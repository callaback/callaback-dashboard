module.exports = [
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/voice/v1/archivedCall.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Voice
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ArchivedCallContextImpl = void 0;
exports.ArchivedCallListInstance = ArchivedCallListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
class ArchivedCallContextImpl {
    constructor(_version, date, sid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(date)) {
            throw new Error("Parameter 'date' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(sid)) {
            throw new Error("Parameter 'sid' is not valid.");
        }
        this._solution = {
            date,
            sid
        };
        this._uri = `/Archives/${date}/Calls/${sid}`;
    }
    remove(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.remove({
            uri: instance._uri,
            method: "delete",
            headers
        });
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    removeWithHttpInfo(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version;
        // DELETE operation - returns boolean based on status code
        let operationPromise = operationVersion.removeWithResponseInfo({
            uri: instance._uri,
            method: "delete",
            headers
        }).then((response)=>({
                ...response,
                body: response.statusCode === 204
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.ArchivedCallContextImpl = ArchivedCallContextImpl;
function ArchivedCallListInstance(version) {
    const instance = (date, sid)=>instance.get(date, sid);
    instance.get = function get(date, sid) {
        return new ArchivedCallContextImpl(version, date, sid);
    };
    instance._version = version;
    instance._solution = {};
    instance._uri = ``;
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/voice/v1/byocTrunk.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Voice
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ByocTrunkPage = exports.ByocTrunkInstance = exports.ByocTrunkContextImpl = void 0;
exports.ByocTrunkListInstance = ByocTrunkListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
class ByocTrunkContextImpl {
    constructor(_version, sid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(sid)) {
            throw new Error("Parameter 'sid' is not valid.");
        }
        this._solution = {
            sid
        };
        this._uri = `/ByocTrunks/${sid}`;
    }
    remove(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.remove({
            uri: instance._uri,
            method: "delete",
            headers
        });
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    removeWithHttpInfo(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version;
        // DELETE operation - returns boolean based on status code
        let operationPromise = operationVersion.removeWithResponseInfo({
            uri: instance._uri,
            method: "delete",
            headers
        }).then((response)=>({
                ...response,
                body: response.statusCode === 204
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new ByocTrunkInstance(operationVersion, payload, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new ByocTrunkInstance(operationVersion, response.body, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    update(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["voiceUrl"] !== undefined) data["VoiceUrl"] = params["voiceUrl"];
        if (params["voiceMethod"] !== undefined) data["VoiceMethod"] = params["voiceMethod"];
        if (params["voiceFallbackUrl"] !== undefined) data["VoiceFallbackUrl"] = params["voiceFallbackUrl"];
        if (params["voiceFallbackMethod"] !== undefined) data["VoiceFallbackMethod"] = params["voiceFallbackMethod"];
        if (params["statusCallbackUrl"] !== undefined) data["StatusCallbackUrl"] = params["statusCallbackUrl"];
        if (params["statusCallbackMethod"] !== undefined) data["StatusCallbackMethod"] = params["statusCallbackMethod"];
        if (params["cnamLookupEnabled"] !== undefined) data["CnamLookupEnabled"] = serialize.bool(params["cnamLookupEnabled"]);
        if (params["connectionPolicySid"] !== undefined) data["ConnectionPolicySid"] = params["connectionPolicySid"];
        if (params["fromDomainSid"] !== undefined) data["FromDomainSid"] = params["fromDomainSid"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.update({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new ByocTrunkInstance(operationVersion, payload, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    updateWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["voiceUrl"] !== undefined) data["VoiceUrl"] = params["voiceUrl"];
        if (params["voiceMethod"] !== undefined) data["VoiceMethod"] = params["voiceMethod"];
        if (params["voiceFallbackUrl"] !== undefined) data["VoiceFallbackUrl"] = params["voiceFallbackUrl"];
        if (params["voiceFallbackMethod"] !== undefined) data["VoiceFallbackMethod"] = params["voiceFallbackMethod"];
        if (params["statusCallbackUrl"] !== undefined) data["StatusCallbackUrl"] = params["statusCallbackUrl"];
        if (params["statusCallbackMethod"] !== undefined) data["StatusCallbackMethod"] = params["statusCallbackMethod"];
        if (params["cnamLookupEnabled"] !== undefined) data["CnamLookupEnabled"] = serialize.bool(params["cnamLookupEnabled"]);
        if (params["connectionPolicySid"] !== undefined) data["ConnectionPolicySid"] = params["connectionPolicySid"];
        if (params["fromDomainSid"] !== undefined) data["FromDomainSid"] = params["fromDomainSid"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.updateWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new ByocTrunkInstance(operationVersion, response.body, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.ByocTrunkContextImpl = ByocTrunkContextImpl;
class ByocTrunkInstance {
    constructor(_version, payload, sid){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.sid = payload.sid;
        this.friendlyName = payload.friendly_name;
        this.voiceUrl = payload.voice_url;
        this.voiceMethod = payload.voice_method;
        this.voiceFallbackUrl = payload.voice_fallback_url;
        this.voiceFallbackMethod = payload.voice_fallback_method;
        this.statusCallbackUrl = payload.status_callback_url;
        this.statusCallbackMethod = payload.status_callback_method;
        this.cnamLookupEnabled = payload.cnam_lookup_enabled;
        this.connectionPolicySid = payload.connection_policy_sid;
        this.fromDomainSid = payload.from_domain_sid;
        this.dateCreated = deserialize.iso8601DateTime(payload.date_created);
        this.dateUpdated = deserialize.iso8601DateTime(payload.date_updated);
        this.url = payload.url;
        this._solution = {
            sid: sid || this.sid
        };
    }
    get _proxy() {
        this._context = this._context || new ByocTrunkContextImpl(this._version, this._solution.sid);
        return this._context;
    }
    /**
     * Remove a ByocTrunkInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean
     */ remove(callback) {
        return this._proxy.remove(callback);
    }
    /**
     * Remove a ByocTrunkInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean with HTTP metadata
     */ removeWithHttpInfo(callback) {
        return this._proxy.removeWithHttpInfo(callback);
    }
    /**
     * Fetch a ByocTrunkInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed ByocTrunkInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a ByocTrunkInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed ByocTrunkInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    update(params, callback) {
        return this._proxy.update(params, callback);
    }
    updateWithHttpInfo(params, callback) {
        return this._proxy.updateWithHttpInfo(params, callback);
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            sid: this.sid,
            friendlyName: this.friendlyName,
            voiceUrl: this.voiceUrl,
            voiceMethod: this.voiceMethod,
            voiceFallbackUrl: this.voiceFallbackUrl,
            voiceFallbackMethod: this.voiceFallbackMethod,
            statusCallbackUrl: this.statusCallbackUrl,
            statusCallbackMethod: this.statusCallbackMethod,
            cnamLookupEnabled: this.cnamLookupEnabled,
            connectionPolicySid: this.connectionPolicySid,
            fromDomainSid: this.fromDomainSid,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated,
            url: this.url
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.ByocTrunkInstance = ByocTrunkInstance;
function ByocTrunkListInstance(version) {
    const instance = (sid)=>instance.get(sid);
    instance.get = function get(sid) {
        return new ByocTrunkContextImpl(version, sid);
    };
    instance._version = version;
    instance._solution = {};
    instance._uri = `/ByocTrunks`;
    instance.create = function create(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["voiceUrl"] !== undefined) data["VoiceUrl"] = params["voiceUrl"];
        if (params["voiceMethod"] !== undefined) data["VoiceMethod"] = params["voiceMethod"];
        if (params["voiceFallbackUrl"] !== undefined) data["VoiceFallbackUrl"] = params["voiceFallbackUrl"];
        if (params["voiceFallbackMethod"] !== undefined) data["VoiceFallbackMethod"] = params["voiceFallbackMethod"];
        if (params["statusCallbackUrl"] !== undefined) data["StatusCallbackUrl"] = params["statusCallbackUrl"];
        if (params["statusCallbackMethod"] !== undefined) data["StatusCallbackMethod"] = params["statusCallbackMethod"];
        if (params["cnamLookupEnabled"] !== undefined) data["CnamLookupEnabled"] = serialize.bool(params["cnamLookupEnabled"]);
        if (params["connectionPolicySid"] !== undefined) data["ConnectionPolicySid"] = params["connectionPolicySid"];
        if (params["fromDomainSid"] !== undefined) data["FromDomainSid"] = params["fromDomainSid"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.create({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new ByocTrunkInstance(operationVersion, payload));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.createWithHttpInfo = function createWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["voiceUrl"] !== undefined) data["VoiceUrl"] = params["voiceUrl"];
        if (params["voiceMethod"] !== undefined) data["VoiceMethod"] = params["voiceMethod"];
        if (params["voiceFallbackUrl"] !== undefined) data["VoiceFallbackUrl"] = params["voiceFallbackUrl"];
        if (params["voiceFallbackMethod"] !== undefined) data["VoiceFallbackMethod"] = params["voiceFallbackMethod"];
        if (params["statusCallbackUrl"] !== undefined) data["StatusCallbackUrl"] = params["statusCallbackUrl"];
        if (params["statusCallbackMethod"] !== undefined) data["StatusCallbackMethod"] = params["statusCallbackMethod"];
        if (params["cnamLookupEnabled"] !== undefined) data["CnamLookupEnabled"] = serialize.bool(params["cnamLookupEnabled"]);
        if (params["connectionPolicySid"] !== undefined) data["ConnectionPolicySid"] = params["connectionPolicySid"];
        if (params["fromDomainSid"] !== undefined) data["FromDomainSid"] = params["fromDomainSid"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.createWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new ByocTrunkInstance(operationVersion, response.body)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new ByocTrunkPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new ByocTrunkPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new ByocTrunkPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new ByocTrunkPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class ByocTrunkPage extends Page_1.default {
    /**
     * Initialize the ByocTrunkPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of ByocTrunkInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new ByocTrunkInstance(this._version, payload);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.ByocTrunkPage = ByocTrunkPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/voice/v1/connectionPolicy/connectionPolicyTarget.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Voice
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConnectionPolicyTargetPage = exports.ConnectionPolicyTargetInstance = exports.ConnectionPolicyTargetContextImpl = void 0;
exports.ConnectionPolicyTargetListInstance = ConnectionPolicyTargetListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
class ConnectionPolicyTargetContextImpl {
    constructor(_version, connectionPolicySid, sid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(connectionPolicySid)) {
            throw new Error("Parameter 'connectionPolicySid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(sid)) {
            throw new Error("Parameter 'sid' is not valid.");
        }
        this._solution = {
            connectionPolicySid,
            sid
        };
        this._uri = `/ConnectionPolicies/${connectionPolicySid}/Targets/${sid}`;
    }
    remove(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.remove({
            uri: instance._uri,
            method: "delete",
            headers
        });
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    removeWithHttpInfo(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version;
        // DELETE operation - returns boolean based on status code
        let operationPromise = operationVersion.removeWithResponseInfo({
            uri: instance._uri,
            method: "delete",
            headers
        }).then((response)=>({
                ...response,
                body: response.statusCode === 204
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new ConnectionPolicyTargetInstance(operationVersion, payload, instance._solution.connectionPolicySid, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new ConnectionPolicyTargetInstance(operationVersion, response.body, instance._solution.connectionPolicySid, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    update(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["target"] !== undefined) data["Target"] = params["target"];
        if (params["priority"] !== undefined) data["Priority"] = params["priority"];
        if (params["weight"] !== undefined) data["Weight"] = params["weight"];
        if (params["enabled"] !== undefined) data["Enabled"] = serialize.bool(params["enabled"]);
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.update({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new ConnectionPolicyTargetInstance(operationVersion, payload, instance._solution.connectionPolicySid, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    updateWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["target"] !== undefined) data["Target"] = params["target"];
        if (params["priority"] !== undefined) data["Priority"] = params["priority"];
        if (params["weight"] !== undefined) data["Weight"] = params["weight"];
        if (params["enabled"] !== undefined) data["Enabled"] = serialize.bool(params["enabled"]);
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.updateWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new ConnectionPolicyTargetInstance(operationVersion, response.body, instance._solution.connectionPolicySid, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.ConnectionPolicyTargetContextImpl = ConnectionPolicyTargetContextImpl;
class ConnectionPolicyTargetInstance {
    constructor(_version, payload, connectionPolicySid, sid){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.connectionPolicySid = payload.connection_policy_sid;
        this.sid = payload.sid;
        this.friendlyName = payload.friendly_name;
        this.target = payload.target;
        this.priority = deserialize.integer(payload.priority);
        this.weight = deserialize.integer(payload.weight);
        this.enabled = payload.enabled;
        this.dateCreated = deserialize.iso8601DateTime(payload.date_created);
        this.dateUpdated = deserialize.iso8601DateTime(payload.date_updated);
        this.url = payload.url;
        this._solution = {
            connectionPolicySid,
            sid: sid || this.sid
        };
    }
    get _proxy() {
        this._context = this._context || new ConnectionPolicyTargetContextImpl(this._version, this._solution.connectionPolicySid, this._solution.sid);
        return this._context;
    }
    /**
     * Remove a ConnectionPolicyTargetInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean
     */ remove(callback) {
        return this._proxy.remove(callback);
    }
    /**
     * Remove a ConnectionPolicyTargetInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean with HTTP metadata
     */ removeWithHttpInfo(callback) {
        return this._proxy.removeWithHttpInfo(callback);
    }
    /**
     * Fetch a ConnectionPolicyTargetInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed ConnectionPolicyTargetInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a ConnectionPolicyTargetInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed ConnectionPolicyTargetInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    update(params, callback) {
        return this._proxy.update(params, callback);
    }
    updateWithHttpInfo(params, callback) {
        return this._proxy.updateWithHttpInfo(params, callback);
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            connectionPolicySid: this.connectionPolicySid,
            sid: this.sid,
            friendlyName: this.friendlyName,
            target: this.target,
            priority: this.priority,
            weight: this.weight,
            enabled: this.enabled,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated,
            url: this.url
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.ConnectionPolicyTargetInstance = ConnectionPolicyTargetInstance;
function ConnectionPolicyTargetListInstance(version, connectionPolicySid) {
    if (!(0, utility_1.isValidPathParam)(connectionPolicySid)) {
        throw new Error("Parameter 'connectionPolicySid' is not valid.");
    }
    const instance = (sid)=>instance.get(sid);
    instance.get = function get(sid) {
        return new ConnectionPolicyTargetContextImpl(version, connectionPolicySid, sid);
    };
    instance._version = version;
    instance._solution = {
        connectionPolicySid
    };
    instance._uri = `/ConnectionPolicies/${connectionPolicySid}/Targets`;
    instance.create = function create(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["target"] === null || params["target"] === undefined) {
            throw new Error("Required parameter \"params['target']\" missing.");
        }
        let data = {};
        data["Target"] = params["target"];
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["priority"] !== undefined) data["Priority"] = params["priority"];
        if (params["weight"] !== undefined) data["Weight"] = params["weight"];
        if (params["enabled"] !== undefined) data["Enabled"] = serialize.bool(params["enabled"]);
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.create({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new ConnectionPolicyTargetInstance(operationVersion, payload, instance._solution.connectionPolicySid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.createWithHttpInfo = function createWithHttpInfo(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["target"] === null || params["target"] === undefined) {
            throw new Error("Required parameter \"params['target']\" missing.");
        }
        let data = {};
        data["Target"] = params["target"];
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["priority"] !== undefined) data["Priority"] = params["priority"];
        if (params["weight"] !== undefined) data["Weight"] = params["weight"];
        if (params["enabled"] !== undefined) data["Enabled"] = serialize.bool(params["enabled"]);
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.createWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new ConnectionPolicyTargetInstance(operationVersion, response.body, instance._solution.connectionPolicySid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new ConnectionPolicyTargetPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new ConnectionPolicyTargetPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new ConnectionPolicyTargetPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new ConnectionPolicyTargetPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class ConnectionPolicyTargetPage extends Page_1.default {
    /**
     * Initialize the ConnectionPolicyTargetPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of ConnectionPolicyTargetInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new ConnectionPolicyTargetInstance(this._version, payload, this._solution.connectionPolicySid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.ConnectionPolicyTargetPage = ConnectionPolicyTargetPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/voice/v1/connectionPolicy.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Voice
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConnectionPolicyPage = exports.ConnectionPolicyInstance = exports.ConnectionPolicyContextImpl = void 0;
exports.ConnectionPolicyListInstance = ConnectionPolicyListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
const connectionPolicyTarget_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/voice/v1/connectionPolicy/connectionPolicyTarget.js [app-route] (ecmascript)");
class ConnectionPolicyContextImpl {
    constructor(_version, sid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(sid)) {
            throw new Error("Parameter 'sid' is not valid.");
        }
        this._solution = {
            sid
        };
        this._uri = `/ConnectionPolicies/${sid}`;
    }
    get targets() {
        this._targets = this._targets || (0, connectionPolicyTarget_1.ConnectionPolicyTargetListInstance)(this._version, this._solution.sid);
        return this._targets;
    }
    remove(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.remove({
            uri: instance._uri,
            method: "delete",
            headers
        });
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    removeWithHttpInfo(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version;
        // DELETE operation - returns boolean based on status code
        let operationPromise = operationVersion.removeWithResponseInfo({
            uri: instance._uri,
            method: "delete",
            headers
        }).then((response)=>({
                ...response,
                body: response.statusCode === 204
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new ConnectionPolicyInstance(operationVersion, payload, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new ConnectionPolicyInstance(operationVersion, response.body, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    update(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.update({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new ConnectionPolicyInstance(operationVersion, payload, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    updateWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.updateWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new ConnectionPolicyInstance(operationVersion, response.body, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.ConnectionPolicyContextImpl = ConnectionPolicyContextImpl;
class ConnectionPolicyInstance {
    constructor(_version, payload, sid){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.sid = payload.sid;
        this.friendlyName = payload.friendly_name;
        this.dateCreated = deserialize.iso8601DateTime(payload.date_created);
        this.dateUpdated = deserialize.iso8601DateTime(payload.date_updated);
        this.url = payload.url;
        this.links = payload.links;
        this._solution = {
            sid: sid || this.sid
        };
    }
    get _proxy() {
        this._context = this._context || new ConnectionPolicyContextImpl(this._version, this._solution.sid);
        return this._context;
    }
    /**
     * Remove a ConnectionPolicyInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean
     */ remove(callback) {
        return this._proxy.remove(callback);
    }
    /**
     * Remove a ConnectionPolicyInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean with HTTP metadata
     */ removeWithHttpInfo(callback) {
        return this._proxy.removeWithHttpInfo(callback);
    }
    /**
     * Fetch a ConnectionPolicyInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed ConnectionPolicyInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a ConnectionPolicyInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed ConnectionPolicyInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    update(params, callback) {
        return this._proxy.update(params, callback);
    }
    updateWithHttpInfo(params, callback) {
        return this._proxy.updateWithHttpInfo(params, callback);
    }
    /**
     * Access the targets.
     */ targets() {
        return this._proxy.targets;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            sid: this.sid,
            friendlyName: this.friendlyName,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated,
            url: this.url,
            links: this.links
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.ConnectionPolicyInstance = ConnectionPolicyInstance;
function ConnectionPolicyListInstance(version) {
    const instance = (sid)=>instance.get(sid);
    instance.get = function get(sid) {
        return new ConnectionPolicyContextImpl(version, sid);
    };
    instance._version = version;
    instance._solution = {};
    instance._uri = `/ConnectionPolicies`;
    instance.create = function create(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.create({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new ConnectionPolicyInstance(operationVersion, payload));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.createWithHttpInfo = function createWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.createWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new ConnectionPolicyInstance(operationVersion, response.body)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new ConnectionPolicyPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new ConnectionPolicyPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new ConnectionPolicyPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new ConnectionPolicyPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class ConnectionPolicyPage extends Page_1.default {
    /**
     * Initialize the ConnectionPolicyPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of ConnectionPolicyInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new ConnectionPolicyInstance(this._version, payload);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.ConnectionPolicyPage = ConnectionPolicyPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/voice/v1/dialingPermissions/bulkCountryUpdate.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Voice
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BulkCountryUpdateInstance = void 0;
exports.BulkCountryUpdateListInstance = BulkCountryUpdateListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
function BulkCountryUpdateListInstance(version) {
    const instance = {};
    instance._version = version;
    instance._solution = {};
    instance._uri = `/DialingPermissions/BulkCountryUpdates`;
    instance.create = function create(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["updateRequest"] === null || params["updateRequest"] === undefined) {
            throw new Error("Required parameter \"params['updateRequest']\" missing.");
        }
        let data = {};
        data["UpdateRequest"] = params["updateRequest"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.create({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new BulkCountryUpdateInstance(operationVersion, payload));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.createWithHttpInfo = function createWithHttpInfo(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["updateRequest"] === null || params["updateRequest"] === undefined) {
            throw new Error("Required parameter \"params['updateRequest']\" missing.");
        }
        let data = {};
        data["UpdateRequest"] = params["updateRequest"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.createWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new BulkCountryUpdateInstance(operationVersion, response.body)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class BulkCountryUpdateInstance {
    constructor(_version, payload){
        this._version = _version;
        this.updateCount = deserialize.integer(payload.update_count);
        this.updateRequest = payload.update_request;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            updateCount: this.updateCount,
            updateRequest: this.updateRequest
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.BulkCountryUpdateInstance = BulkCountryUpdateInstance;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/voice/v1/dialingPermissions/country/highriskSpecialPrefix.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Voice
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.HighriskSpecialPrefixPage = exports.HighriskSpecialPrefixInstance = void 0;
exports.HighriskSpecialPrefixListInstance = HighriskSpecialPrefixListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
function HighriskSpecialPrefixListInstance(version, isoCode) {
    if (!(0, utility_1.isValidPathParam)(isoCode)) {
        throw new Error("Parameter 'isoCode' is not valid.");
    }
    const instance = {};
    instance._version = version;
    instance._solution = {
        isoCode
    };
    instance._uri = `/DialingPermissions/Countries/${isoCode}/HighRiskSpecialPrefixes`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new HighriskSpecialPrefixPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new HighriskSpecialPrefixPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new HighriskSpecialPrefixPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new HighriskSpecialPrefixPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class HighriskSpecialPrefixInstance {
    constructor(_version, payload, isoCode){
        this._version = _version;
        this.prefix = payload.prefix;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            prefix: this.prefix
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.HighriskSpecialPrefixInstance = HighriskSpecialPrefixInstance;
class HighriskSpecialPrefixPage extends Page_1.default {
    /**
     * Initialize the HighriskSpecialPrefixPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of HighriskSpecialPrefixInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new HighriskSpecialPrefixInstance(this._version, payload, this._solution.isoCode);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.HighriskSpecialPrefixPage = HighriskSpecialPrefixPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/voice/v1/dialingPermissions/country.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Voice
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CountryPage = exports.CountryInstance = exports.CountryContextImpl = void 0;
exports.CountryListInstance = CountryListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
const highriskSpecialPrefix_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/voice/v1/dialingPermissions/country/highriskSpecialPrefix.js [app-route] (ecmascript)");
class CountryContextImpl {
    constructor(_version, isoCode){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(isoCode)) {
            throw new Error("Parameter 'isoCode' is not valid.");
        }
        this._solution = {
            isoCode
        };
        this._uri = `/DialingPermissions/Countries/${isoCode}`;
    }
    get highriskSpecialPrefixes() {
        this._highriskSpecialPrefixes = this._highriskSpecialPrefixes || (0, highriskSpecialPrefix_1.HighriskSpecialPrefixListInstance)(this._version, this._solution.isoCode);
        return this._highriskSpecialPrefixes;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new CountryInstance(operationVersion, payload, instance._solution.isoCode));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new CountryInstance(operationVersion, response.body, instance._solution.isoCode)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.CountryContextImpl = CountryContextImpl;
class CountryInstance {
    constructor(_version, payload, isoCode){
        this._version = _version;
        this.isoCode = payload.iso_code;
        this.name = payload.name;
        this.continent = payload.continent;
        this.countryCodes = payload.country_codes;
        this.lowRiskNumbersEnabled = payload.low_risk_numbers_enabled;
        this.highRiskSpecialNumbersEnabled = payload.high_risk_special_numbers_enabled;
        this.highRiskTollfraudNumbersEnabled = payload.high_risk_tollfraud_numbers_enabled;
        this.url = payload.url;
        this.links = payload.links;
        this._solution = {
            isoCode: isoCode || this.isoCode
        };
    }
    get _proxy() {
        this._context = this._context || new CountryContextImpl(this._version, this._solution.isoCode);
        return this._context;
    }
    /**
     * Fetch a CountryInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed CountryInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a CountryInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed CountryInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    /**
     * Access the highriskSpecialPrefixes.
     */ highriskSpecialPrefixes() {
        return this._proxy.highriskSpecialPrefixes;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            isoCode: this.isoCode,
            name: this.name,
            continent: this.continent,
            countryCodes: this.countryCodes,
            lowRiskNumbersEnabled: this.lowRiskNumbersEnabled,
            highRiskSpecialNumbersEnabled: this.highRiskSpecialNumbersEnabled,
            highRiskTollfraudNumbersEnabled: this.highRiskTollfraudNumbersEnabled,
            url: this.url,
            links: this.links
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.CountryInstance = CountryInstance;
function CountryListInstance(version) {
    const instance = (isoCode)=>instance.get(isoCode);
    instance.get = function get(isoCode) {
        return new CountryContextImpl(version, isoCode);
    };
    instance._version = version;
    instance._solution = {};
    instance._uri = `/DialingPermissions/Countries`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["isoCode"] !== undefined) data["IsoCode"] = params["isoCode"];
        if (params["continent"] !== undefined) data["Continent"] = params["continent"];
        if (params["countryCode"] !== undefined) data["CountryCode"] = params["countryCode"];
        if (params["lowRiskNumbersEnabled"] !== undefined) data["LowRiskNumbersEnabled"] = serialize.bool(params["lowRiskNumbersEnabled"]);
        if (params["highRiskSpecialNumbersEnabled"] !== undefined) data["HighRiskSpecialNumbersEnabled"] = serialize.bool(params["highRiskSpecialNumbersEnabled"]);
        if (params["highRiskTollfraudNumbersEnabled"] !== undefined) data["HighRiskTollfraudNumbersEnabled"] = serialize.bool(params["highRiskTollfraudNumbersEnabled"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new CountryPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new CountryPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["isoCode"] !== undefined) data["IsoCode"] = params["isoCode"];
        if (params["continent"] !== undefined) data["Continent"] = params["continent"];
        if (params["countryCode"] !== undefined) data["CountryCode"] = params["countryCode"];
        if (params["lowRiskNumbersEnabled"] !== undefined) data["LowRiskNumbersEnabled"] = serialize.bool(params["lowRiskNumbersEnabled"]);
        if (params["highRiskSpecialNumbersEnabled"] !== undefined) data["HighRiskSpecialNumbersEnabled"] = serialize.bool(params["highRiskSpecialNumbersEnabled"]);
        if (params["highRiskTollfraudNumbersEnabled"] !== undefined) data["HighRiskTollfraudNumbersEnabled"] = serialize.bool(params["highRiskTollfraudNumbersEnabled"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new CountryPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new CountryPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class CountryPage extends Page_1.default {
    /**
     * Initialize the CountryPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of CountryInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new CountryInstance(this._version, payload);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.CountryPage = CountryPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/voice/v1/dialingPermissions/settings.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Voice
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SettingsInstance = exports.SettingsContextImpl = void 0;
exports.SettingsListInstance = SettingsListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
class SettingsContextImpl {
    constructor(_version){
        this._version = _version;
        this._solution = {};
        this._uri = `/Settings`;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new SettingsInstance(operationVersion, payload));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new SettingsInstance(operationVersion, response.body)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    update(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["dialingPermissionsInheritance"] !== undefined) data["DialingPermissionsInheritance"] = serialize.bool(params["dialingPermissionsInheritance"]);
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.update({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new SettingsInstance(operationVersion, payload));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    updateWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["dialingPermissionsInheritance"] !== undefined) data["DialingPermissionsInheritance"] = serialize.bool(params["dialingPermissionsInheritance"]);
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.updateWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new SettingsInstance(operationVersion, response.body)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.SettingsContextImpl = SettingsContextImpl;
class SettingsInstance {
    constructor(_version, payload){
        this._version = _version;
        this.dialingPermissionsInheritance = payload.dialing_permissions_inheritance;
        this.url = payload.url;
        this._solution = {};
    }
    get _proxy() {
        this._context = this._context || new SettingsContextImpl(this._version);
        return this._context;
    }
    /**
     * Fetch a SettingsInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed SettingsInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a SettingsInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed SettingsInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    update(params, callback) {
        return this._proxy.update(params, callback);
    }
    updateWithHttpInfo(params, callback) {
        return this._proxy.updateWithHttpInfo(params, callback);
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            dialingPermissionsInheritance: this.dialingPermissionsInheritance,
            url: this.url
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.SettingsInstance = SettingsInstance;
function SettingsListInstance(version) {
    const instance = ()=>instance.get();
    instance.get = function get() {
        return new SettingsContextImpl(version);
    };
    instance._version = version;
    instance._solution = {};
    instance._uri = ``;
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/voice/v1/dialingPermissions.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Voice
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DialingPermissionsListInstance = DialingPermissionsListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const bulkCountryUpdate_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/voice/v1/dialingPermissions/bulkCountryUpdate.js [app-route] (ecmascript)");
const country_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/voice/v1/dialingPermissions/country.js [app-route] (ecmascript)");
const settings_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/voice/v1/dialingPermissions/settings.js [app-route] (ecmascript)");
function DialingPermissionsListInstance(version) {
    const instance = {};
    instance._version = version;
    instance._solution = {};
    instance._uri = `/DialingPermissions`;
    Object.defineProperty(instance, "bulkCountryUpdates", {
        get: function bulkCountryUpdates() {
            if (!instance._bulkCountryUpdates) {
                instance._bulkCountryUpdates = (0, bulkCountryUpdate_1.BulkCountryUpdateListInstance)(instance._version);
            }
            return instance._bulkCountryUpdates;
        }
    });
    Object.defineProperty(instance, "countries", {
        get: function countries() {
            if (!instance._countries) {
                instance._countries = (0, country_1.CountryListInstance)(instance._version);
            }
            return instance._countries;
        }
    });
    Object.defineProperty(instance, "settings", {
        get: function settings() {
            if (!instance._settings) {
                instance._settings = (0, settings_1.SettingsListInstance)(instance._version);
            }
            return instance._settings;
        }
    });
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/voice/v1/ipRecord.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Voice
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IpRecordPage = exports.IpRecordInstance = exports.IpRecordContextImpl = void 0;
exports.IpRecordListInstance = IpRecordListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
class IpRecordContextImpl {
    constructor(_version, sid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(sid)) {
            throw new Error("Parameter 'sid' is not valid.");
        }
        this._solution = {
            sid
        };
        this._uri = `/IpRecords/${sid}`;
    }
    remove(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.remove({
            uri: instance._uri,
            method: "delete",
            headers
        });
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    removeWithHttpInfo(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version;
        // DELETE operation - returns boolean based on status code
        let operationPromise = operationVersion.removeWithResponseInfo({
            uri: instance._uri,
            method: "delete",
            headers
        }).then((response)=>({
                ...response,
                body: response.statusCode === 204
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new IpRecordInstance(operationVersion, payload, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new IpRecordInstance(operationVersion, response.body, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    update(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.update({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new IpRecordInstance(operationVersion, payload, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    updateWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.updateWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new IpRecordInstance(operationVersion, response.body, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.IpRecordContextImpl = IpRecordContextImpl;
class IpRecordInstance {
    constructor(_version, payload, sid){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.sid = payload.sid;
        this.friendlyName = payload.friendly_name;
        this.ipAddress = payload.ip_address;
        this.cidrPrefixLength = deserialize.integer(payload.cidr_prefix_length);
        this.dateCreated = deserialize.iso8601DateTime(payload.date_created);
        this.dateUpdated = deserialize.iso8601DateTime(payload.date_updated);
        this.url = payload.url;
        this._solution = {
            sid: sid || this.sid
        };
    }
    get _proxy() {
        this._context = this._context || new IpRecordContextImpl(this._version, this._solution.sid);
        return this._context;
    }
    /**
     * Remove a IpRecordInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean
     */ remove(callback) {
        return this._proxy.remove(callback);
    }
    /**
     * Remove a IpRecordInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean with HTTP metadata
     */ removeWithHttpInfo(callback) {
        return this._proxy.removeWithHttpInfo(callback);
    }
    /**
     * Fetch a IpRecordInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed IpRecordInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a IpRecordInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed IpRecordInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    update(params, callback) {
        return this._proxy.update(params, callback);
    }
    updateWithHttpInfo(params, callback) {
        return this._proxy.updateWithHttpInfo(params, callback);
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            sid: this.sid,
            friendlyName: this.friendlyName,
            ipAddress: this.ipAddress,
            cidrPrefixLength: this.cidrPrefixLength,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated,
            url: this.url
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.IpRecordInstance = IpRecordInstance;
function IpRecordListInstance(version) {
    const instance = (sid)=>instance.get(sid);
    instance.get = function get(sid) {
        return new IpRecordContextImpl(version, sid);
    };
    instance._version = version;
    instance._solution = {};
    instance._uri = `/IpRecords`;
    instance.create = function create(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["ipAddress"] === null || params["ipAddress"] === undefined) {
            throw new Error("Required parameter \"params['ipAddress']\" missing.");
        }
        let data = {};
        data["IpAddress"] = params["ipAddress"];
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["cidrPrefixLength"] !== undefined) data["CidrPrefixLength"] = params["cidrPrefixLength"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.create({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new IpRecordInstance(operationVersion, payload));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.createWithHttpInfo = function createWithHttpInfo(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["ipAddress"] === null || params["ipAddress"] === undefined) {
            throw new Error("Required parameter \"params['ipAddress']\" missing.");
        }
        let data = {};
        data["IpAddress"] = params["ipAddress"];
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["cidrPrefixLength"] !== undefined) data["CidrPrefixLength"] = params["cidrPrefixLength"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.createWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new IpRecordInstance(operationVersion, response.body)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new IpRecordPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new IpRecordPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new IpRecordPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new IpRecordPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class IpRecordPage extends Page_1.default {
    /**
     * Initialize the IpRecordPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of IpRecordInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new IpRecordInstance(this._version, payload);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.IpRecordPage = IpRecordPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/voice/v1/sourceIpMapping.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Voice
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SourceIpMappingPage = exports.SourceIpMappingInstance = exports.SourceIpMappingContextImpl = void 0;
exports.SourceIpMappingListInstance = SourceIpMappingListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
class SourceIpMappingContextImpl {
    constructor(_version, sid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(sid)) {
            throw new Error("Parameter 'sid' is not valid.");
        }
        this._solution = {
            sid
        };
        this._uri = `/SourceIpMappings/${sid}`;
    }
    remove(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.remove({
            uri: instance._uri,
            method: "delete",
            headers
        });
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    removeWithHttpInfo(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version;
        // DELETE operation - returns boolean based on status code
        let operationPromise = operationVersion.removeWithResponseInfo({
            uri: instance._uri,
            method: "delete",
            headers
        }).then((response)=>({
                ...response,
                body: response.statusCode === 204
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new SourceIpMappingInstance(operationVersion, payload, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new SourceIpMappingInstance(operationVersion, response.body, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    update(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["sipDomainSid"] === null || params["sipDomainSid"] === undefined) {
            throw new Error("Required parameter \"params['sipDomainSid']\" missing.");
        }
        let data = {};
        data["SipDomainSid"] = params["sipDomainSid"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.update({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new SourceIpMappingInstance(operationVersion, payload, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    updateWithHttpInfo(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["sipDomainSid"] === null || params["sipDomainSid"] === undefined) {
            throw new Error("Required parameter \"params['sipDomainSid']\" missing.");
        }
        let data = {};
        data["SipDomainSid"] = params["sipDomainSid"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.updateWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new SourceIpMappingInstance(operationVersion, response.body, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.SourceIpMappingContextImpl = SourceIpMappingContextImpl;
class SourceIpMappingInstance {
    constructor(_version, payload, sid){
        this._version = _version;
        this.sid = payload.sid;
        this.ipRecordSid = payload.ip_record_sid;
        this.sipDomainSid = payload.sip_domain_sid;
        this.dateCreated = deserialize.iso8601DateTime(payload.date_created);
        this.dateUpdated = deserialize.iso8601DateTime(payload.date_updated);
        this.url = payload.url;
        this._solution = {
            sid: sid || this.sid
        };
    }
    get _proxy() {
        this._context = this._context || new SourceIpMappingContextImpl(this._version, this._solution.sid);
        return this._context;
    }
    /**
     * Remove a SourceIpMappingInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean
     */ remove(callback) {
        return this._proxy.remove(callback);
    }
    /**
     * Remove a SourceIpMappingInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean with HTTP metadata
     */ removeWithHttpInfo(callback) {
        return this._proxy.removeWithHttpInfo(callback);
    }
    /**
     * Fetch a SourceIpMappingInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed SourceIpMappingInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a SourceIpMappingInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed SourceIpMappingInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    update(params, callback) {
        return this._proxy.update(params, callback);
    }
    updateWithHttpInfo(params, callback) {
        return this._proxy.updateWithHttpInfo(params, callback);
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            sid: this.sid,
            ipRecordSid: this.ipRecordSid,
            sipDomainSid: this.sipDomainSid,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated,
            url: this.url
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.SourceIpMappingInstance = SourceIpMappingInstance;
function SourceIpMappingListInstance(version) {
    const instance = (sid)=>instance.get(sid);
    instance.get = function get(sid) {
        return new SourceIpMappingContextImpl(version, sid);
    };
    instance._version = version;
    instance._solution = {};
    instance._uri = `/SourceIpMappings`;
    instance.create = function create(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["ipRecordSid"] === null || params["ipRecordSid"] === undefined) {
            throw new Error("Required parameter \"params['ipRecordSid']\" missing.");
        }
        if (params["sipDomainSid"] === null || params["sipDomainSid"] === undefined) {
            throw new Error("Required parameter \"params['sipDomainSid']\" missing.");
        }
        let data = {};
        data["IpRecordSid"] = params["ipRecordSid"];
        data["SipDomainSid"] = params["sipDomainSid"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.create({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new SourceIpMappingInstance(operationVersion, payload));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.createWithHttpInfo = function createWithHttpInfo(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["ipRecordSid"] === null || params["ipRecordSid"] === undefined) {
            throw new Error("Required parameter \"params['ipRecordSid']\" missing.");
        }
        if (params["sipDomainSid"] === null || params["sipDomainSid"] === undefined) {
            throw new Error("Required parameter \"params['sipDomainSid']\" missing.");
        }
        let data = {};
        data["IpRecordSid"] = params["ipRecordSid"];
        data["SipDomainSid"] = params["sipDomainSid"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.createWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new SourceIpMappingInstance(operationVersion, response.body)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new SourceIpMappingPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new SourceIpMappingPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new SourceIpMappingPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new SourceIpMappingPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class SourceIpMappingPage extends Page_1.default {
    /**
     * Initialize the SourceIpMappingPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of SourceIpMappingInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new SourceIpMappingInstance(this._version, payload);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.SourceIpMappingPage = SourceIpMappingPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/voice/V1.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Voice
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
const Version_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Version.js [app-route] (ecmascript)"));
const archivedCall_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/voice/v1/archivedCall.js [app-route] (ecmascript)");
const byocTrunk_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/voice/v1/byocTrunk.js [app-route] (ecmascript)");
const connectionPolicy_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/voice/v1/connectionPolicy.js [app-route] (ecmascript)");
const dialingPermissions_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/voice/v1/dialingPermissions.js [app-route] (ecmascript)");
const ipRecord_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/voice/v1/ipRecord.js [app-route] (ecmascript)");
const sourceIpMapping_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/voice/v1/sourceIpMapping.js [app-route] (ecmascript)");
class V1 extends Version_1.default {
    /**
     * Initialize the V1 version of Voice
     *
     * @param domain - The Twilio (Twilio.Voice) domain
     */ constructor(domain){
        super(domain, "v1");
    }
    /** Getter for archivedCalls resource */ get archivedCalls() {
        this._archivedCalls = this._archivedCalls || (0, archivedCall_1.ArchivedCallListInstance)(this);
        return this._archivedCalls;
    }
    /** Getter for byocTrunks resource */ get byocTrunks() {
        this._byocTrunks = this._byocTrunks || (0, byocTrunk_1.ByocTrunkListInstance)(this);
        return this._byocTrunks;
    }
    /** Getter for connectionPolicies resource */ get connectionPolicies() {
        this._connectionPolicies = this._connectionPolicies || (0, connectionPolicy_1.ConnectionPolicyListInstance)(this);
        return this._connectionPolicies;
    }
    /** Getter for dialingPermissions resource */ get dialingPermissions() {
        this._dialingPermissions = this._dialingPermissions || (0, dialingPermissions_1.DialingPermissionsListInstance)(this);
        return this._dialingPermissions;
    }
    /** Getter for ipRecords resource */ get ipRecords() {
        this._ipRecords = this._ipRecords || (0, ipRecord_1.IpRecordListInstance)(this);
        return this._ipRecords;
    }
    /** Getter for sourceIpMappings resource */ get sourceIpMappings() {
        this._sourceIpMappings = this._sourceIpMappings || (0, sourceIpMapping_1.SourceIpMappingListInstance)(this);
        return this._sourceIpMappings;
    }
}
exports.default = V1;
}),
];

//# sourceMappingURL=96e98_twilio_lib_rest_voice_773b5694._.js.map