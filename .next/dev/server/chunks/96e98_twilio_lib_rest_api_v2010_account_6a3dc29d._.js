module.exports = [
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/address/dependentPhoneNumber.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DependentPhoneNumberPage = exports.DependentPhoneNumberInstance = void 0;
exports.DependentPhoneNumberListInstance = DependentPhoneNumberListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
function DependentPhoneNumberListInstance(version, accountSid, addressSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    if (!(0, utility_1.isValidPathParam)(addressSid)) {
        throw new Error("Parameter 'addressSid' is not valid.");
    }
    const instance = {};
    instance._version = version;
    instance._solution = {
        accountSid,
        addressSid
    };
    instance._uri = `/Accounts/${accountSid}/Addresses/${addressSid}/DependentPhoneNumbers.json`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new DependentPhoneNumberPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new DependentPhoneNumberPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new DependentPhoneNumberPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new DependentPhoneNumberPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class DependentPhoneNumberInstance {
    constructor(_version, payload, accountSid, addressSid){
        this._version = _version;
        this.sid = payload.sid;
        this.accountSid = payload.account_sid;
        this.friendlyName = payload.friendly_name;
        this.phoneNumber = payload.phone_number;
        this.voiceUrl = payload.voice_url;
        this.voiceMethod = payload.voice_method;
        this.voiceFallbackMethod = payload.voice_fallback_method;
        this.voiceFallbackUrl = payload.voice_fallback_url;
        this.voiceCallerIdLookup = payload.voice_caller_id_lookup;
        this.dateCreated = deserialize.rfc2822DateTime(payload.date_created);
        this.dateUpdated = deserialize.rfc2822DateTime(payload.date_updated);
        this.smsFallbackMethod = payload.sms_fallback_method;
        this.smsFallbackUrl = payload.sms_fallback_url;
        this.smsMethod = payload.sms_method;
        this.smsUrl = payload.sms_url;
        this.addressRequirements = payload.address_requirements;
        this.capabilities = payload.capabilities;
        this.statusCallback = payload.status_callback;
        this.statusCallbackMethod = payload.status_callback_method;
        this.apiVersion = payload.api_version;
        this.smsApplicationSid = payload.sms_application_sid;
        this.voiceApplicationSid = payload.voice_application_sid;
        this.trunkSid = payload.trunk_sid;
        this.emergencyStatus = payload.emergency_status;
        this.emergencyAddressSid = payload.emergency_address_sid;
        this.uri = payload.uri;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            sid: this.sid,
            accountSid: this.accountSid,
            friendlyName: this.friendlyName,
            phoneNumber: this.phoneNumber,
            voiceUrl: this.voiceUrl,
            voiceMethod: this.voiceMethod,
            voiceFallbackMethod: this.voiceFallbackMethod,
            voiceFallbackUrl: this.voiceFallbackUrl,
            voiceCallerIdLookup: this.voiceCallerIdLookup,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated,
            smsFallbackMethod: this.smsFallbackMethod,
            smsFallbackUrl: this.smsFallbackUrl,
            smsMethod: this.smsMethod,
            smsUrl: this.smsUrl,
            addressRequirements: this.addressRequirements,
            capabilities: this.capabilities,
            statusCallback: this.statusCallback,
            statusCallbackMethod: this.statusCallbackMethod,
            apiVersion: this.apiVersion,
            smsApplicationSid: this.smsApplicationSid,
            voiceApplicationSid: this.voiceApplicationSid,
            trunkSid: this.trunkSid,
            emergencyStatus: this.emergencyStatus,
            emergencyAddressSid: this.emergencyAddressSid,
            uri: this.uri
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.DependentPhoneNumberInstance = DependentPhoneNumberInstance;
class DependentPhoneNumberPage extends Page_1.default {
    /**
     * Initialize the DependentPhoneNumberPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of DependentPhoneNumberInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new DependentPhoneNumberInstance(this._version, payload, this._solution.accountSid, this._solution.addressSid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.DependentPhoneNumberPage = DependentPhoneNumberPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/address.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AddressPage = exports.AddressInstance = exports.AddressContextImpl = void 0;
exports.AddressListInstance = AddressListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
const dependentPhoneNumber_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/address/dependentPhoneNumber.js [app-route] (ecmascript)");
class AddressContextImpl {
    constructor(_version, accountSid, sid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(accountSid)) {
            throw new Error("Parameter 'accountSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(sid)) {
            throw new Error("Parameter 'sid' is not valid.");
        }
        this._solution = {
            accountSid,
            sid
        };
        this._uri = `/Accounts/${accountSid}/Addresses/${sid}.json`;
    }
    get dependentPhoneNumbers() {
        this._dependentPhoneNumbers = this._dependentPhoneNumbers || (0, dependentPhoneNumber_1.DependentPhoneNumberListInstance)(this._version, this._solution.accountSid, this._solution.sid);
        return this._dependentPhoneNumbers;
    }
    remove(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.remove({
            uri: instance._uri,
            method: "delete",
            headers
        });
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    removeWithHttpInfo(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version;
        // DELETE operation - returns boolean based on status code
        let operationPromise = operationVersion.removeWithResponseInfo({
            uri: instance._uri,
            method: "delete",
            headers
        }).then((response)=>({
                ...response,
                body: response.statusCode === 204
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new AddressInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new AddressInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    update(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["customerName"] !== undefined) data["CustomerName"] = params["customerName"];
        if (params["street"] !== undefined) data["Street"] = params["street"];
        if (params["city"] !== undefined) data["City"] = params["city"];
        if (params["region"] !== undefined) data["Region"] = params["region"];
        if (params["postalCode"] !== undefined) data["PostalCode"] = params["postalCode"];
        if (params["emergencyEnabled"] !== undefined) data["EmergencyEnabled"] = serialize.bool(params["emergencyEnabled"]);
        if (params["autoCorrectAddress"] !== undefined) data["AutoCorrectAddress"] = serialize.bool(params["autoCorrectAddress"]);
        if (params["streetSecondary"] !== undefined) data["StreetSecondary"] = params["streetSecondary"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.update({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new AddressInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    updateWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["customerName"] !== undefined) data["CustomerName"] = params["customerName"];
        if (params["street"] !== undefined) data["Street"] = params["street"];
        if (params["city"] !== undefined) data["City"] = params["city"];
        if (params["region"] !== undefined) data["Region"] = params["region"];
        if (params["postalCode"] !== undefined) data["PostalCode"] = params["postalCode"];
        if (params["emergencyEnabled"] !== undefined) data["EmergencyEnabled"] = serialize.bool(params["emergencyEnabled"]);
        if (params["autoCorrectAddress"] !== undefined) data["AutoCorrectAddress"] = serialize.bool(params["autoCorrectAddress"]);
        if (params["streetSecondary"] !== undefined) data["StreetSecondary"] = params["streetSecondary"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.updateWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new AddressInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.AddressContextImpl = AddressContextImpl;
class AddressInstance {
    constructor(_version, payload, accountSid, sid){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.city = payload.city;
        this.customerName = payload.customer_name;
        this.dateCreated = deserialize.rfc2822DateTime(payload.date_created);
        this.dateUpdated = deserialize.rfc2822DateTime(payload.date_updated);
        this.friendlyName = payload.friendly_name;
        this.isoCountry = payload.iso_country;
        this.postalCode = payload.postal_code;
        this.region = payload.region;
        this.sid = payload.sid;
        this.street = payload.street;
        this.uri = payload.uri;
        this.emergencyEnabled = payload.emergency_enabled;
        this.validated = payload.validated;
        this.verified = payload.verified;
        this.streetSecondary = payload.street_secondary;
        this._solution = {
            accountSid,
            sid: sid || this.sid
        };
    }
    get _proxy() {
        this._context = this._context || new AddressContextImpl(this._version, this._solution.accountSid, this._solution.sid);
        return this._context;
    }
    /**
     * Remove a AddressInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean
     */ remove(callback) {
        return this._proxy.remove(callback);
    }
    /**
     * Remove a AddressInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean with HTTP metadata
     */ removeWithHttpInfo(callback) {
        return this._proxy.removeWithHttpInfo(callback);
    }
    /**
     * Fetch a AddressInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed AddressInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a AddressInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed AddressInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    update(params, callback) {
        return this._proxy.update(params, callback);
    }
    updateWithHttpInfo(params, callback) {
        return this._proxy.updateWithHttpInfo(params, callback);
    }
    /**
     * Access the dependentPhoneNumbers.
     */ dependentPhoneNumbers() {
        return this._proxy.dependentPhoneNumbers;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            city: this.city,
            customerName: this.customerName,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated,
            friendlyName: this.friendlyName,
            isoCountry: this.isoCountry,
            postalCode: this.postalCode,
            region: this.region,
            sid: this.sid,
            street: this.street,
            uri: this.uri,
            emergencyEnabled: this.emergencyEnabled,
            validated: this.validated,
            verified: this.verified,
            streetSecondary: this.streetSecondary
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.AddressInstance = AddressInstance;
function AddressListInstance(version, accountSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    const instance = (sid)=>instance.get(sid);
    instance.get = function get(sid) {
        return new AddressContextImpl(version, accountSid, sid);
    };
    instance._version = version;
    instance._solution = {
        accountSid
    };
    instance._uri = `/Accounts/${accountSid}/Addresses.json`;
    instance.create = function create(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["customerName"] === null || params["customerName"] === undefined) {
            throw new Error("Required parameter \"params['customerName']\" missing.");
        }
        if (params["street"] === null || params["street"] === undefined) {
            throw new Error("Required parameter \"params['street']\" missing.");
        }
        if (params["city"] === null || params["city"] === undefined) {
            throw new Error("Required parameter \"params['city']\" missing.");
        }
        if (params["region"] === null || params["region"] === undefined) {
            throw new Error("Required parameter \"params['region']\" missing.");
        }
        if (params["postalCode"] === null || params["postalCode"] === undefined) {
            throw new Error("Required parameter \"params['postalCode']\" missing.");
        }
        if (params["isoCountry"] === null || params["isoCountry"] === undefined) {
            throw new Error("Required parameter \"params['isoCountry']\" missing.");
        }
        let data = {};
        data["CustomerName"] = params["customerName"];
        data["Street"] = params["street"];
        data["City"] = params["city"];
        data["Region"] = params["region"];
        data["PostalCode"] = params["postalCode"];
        data["IsoCountry"] = params["isoCountry"];
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["emergencyEnabled"] !== undefined) data["EmergencyEnabled"] = serialize.bool(params["emergencyEnabled"]);
        if (params["autoCorrectAddress"] !== undefined) data["AutoCorrectAddress"] = serialize.bool(params["autoCorrectAddress"]);
        if (params["streetSecondary"] !== undefined) data["StreetSecondary"] = params["streetSecondary"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.create({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new AddressInstance(operationVersion, payload, instance._solution.accountSid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.createWithHttpInfo = function createWithHttpInfo(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["customerName"] === null || params["customerName"] === undefined) {
            throw new Error("Required parameter \"params['customerName']\" missing.");
        }
        if (params["street"] === null || params["street"] === undefined) {
            throw new Error("Required parameter \"params['street']\" missing.");
        }
        if (params["city"] === null || params["city"] === undefined) {
            throw new Error("Required parameter \"params['city']\" missing.");
        }
        if (params["region"] === null || params["region"] === undefined) {
            throw new Error("Required parameter \"params['region']\" missing.");
        }
        if (params["postalCode"] === null || params["postalCode"] === undefined) {
            throw new Error("Required parameter \"params['postalCode']\" missing.");
        }
        if (params["isoCountry"] === null || params["isoCountry"] === undefined) {
            throw new Error("Required parameter \"params['isoCountry']\" missing.");
        }
        let data = {};
        data["CustomerName"] = params["customerName"];
        data["Street"] = params["street"];
        data["City"] = params["city"];
        data["Region"] = params["region"];
        data["PostalCode"] = params["postalCode"];
        data["IsoCountry"] = params["isoCountry"];
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["emergencyEnabled"] !== undefined) data["EmergencyEnabled"] = serialize.bool(params["emergencyEnabled"]);
        if (params["autoCorrectAddress"] !== undefined) data["AutoCorrectAddress"] = serialize.bool(params["autoCorrectAddress"]);
        if (params["streetSecondary"] !== undefined) data["StreetSecondary"] = params["streetSecondary"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.createWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new AddressInstance(operationVersion, response.body, instance._solution.accountSid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["customerName"] !== undefined) data["CustomerName"] = params["customerName"];
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["emergencyEnabled"] !== undefined) data["EmergencyEnabled"] = serialize.bool(params["emergencyEnabled"]);
        if (params["isoCountry"] !== undefined) data["IsoCountry"] = params["isoCountry"];
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new AddressPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new AddressPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["customerName"] !== undefined) data["CustomerName"] = params["customerName"];
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["emergencyEnabled"] !== undefined) data["EmergencyEnabled"] = serialize.bool(params["emergencyEnabled"]);
        if (params["isoCountry"] !== undefined) data["IsoCountry"] = params["isoCountry"];
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new AddressPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new AddressPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class AddressPage extends Page_1.default {
    /**
     * Initialize the AddressPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of AddressInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new AddressInstance(this._version, payload, this._solution.accountSid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.AddressPage = AddressPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/application.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ApplicationPage = exports.ApplicationInstance = exports.ApplicationContextImpl = void 0;
exports.ApplicationListInstance = ApplicationListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
class ApplicationContextImpl {
    constructor(_version, accountSid, sid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(accountSid)) {
            throw new Error("Parameter 'accountSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(sid)) {
            throw new Error("Parameter 'sid' is not valid.");
        }
        this._solution = {
            accountSid,
            sid
        };
        this._uri = `/Accounts/${accountSid}/Applications/${sid}.json`;
    }
    remove(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.remove({
            uri: instance._uri,
            method: "delete",
            headers
        });
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    removeWithHttpInfo(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version;
        // DELETE operation - returns boolean based on status code
        let operationPromise = operationVersion.removeWithResponseInfo({
            uri: instance._uri,
            method: "delete",
            headers
        }).then((response)=>({
                ...response,
                body: response.statusCode === 204
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new ApplicationInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new ApplicationInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    update(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["apiVersion"] !== undefined) data["ApiVersion"] = params["apiVersion"];
        if (params["voiceUrl"] !== undefined) data["VoiceUrl"] = params["voiceUrl"];
        if (params["voiceMethod"] !== undefined) data["VoiceMethod"] = params["voiceMethod"];
        if (params["voiceFallbackUrl"] !== undefined) data["VoiceFallbackUrl"] = params["voiceFallbackUrl"];
        if (params["voiceFallbackMethod"] !== undefined) data["VoiceFallbackMethod"] = params["voiceFallbackMethod"];
        if (params["statusCallback"] !== undefined) data["StatusCallback"] = params["statusCallback"];
        if (params["statusCallbackMethod"] !== undefined) data["StatusCallbackMethod"] = params["statusCallbackMethod"];
        if (params["voiceCallerIdLookup"] !== undefined) data["VoiceCallerIdLookup"] = serialize.bool(params["voiceCallerIdLookup"]);
        if (params["smsUrl"] !== undefined) data["SmsUrl"] = params["smsUrl"];
        if (params["smsMethod"] !== undefined) data["SmsMethod"] = params["smsMethod"];
        if (params["smsFallbackUrl"] !== undefined) data["SmsFallbackUrl"] = params["smsFallbackUrl"];
        if (params["smsFallbackMethod"] !== undefined) data["SmsFallbackMethod"] = params["smsFallbackMethod"];
        if (params["smsStatusCallback"] !== undefined) data["SmsStatusCallback"] = params["smsStatusCallback"];
        if (params["messageStatusCallback"] !== undefined) data["MessageStatusCallback"] = params["messageStatusCallback"];
        if (params["publicApplicationConnectEnabled"] !== undefined) data["PublicApplicationConnectEnabled"] = serialize.bool(params["publicApplicationConnectEnabled"]);
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.update({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new ApplicationInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    updateWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["apiVersion"] !== undefined) data["ApiVersion"] = params["apiVersion"];
        if (params["voiceUrl"] !== undefined) data["VoiceUrl"] = params["voiceUrl"];
        if (params["voiceMethod"] !== undefined) data["VoiceMethod"] = params["voiceMethod"];
        if (params["voiceFallbackUrl"] !== undefined) data["VoiceFallbackUrl"] = params["voiceFallbackUrl"];
        if (params["voiceFallbackMethod"] !== undefined) data["VoiceFallbackMethod"] = params["voiceFallbackMethod"];
        if (params["statusCallback"] !== undefined) data["StatusCallback"] = params["statusCallback"];
        if (params["statusCallbackMethod"] !== undefined) data["StatusCallbackMethod"] = params["statusCallbackMethod"];
        if (params["voiceCallerIdLookup"] !== undefined) data["VoiceCallerIdLookup"] = serialize.bool(params["voiceCallerIdLookup"]);
        if (params["smsUrl"] !== undefined) data["SmsUrl"] = params["smsUrl"];
        if (params["smsMethod"] !== undefined) data["SmsMethod"] = params["smsMethod"];
        if (params["smsFallbackUrl"] !== undefined) data["SmsFallbackUrl"] = params["smsFallbackUrl"];
        if (params["smsFallbackMethod"] !== undefined) data["SmsFallbackMethod"] = params["smsFallbackMethod"];
        if (params["smsStatusCallback"] !== undefined) data["SmsStatusCallback"] = params["smsStatusCallback"];
        if (params["messageStatusCallback"] !== undefined) data["MessageStatusCallback"] = params["messageStatusCallback"];
        if (params["publicApplicationConnectEnabled"] !== undefined) data["PublicApplicationConnectEnabled"] = serialize.bool(params["publicApplicationConnectEnabled"]);
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.updateWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new ApplicationInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.ApplicationContextImpl = ApplicationContextImpl;
class ApplicationInstance {
    constructor(_version, payload, accountSid, sid){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.apiVersion = payload.api_version;
        this.dateCreated = deserialize.rfc2822DateTime(payload.date_created);
        this.dateUpdated = deserialize.rfc2822DateTime(payload.date_updated);
        this.friendlyName = payload.friendly_name;
        this.messageStatusCallback = payload.message_status_callback;
        this.sid = payload.sid;
        this.smsFallbackMethod = payload.sms_fallback_method;
        this.smsFallbackUrl = payload.sms_fallback_url;
        this.smsMethod = payload.sms_method;
        this.smsStatusCallback = payload.sms_status_callback;
        this.smsUrl = payload.sms_url;
        this.statusCallback = payload.status_callback;
        this.statusCallbackMethod = payload.status_callback_method;
        this.uri = payload.uri;
        this.voiceCallerIdLookup = payload.voice_caller_id_lookup;
        this.voiceFallbackMethod = payload.voice_fallback_method;
        this.voiceFallbackUrl = payload.voice_fallback_url;
        this.voiceMethod = payload.voice_method;
        this.voiceUrl = payload.voice_url;
        this.publicApplicationConnectEnabled = payload.public_application_connect_enabled;
        this._solution = {
            accountSid,
            sid: sid || this.sid
        };
    }
    get _proxy() {
        this._context = this._context || new ApplicationContextImpl(this._version, this._solution.accountSid, this._solution.sid);
        return this._context;
    }
    /**
     * Remove a ApplicationInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean
     */ remove(callback) {
        return this._proxy.remove(callback);
    }
    /**
     * Remove a ApplicationInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean with HTTP metadata
     */ removeWithHttpInfo(callback) {
        return this._proxy.removeWithHttpInfo(callback);
    }
    /**
     * Fetch a ApplicationInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed ApplicationInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a ApplicationInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed ApplicationInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    update(params, callback) {
        return this._proxy.update(params, callback);
    }
    updateWithHttpInfo(params, callback) {
        return this._proxy.updateWithHttpInfo(params, callback);
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            apiVersion: this.apiVersion,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated,
            friendlyName: this.friendlyName,
            messageStatusCallback: this.messageStatusCallback,
            sid: this.sid,
            smsFallbackMethod: this.smsFallbackMethod,
            smsFallbackUrl: this.smsFallbackUrl,
            smsMethod: this.smsMethod,
            smsStatusCallback: this.smsStatusCallback,
            smsUrl: this.smsUrl,
            statusCallback: this.statusCallback,
            statusCallbackMethod: this.statusCallbackMethod,
            uri: this.uri,
            voiceCallerIdLookup: this.voiceCallerIdLookup,
            voiceFallbackMethod: this.voiceFallbackMethod,
            voiceFallbackUrl: this.voiceFallbackUrl,
            voiceMethod: this.voiceMethod,
            voiceUrl: this.voiceUrl,
            publicApplicationConnectEnabled: this.publicApplicationConnectEnabled
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.ApplicationInstance = ApplicationInstance;
function ApplicationListInstance(version, accountSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    const instance = (sid)=>instance.get(sid);
    instance.get = function get(sid) {
        return new ApplicationContextImpl(version, accountSid, sid);
    };
    instance._version = version;
    instance._solution = {
        accountSid
    };
    instance._uri = `/Accounts/${accountSid}/Applications.json`;
    instance.create = function create(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["apiVersion"] !== undefined) data["ApiVersion"] = params["apiVersion"];
        if (params["voiceUrl"] !== undefined) data["VoiceUrl"] = params["voiceUrl"];
        if (params["voiceMethod"] !== undefined) data["VoiceMethod"] = params["voiceMethod"];
        if (params["voiceFallbackUrl"] !== undefined) data["VoiceFallbackUrl"] = params["voiceFallbackUrl"];
        if (params["voiceFallbackMethod"] !== undefined) data["VoiceFallbackMethod"] = params["voiceFallbackMethod"];
        if (params["statusCallback"] !== undefined) data["StatusCallback"] = params["statusCallback"];
        if (params["statusCallbackMethod"] !== undefined) data["StatusCallbackMethod"] = params["statusCallbackMethod"];
        if (params["voiceCallerIdLookup"] !== undefined) data["VoiceCallerIdLookup"] = serialize.bool(params["voiceCallerIdLookup"]);
        if (params["smsUrl"] !== undefined) data["SmsUrl"] = params["smsUrl"];
        if (params["smsMethod"] !== undefined) data["SmsMethod"] = params["smsMethod"];
        if (params["smsFallbackUrl"] !== undefined) data["SmsFallbackUrl"] = params["smsFallbackUrl"];
        if (params["smsFallbackMethod"] !== undefined) data["SmsFallbackMethod"] = params["smsFallbackMethod"];
        if (params["smsStatusCallback"] !== undefined) data["SmsStatusCallback"] = params["smsStatusCallback"];
        if (params["messageStatusCallback"] !== undefined) data["MessageStatusCallback"] = params["messageStatusCallback"];
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["publicApplicationConnectEnabled"] !== undefined) data["PublicApplicationConnectEnabled"] = serialize.bool(params["publicApplicationConnectEnabled"]);
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.create({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new ApplicationInstance(operationVersion, payload, instance._solution.accountSid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.createWithHttpInfo = function createWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["apiVersion"] !== undefined) data["ApiVersion"] = params["apiVersion"];
        if (params["voiceUrl"] !== undefined) data["VoiceUrl"] = params["voiceUrl"];
        if (params["voiceMethod"] !== undefined) data["VoiceMethod"] = params["voiceMethod"];
        if (params["voiceFallbackUrl"] !== undefined) data["VoiceFallbackUrl"] = params["voiceFallbackUrl"];
        if (params["voiceFallbackMethod"] !== undefined) data["VoiceFallbackMethod"] = params["voiceFallbackMethod"];
        if (params["statusCallback"] !== undefined) data["StatusCallback"] = params["statusCallback"];
        if (params["statusCallbackMethod"] !== undefined) data["StatusCallbackMethod"] = params["statusCallbackMethod"];
        if (params["voiceCallerIdLookup"] !== undefined) data["VoiceCallerIdLookup"] = serialize.bool(params["voiceCallerIdLookup"]);
        if (params["smsUrl"] !== undefined) data["SmsUrl"] = params["smsUrl"];
        if (params["smsMethod"] !== undefined) data["SmsMethod"] = params["smsMethod"];
        if (params["smsFallbackUrl"] !== undefined) data["SmsFallbackUrl"] = params["smsFallbackUrl"];
        if (params["smsFallbackMethod"] !== undefined) data["SmsFallbackMethod"] = params["smsFallbackMethod"];
        if (params["smsStatusCallback"] !== undefined) data["SmsStatusCallback"] = params["smsStatusCallback"];
        if (params["messageStatusCallback"] !== undefined) data["MessageStatusCallback"] = params["messageStatusCallback"];
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["publicApplicationConnectEnabled"] !== undefined) data["PublicApplicationConnectEnabled"] = serialize.bool(params["publicApplicationConnectEnabled"]);
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.createWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new ApplicationInstance(operationVersion, response.body, instance._solution.accountSid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new ApplicationPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new ApplicationPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new ApplicationPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new ApplicationPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class ApplicationPage extends Page_1.default {
    /**
     * Initialize the ApplicationPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of ApplicationInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new ApplicationInstance(this._version, payload, this._solution.accountSid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.ApplicationPage = ApplicationPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/authorizedConnectApp.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AuthorizedConnectAppPage = exports.AuthorizedConnectAppInstance = exports.AuthorizedConnectAppContextImpl = void 0;
exports.AuthorizedConnectAppListInstance = AuthorizedConnectAppListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
class AuthorizedConnectAppContextImpl {
    constructor(_version, accountSid, connectAppSid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(accountSid)) {
            throw new Error("Parameter 'accountSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(connectAppSid)) {
            throw new Error("Parameter 'connectAppSid' is not valid.");
        }
        this._solution = {
            accountSid,
            connectAppSid
        };
        this._uri = `/Accounts/${accountSid}/AuthorizedConnectApps/${connectAppSid}.json`;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new AuthorizedConnectAppInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.connectAppSid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new AuthorizedConnectAppInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.connectAppSid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.AuthorizedConnectAppContextImpl = AuthorizedConnectAppContextImpl;
class AuthorizedConnectAppInstance {
    constructor(_version, payload, accountSid, connectAppSid){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.connectAppCompanyName = payload.connect_app_company_name;
        this.connectAppDescription = payload.connect_app_description;
        this.connectAppFriendlyName = payload.connect_app_friendly_name;
        this.connectAppHomepageUrl = payload.connect_app_homepage_url;
        this.connectAppSid = payload.connect_app_sid;
        this.permissions = payload.permissions;
        this.uri = payload.uri;
        this._solution = {
            accountSid,
            connectAppSid: connectAppSid || this.connectAppSid
        };
    }
    get _proxy() {
        this._context = this._context || new AuthorizedConnectAppContextImpl(this._version, this._solution.accountSid, this._solution.connectAppSid);
        return this._context;
    }
    /**
     * Fetch a AuthorizedConnectAppInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed AuthorizedConnectAppInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a AuthorizedConnectAppInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed AuthorizedConnectAppInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            connectAppCompanyName: this.connectAppCompanyName,
            connectAppDescription: this.connectAppDescription,
            connectAppFriendlyName: this.connectAppFriendlyName,
            connectAppHomepageUrl: this.connectAppHomepageUrl,
            connectAppSid: this.connectAppSid,
            permissions: this.permissions,
            uri: this.uri
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.AuthorizedConnectAppInstance = AuthorizedConnectAppInstance;
function AuthorizedConnectAppListInstance(version, accountSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    const instance = (connectAppSid)=>instance.get(connectAppSid);
    instance.get = function get(connectAppSid) {
        return new AuthorizedConnectAppContextImpl(version, accountSid, connectAppSid);
    };
    instance._version = version;
    instance._solution = {
        accountSid
    };
    instance._uri = `/Accounts/${accountSid}/AuthorizedConnectApps.json`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new AuthorizedConnectAppPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new AuthorizedConnectAppPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new AuthorizedConnectAppPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new AuthorizedConnectAppPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class AuthorizedConnectAppPage extends Page_1.default {
    /**
     * Initialize the AuthorizedConnectAppPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of AuthorizedConnectAppInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new AuthorizedConnectAppInstance(this._version, payload, this._solution.accountSid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.AuthorizedConnectAppPage = AuthorizedConnectAppPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/availablePhoneNumberCountry/local.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LocalPage = exports.LocalInstance = void 0;
exports.LocalListInstance = LocalListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
function LocalListInstance(version, accountSid, countryCode) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    if (!(0, utility_1.isValidPathParam)(countryCode)) {
        throw new Error("Parameter 'countryCode' is not valid.");
    }
    const instance = {};
    instance._version = version;
    instance._solution = {
        accountSid,
        countryCode
    };
    instance._uri = `/Accounts/${accountSid}/AvailablePhoneNumbers/${countryCode}/Local.json`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["areaCode"] !== undefined) data["AreaCode"] = params["areaCode"];
        if (params["contains"] !== undefined) data["Contains"] = params["contains"];
        if (params["smsEnabled"] !== undefined) data["SmsEnabled"] = serialize.bool(params["smsEnabled"]);
        if (params["mmsEnabled"] !== undefined) data["MmsEnabled"] = serialize.bool(params["mmsEnabled"]);
        if (params["voiceEnabled"] !== undefined) data["VoiceEnabled"] = serialize.bool(params["voiceEnabled"]);
        if (params["excludeAllAddressRequired"] !== undefined) data["ExcludeAllAddressRequired"] = serialize.bool(params["excludeAllAddressRequired"]);
        if (params["excludeLocalAddressRequired"] !== undefined) data["ExcludeLocalAddressRequired"] = serialize.bool(params["excludeLocalAddressRequired"]);
        if (params["excludeForeignAddressRequired"] !== undefined) data["ExcludeForeignAddressRequired"] = serialize.bool(params["excludeForeignAddressRequired"]);
        if (params["beta"] !== undefined) data["Beta"] = serialize.bool(params["beta"]);
        if (params["nearNumber"] !== undefined) data["NearNumber"] = params["nearNumber"];
        if (params["nearLatLong"] !== undefined) data["NearLatLong"] = params["nearLatLong"];
        if (params["distance"] !== undefined) data["Distance"] = params["distance"];
        if (params["inPostalCode"] !== undefined) data["InPostalCode"] = params["inPostalCode"];
        if (params["inRegion"] !== undefined) data["InRegion"] = params["inRegion"];
        if (params["inRateCenter"] !== undefined) data["InRateCenter"] = params["inRateCenter"];
        if (params["inLata"] !== undefined) data["InLata"] = params["inLata"];
        if (params["inLocality"] !== undefined) data["InLocality"] = params["inLocality"];
        if (params["faxEnabled"] !== undefined) data["FaxEnabled"] = serialize.bool(params["faxEnabled"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new LocalPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new LocalPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["areaCode"] !== undefined) data["AreaCode"] = params["areaCode"];
        if (params["contains"] !== undefined) data["Contains"] = params["contains"];
        if (params["smsEnabled"] !== undefined) data["SmsEnabled"] = serialize.bool(params["smsEnabled"]);
        if (params["mmsEnabled"] !== undefined) data["MmsEnabled"] = serialize.bool(params["mmsEnabled"]);
        if (params["voiceEnabled"] !== undefined) data["VoiceEnabled"] = serialize.bool(params["voiceEnabled"]);
        if (params["excludeAllAddressRequired"] !== undefined) data["ExcludeAllAddressRequired"] = serialize.bool(params["excludeAllAddressRequired"]);
        if (params["excludeLocalAddressRequired"] !== undefined) data["ExcludeLocalAddressRequired"] = serialize.bool(params["excludeLocalAddressRequired"]);
        if (params["excludeForeignAddressRequired"] !== undefined) data["ExcludeForeignAddressRequired"] = serialize.bool(params["excludeForeignAddressRequired"]);
        if (params["beta"] !== undefined) data["Beta"] = serialize.bool(params["beta"]);
        if (params["nearNumber"] !== undefined) data["NearNumber"] = params["nearNumber"];
        if (params["nearLatLong"] !== undefined) data["NearLatLong"] = params["nearLatLong"];
        if (params["distance"] !== undefined) data["Distance"] = params["distance"];
        if (params["inPostalCode"] !== undefined) data["InPostalCode"] = params["inPostalCode"];
        if (params["inRegion"] !== undefined) data["InRegion"] = params["inRegion"];
        if (params["inRateCenter"] !== undefined) data["InRateCenter"] = params["inRateCenter"];
        if (params["inLata"] !== undefined) data["InLata"] = params["inLata"];
        if (params["inLocality"] !== undefined) data["InLocality"] = params["inLocality"];
        if (params["faxEnabled"] !== undefined) data["FaxEnabled"] = serialize.bool(params["faxEnabled"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new LocalPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new LocalPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class LocalInstance {
    constructor(_version, payload, accountSid, countryCode){
        this._version = _version;
        this.friendlyName = payload.friendly_name;
        this.phoneNumber = payload.phone_number;
        this.lata = payload.lata;
        this.locality = payload.locality;
        this.rateCenter = payload.rate_center;
        this.latitude = payload.latitude;
        this.longitude = payload.longitude;
        this.region = payload.region;
        this.postalCode = payload.postal_code;
        this.isoCountry = payload.iso_country;
        this.addressRequirements = payload.address_requirements;
        this.beta = payload.beta;
        this.capabilities = payload.capabilities;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            friendlyName: this.friendlyName,
            phoneNumber: this.phoneNumber,
            lata: this.lata,
            locality: this.locality,
            rateCenter: this.rateCenter,
            latitude: this.latitude,
            longitude: this.longitude,
            region: this.region,
            postalCode: this.postalCode,
            isoCountry: this.isoCountry,
            addressRequirements: this.addressRequirements,
            beta: this.beta,
            capabilities: this.capabilities
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.LocalInstance = LocalInstance;
class LocalPage extends Page_1.default {
    /**
     * Initialize the LocalPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of LocalInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new LocalInstance(this._version, payload, this._solution.accountSid, this._solution.countryCode);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.LocalPage = LocalPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/availablePhoneNumberCountry/machineToMachine.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MachineToMachinePage = exports.MachineToMachineInstance = void 0;
exports.MachineToMachineListInstance = MachineToMachineListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
function MachineToMachineListInstance(version, accountSid, countryCode) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    if (!(0, utility_1.isValidPathParam)(countryCode)) {
        throw new Error("Parameter 'countryCode' is not valid.");
    }
    const instance = {};
    instance._version = version;
    instance._solution = {
        accountSid,
        countryCode
    };
    instance._uri = `/Accounts/${accountSid}/AvailablePhoneNumbers/${countryCode}/MachineToMachine.json`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["areaCode"] !== undefined) data["AreaCode"] = params["areaCode"];
        if (params["contains"] !== undefined) data["Contains"] = params["contains"];
        if (params["smsEnabled"] !== undefined) data["SmsEnabled"] = serialize.bool(params["smsEnabled"]);
        if (params["mmsEnabled"] !== undefined) data["MmsEnabled"] = serialize.bool(params["mmsEnabled"]);
        if (params["voiceEnabled"] !== undefined) data["VoiceEnabled"] = serialize.bool(params["voiceEnabled"]);
        if (params["excludeAllAddressRequired"] !== undefined) data["ExcludeAllAddressRequired"] = serialize.bool(params["excludeAllAddressRequired"]);
        if (params["excludeLocalAddressRequired"] !== undefined) data["ExcludeLocalAddressRequired"] = serialize.bool(params["excludeLocalAddressRequired"]);
        if (params["excludeForeignAddressRequired"] !== undefined) data["ExcludeForeignAddressRequired"] = serialize.bool(params["excludeForeignAddressRequired"]);
        if (params["beta"] !== undefined) data["Beta"] = serialize.bool(params["beta"]);
        if (params["nearNumber"] !== undefined) data["NearNumber"] = params["nearNumber"];
        if (params["nearLatLong"] !== undefined) data["NearLatLong"] = params["nearLatLong"];
        if (params["distance"] !== undefined) data["Distance"] = params["distance"];
        if (params["inPostalCode"] !== undefined) data["InPostalCode"] = params["inPostalCode"];
        if (params["inRegion"] !== undefined) data["InRegion"] = params["inRegion"];
        if (params["inRateCenter"] !== undefined) data["InRateCenter"] = params["inRateCenter"];
        if (params["inLata"] !== undefined) data["InLata"] = params["inLata"];
        if (params["inLocality"] !== undefined) data["InLocality"] = params["inLocality"];
        if (params["faxEnabled"] !== undefined) data["FaxEnabled"] = serialize.bool(params["faxEnabled"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new MachineToMachinePage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new MachineToMachinePage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["areaCode"] !== undefined) data["AreaCode"] = params["areaCode"];
        if (params["contains"] !== undefined) data["Contains"] = params["contains"];
        if (params["smsEnabled"] !== undefined) data["SmsEnabled"] = serialize.bool(params["smsEnabled"]);
        if (params["mmsEnabled"] !== undefined) data["MmsEnabled"] = serialize.bool(params["mmsEnabled"]);
        if (params["voiceEnabled"] !== undefined) data["VoiceEnabled"] = serialize.bool(params["voiceEnabled"]);
        if (params["excludeAllAddressRequired"] !== undefined) data["ExcludeAllAddressRequired"] = serialize.bool(params["excludeAllAddressRequired"]);
        if (params["excludeLocalAddressRequired"] !== undefined) data["ExcludeLocalAddressRequired"] = serialize.bool(params["excludeLocalAddressRequired"]);
        if (params["excludeForeignAddressRequired"] !== undefined) data["ExcludeForeignAddressRequired"] = serialize.bool(params["excludeForeignAddressRequired"]);
        if (params["beta"] !== undefined) data["Beta"] = serialize.bool(params["beta"]);
        if (params["nearNumber"] !== undefined) data["NearNumber"] = params["nearNumber"];
        if (params["nearLatLong"] !== undefined) data["NearLatLong"] = params["nearLatLong"];
        if (params["distance"] !== undefined) data["Distance"] = params["distance"];
        if (params["inPostalCode"] !== undefined) data["InPostalCode"] = params["inPostalCode"];
        if (params["inRegion"] !== undefined) data["InRegion"] = params["inRegion"];
        if (params["inRateCenter"] !== undefined) data["InRateCenter"] = params["inRateCenter"];
        if (params["inLata"] !== undefined) data["InLata"] = params["inLata"];
        if (params["inLocality"] !== undefined) data["InLocality"] = params["inLocality"];
        if (params["faxEnabled"] !== undefined) data["FaxEnabled"] = serialize.bool(params["faxEnabled"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new MachineToMachinePage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new MachineToMachinePage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class MachineToMachineInstance {
    constructor(_version, payload, accountSid, countryCode){
        this._version = _version;
        this.friendlyName = payload.friendly_name;
        this.phoneNumber = payload.phone_number;
        this.lata = payload.lata;
        this.locality = payload.locality;
        this.rateCenter = payload.rate_center;
        this.latitude = payload.latitude;
        this.longitude = payload.longitude;
        this.region = payload.region;
        this.postalCode = payload.postal_code;
        this.isoCountry = payload.iso_country;
        this.addressRequirements = payload.address_requirements;
        this.beta = payload.beta;
        this.capabilities = payload.capabilities;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            friendlyName: this.friendlyName,
            phoneNumber: this.phoneNumber,
            lata: this.lata,
            locality: this.locality,
            rateCenter: this.rateCenter,
            latitude: this.latitude,
            longitude: this.longitude,
            region: this.region,
            postalCode: this.postalCode,
            isoCountry: this.isoCountry,
            addressRequirements: this.addressRequirements,
            beta: this.beta,
            capabilities: this.capabilities
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.MachineToMachineInstance = MachineToMachineInstance;
class MachineToMachinePage extends Page_1.default {
    /**
     * Initialize the MachineToMachinePage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of MachineToMachineInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new MachineToMachineInstance(this._version, payload, this._solution.accountSid, this._solution.countryCode);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.MachineToMachinePage = MachineToMachinePage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/availablePhoneNumberCountry/mobile.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MobilePage = exports.MobileInstance = void 0;
exports.MobileListInstance = MobileListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
function MobileListInstance(version, accountSid, countryCode) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    if (!(0, utility_1.isValidPathParam)(countryCode)) {
        throw new Error("Parameter 'countryCode' is not valid.");
    }
    const instance = {};
    instance._version = version;
    instance._solution = {
        accountSid,
        countryCode
    };
    instance._uri = `/Accounts/${accountSid}/AvailablePhoneNumbers/${countryCode}/Mobile.json`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["areaCode"] !== undefined) data["AreaCode"] = params["areaCode"];
        if (params["contains"] !== undefined) data["Contains"] = params["contains"];
        if (params["smsEnabled"] !== undefined) data["SmsEnabled"] = serialize.bool(params["smsEnabled"]);
        if (params["mmsEnabled"] !== undefined) data["MmsEnabled"] = serialize.bool(params["mmsEnabled"]);
        if (params["voiceEnabled"] !== undefined) data["VoiceEnabled"] = serialize.bool(params["voiceEnabled"]);
        if (params["excludeAllAddressRequired"] !== undefined) data["ExcludeAllAddressRequired"] = serialize.bool(params["excludeAllAddressRequired"]);
        if (params["excludeLocalAddressRequired"] !== undefined) data["ExcludeLocalAddressRequired"] = serialize.bool(params["excludeLocalAddressRequired"]);
        if (params["excludeForeignAddressRequired"] !== undefined) data["ExcludeForeignAddressRequired"] = serialize.bool(params["excludeForeignAddressRequired"]);
        if (params["beta"] !== undefined) data["Beta"] = serialize.bool(params["beta"]);
        if (params["nearNumber"] !== undefined) data["NearNumber"] = params["nearNumber"];
        if (params["nearLatLong"] !== undefined) data["NearLatLong"] = params["nearLatLong"];
        if (params["distance"] !== undefined) data["Distance"] = params["distance"];
        if (params["inPostalCode"] !== undefined) data["InPostalCode"] = params["inPostalCode"];
        if (params["inRegion"] !== undefined) data["InRegion"] = params["inRegion"];
        if (params["inRateCenter"] !== undefined) data["InRateCenter"] = params["inRateCenter"];
        if (params["inLata"] !== undefined) data["InLata"] = params["inLata"];
        if (params["inLocality"] !== undefined) data["InLocality"] = params["inLocality"];
        if (params["faxEnabled"] !== undefined) data["FaxEnabled"] = serialize.bool(params["faxEnabled"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new MobilePage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new MobilePage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["areaCode"] !== undefined) data["AreaCode"] = params["areaCode"];
        if (params["contains"] !== undefined) data["Contains"] = params["contains"];
        if (params["smsEnabled"] !== undefined) data["SmsEnabled"] = serialize.bool(params["smsEnabled"]);
        if (params["mmsEnabled"] !== undefined) data["MmsEnabled"] = serialize.bool(params["mmsEnabled"]);
        if (params["voiceEnabled"] !== undefined) data["VoiceEnabled"] = serialize.bool(params["voiceEnabled"]);
        if (params["excludeAllAddressRequired"] !== undefined) data["ExcludeAllAddressRequired"] = serialize.bool(params["excludeAllAddressRequired"]);
        if (params["excludeLocalAddressRequired"] !== undefined) data["ExcludeLocalAddressRequired"] = serialize.bool(params["excludeLocalAddressRequired"]);
        if (params["excludeForeignAddressRequired"] !== undefined) data["ExcludeForeignAddressRequired"] = serialize.bool(params["excludeForeignAddressRequired"]);
        if (params["beta"] !== undefined) data["Beta"] = serialize.bool(params["beta"]);
        if (params["nearNumber"] !== undefined) data["NearNumber"] = params["nearNumber"];
        if (params["nearLatLong"] !== undefined) data["NearLatLong"] = params["nearLatLong"];
        if (params["distance"] !== undefined) data["Distance"] = params["distance"];
        if (params["inPostalCode"] !== undefined) data["InPostalCode"] = params["inPostalCode"];
        if (params["inRegion"] !== undefined) data["InRegion"] = params["inRegion"];
        if (params["inRateCenter"] !== undefined) data["InRateCenter"] = params["inRateCenter"];
        if (params["inLata"] !== undefined) data["InLata"] = params["inLata"];
        if (params["inLocality"] !== undefined) data["InLocality"] = params["inLocality"];
        if (params["faxEnabled"] !== undefined) data["FaxEnabled"] = serialize.bool(params["faxEnabled"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new MobilePage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new MobilePage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class MobileInstance {
    constructor(_version, payload, accountSid, countryCode){
        this._version = _version;
        this.friendlyName = payload.friendly_name;
        this.phoneNumber = payload.phone_number;
        this.lata = payload.lata;
        this.locality = payload.locality;
        this.rateCenter = payload.rate_center;
        this.latitude = payload.latitude;
        this.longitude = payload.longitude;
        this.region = payload.region;
        this.postalCode = payload.postal_code;
        this.isoCountry = payload.iso_country;
        this.addressRequirements = payload.address_requirements;
        this.beta = payload.beta;
        this.capabilities = payload.capabilities;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            friendlyName: this.friendlyName,
            phoneNumber: this.phoneNumber,
            lata: this.lata,
            locality: this.locality,
            rateCenter: this.rateCenter,
            latitude: this.latitude,
            longitude: this.longitude,
            region: this.region,
            postalCode: this.postalCode,
            isoCountry: this.isoCountry,
            addressRequirements: this.addressRequirements,
            beta: this.beta,
            capabilities: this.capabilities
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.MobileInstance = MobileInstance;
class MobilePage extends Page_1.default {
    /**
     * Initialize the MobilePage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of MobileInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new MobileInstance(this._version, payload, this._solution.accountSid, this._solution.countryCode);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.MobilePage = MobilePage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/availablePhoneNumberCountry/national.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NationalPage = exports.NationalInstance = void 0;
exports.NationalListInstance = NationalListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
function NationalListInstance(version, accountSid, countryCode) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    if (!(0, utility_1.isValidPathParam)(countryCode)) {
        throw new Error("Parameter 'countryCode' is not valid.");
    }
    const instance = {};
    instance._version = version;
    instance._solution = {
        accountSid,
        countryCode
    };
    instance._uri = `/Accounts/${accountSid}/AvailablePhoneNumbers/${countryCode}/National.json`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["areaCode"] !== undefined) data["AreaCode"] = params["areaCode"];
        if (params["contains"] !== undefined) data["Contains"] = params["contains"];
        if (params["smsEnabled"] !== undefined) data["SmsEnabled"] = serialize.bool(params["smsEnabled"]);
        if (params["mmsEnabled"] !== undefined) data["MmsEnabled"] = serialize.bool(params["mmsEnabled"]);
        if (params["voiceEnabled"] !== undefined) data["VoiceEnabled"] = serialize.bool(params["voiceEnabled"]);
        if (params["excludeAllAddressRequired"] !== undefined) data["ExcludeAllAddressRequired"] = serialize.bool(params["excludeAllAddressRequired"]);
        if (params["excludeLocalAddressRequired"] !== undefined) data["ExcludeLocalAddressRequired"] = serialize.bool(params["excludeLocalAddressRequired"]);
        if (params["excludeForeignAddressRequired"] !== undefined) data["ExcludeForeignAddressRequired"] = serialize.bool(params["excludeForeignAddressRequired"]);
        if (params["beta"] !== undefined) data["Beta"] = serialize.bool(params["beta"]);
        if (params["nearNumber"] !== undefined) data["NearNumber"] = params["nearNumber"];
        if (params["nearLatLong"] !== undefined) data["NearLatLong"] = params["nearLatLong"];
        if (params["distance"] !== undefined) data["Distance"] = params["distance"];
        if (params["inPostalCode"] !== undefined) data["InPostalCode"] = params["inPostalCode"];
        if (params["inRegion"] !== undefined) data["InRegion"] = params["inRegion"];
        if (params["inRateCenter"] !== undefined) data["InRateCenter"] = params["inRateCenter"];
        if (params["inLata"] !== undefined) data["InLata"] = params["inLata"];
        if (params["inLocality"] !== undefined) data["InLocality"] = params["inLocality"];
        if (params["faxEnabled"] !== undefined) data["FaxEnabled"] = serialize.bool(params["faxEnabled"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new NationalPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new NationalPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["areaCode"] !== undefined) data["AreaCode"] = params["areaCode"];
        if (params["contains"] !== undefined) data["Contains"] = params["contains"];
        if (params["smsEnabled"] !== undefined) data["SmsEnabled"] = serialize.bool(params["smsEnabled"]);
        if (params["mmsEnabled"] !== undefined) data["MmsEnabled"] = serialize.bool(params["mmsEnabled"]);
        if (params["voiceEnabled"] !== undefined) data["VoiceEnabled"] = serialize.bool(params["voiceEnabled"]);
        if (params["excludeAllAddressRequired"] !== undefined) data["ExcludeAllAddressRequired"] = serialize.bool(params["excludeAllAddressRequired"]);
        if (params["excludeLocalAddressRequired"] !== undefined) data["ExcludeLocalAddressRequired"] = serialize.bool(params["excludeLocalAddressRequired"]);
        if (params["excludeForeignAddressRequired"] !== undefined) data["ExcludeForeignAddressRequired"] = serialize.bool(params["excludeForeignAddressRequired"]);
        if (params["beta"] !== undefined) data["Beta"] = serialize.bool(params["beta"]);
        if (params["nearNumber"] !== undefined) data["NearNumber"] = params["nearNumber"];
        if (params["nearLatLong"] !== undefined) data["NearLatLong"] = params["nearLatLong"];
        if (params["distance"] !== undefined) data["Distance"] = params["distance"];
        if (params["inPostalCode"] !== undefined) data["InPostalCode"] = params["inPostalCode"];
        if (params["inRegion"] !== undefined) data["InRegion"] = params["inRegion"];
        if (params["inRateCenter"] !== undefined) data["InRateCenter"] = params["inRateCenter"];
        if (params["inLata"] !== undefined) data["InLata"] = params["inLata"];
        if (params["inLocality"] !== undefined) data["InLocality"] = params["inLocality"];
        if (params["faxEnabled"] !== undefined) data["FaxEnabled"] = serialize.bool(params["faxEnabled"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new NationalPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new NationalPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class NationalInstance {
    constructor(_version, payload, accountSid, countryCode){
        this._version = _version;
        this.friendlyName = payload.friendly_name;
        this.phoneNumber = payload.phone_number;
        this.lata = payload.lata;
        this.locality = payload.locality;
        this.rateCenter = payload.rate_center;
        this.latitude = payload.latitude;
        this.longitude = payload.longitude;
        this.region = payload.region;
        this.postalCode = payload.postal_code;
        this.isoCountry = payload.iso_country;
        this.addressRequirements = payload.address_requirements;
        this.beta = payload.beta;
        this.capabilities = payload.capabilities;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            friendlyName: this.friendlyName,
            phoneNumber: this.phoneNumber,
            lata: this.lata,
            locality: this.locality,
            rateCenter: this.rateCenter,
            latitude: this.latitude,
            longitude: this.longitude,
            region: this.region,
            postalCode: this.postalCode,
            isoCountry: this.isoCountry,
            addressRequirements: this.addressRequirements,
            beta: this.beta,
            capabilities: this.capabilities
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.NationalInstance = NationalInstance;
class NationalPage extends Page_1.default {
    /**
     * Initialize the NationalPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of NationalInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new NationalInstance(this._version, payload, this._solution.accountSid, this._solution.countryCode);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.NationalPage = NationalPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/availablePhoneNumberCountry/sharedCost.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SharedCostPage = exports.SharedCostInstance = void 0;
exports.SharedCostListInstance = SharedCostListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
function SharedCostListInstance(version, accountSid, countryCode) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    if (!(0, utility_1.isValidPathParam)(countryCode)) {
        throw new Error("Parameter 'countryCode' is not valid.");
    }
    const instance = {};
    instance._version = version;
    instance._solution = {
        accountSid,
        countryCode
    };
    instance._uri = `/Accounts/${accountSid}/AvailablePhoneNumbers/${countryCode}/SharedCost.json`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["areaCode"] !== undefined) data["AreaCode"] = params["areaCode"];
        if (params["contains"] !== undefined) data["Contains"] = params["contains"];
        if (params["smsEnabled"] !== undefined) data["SmsEnabled"] = serialize.bool(params["smsEnabled"]);
        if (params["mmsEnabled"] !== undefined) data["MmsEnabled"] = serialize.bool(params["mmsEnabled"]);
        if (params["voiceEnabled"] !== undefined) data["VoiceEnabled"] = serialize.bool(params["voiceEnabled"]);
        if (params["excludeAllAddressRequired"] !== undefined) data["ExcludeAllAddressRequired"] = serialize.bool(params["excludeAllAddressRequired"]);
        if (params["excludeLocalAddressRequired"] !== undefined) data["ExcludeLocalAddressRequired"] = serialize.bool(params["excludeLocalAddressRequired"]);
        if (params["excludeForeignAddressRequired"] !== undefined) data["ExcludeForeignAddressRequired"] = serialize.bool(params["excludeForeignAddressRequired"]);
        if (params["beta"] !== undefined) data["Beta"] = serialize.bool(params["beta"]);
        if (params["nearNumber"] !== undefined) data["NearNumber"] = params["nearNumber"];
        if (params["nearLatLong"] !== undefined) data["NearLatLong"] = params["nearLatLong"];
        if (params["distance"] !== undefined) data["Distance"] = params["distance"];
        if (params["inPostalCode"] !== undefined) data["InPostalCode"] = params["inPostalCode"];
        if (params["inRegion"] !== undefined) data["InRegion"] = params["inRegion"];
        if (params["inRateCenter"] !== undefined) data["InRateCenter"] = params["inRateCenter"];
        if (params["inLata"] !== undefined) data["InLata"] = params["inLata"];
        if (params["inLocality"] !== undefined) data["InLocality"] = params["inLocality"];
        if (params["faxEnabled"] !== undefined) data["FaxEnabled"] = serialize.bool(params["faxEnabled"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new SharedCostPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new SharedCostPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["areaCode"] !== undefined) data["AreaCode"] = params["areaCode"];
        if (params["contains"] !== undefined) data["Contains"] = params["contains"];
        if (params["smsEnabled"] !== undefined) data["SmsEnabled"] = serialize.bool(params["smsEnabled"]);
        if (params["mmsEnabled"] !== undefined) data["MmsEnabled"] = serialize.bool(params["mmsEnabled"]);
        if (params["voiceEnabled"] !== undefined) data["VoiceEnabled"] = serialize.bool(params["voiceEnabled"]);
        if (params["excludeAllAddressRequired"] !== undefined) data["ExcludeAllAddressRequired"] = serialize.bool(params["excludeAllAddressRequired"]);
        if (params["excludeLocalAddressRequired"] !== undefined) data["ExcludeLocalAddressRequired"] = serialize.bool(params["excludeLocalAddressRequired"]);
        if (params["excludeForeignAddressRequired"] !== undefined) data["ExcludeForeignAddressRequired"] = serialize.bool(params["excludeForeignAddressRequired"]);
        if (params["beta"] !== undefined) data["Beta"] = serialize.bool(params["beta"]);
        if (params["nearNumber"] !== undefined) data["NearNumber"] = params["nearNumber"];
        if (params["nearLatLong"] !== undefined) data["NearLatLong"] = params["nearLatLong"];
        if (params["distance"] !== undefined) data["Distance"] = params["distance"];
        if (params["inPostalCode"] !== undefined) data["InPostalCode"] = params["inPostalCode"];
        if (params["inRegion"] !== undefined) data["InRegion"] = params["inRegion"];
        if (params["inRateCenter"] !== undefined) data["InRateCenter"] = params["inRateCenter"];
        if (params["inLata"] !== undefined) data["InLata"] = params["inLata"];
        if (params["inLocality"] !== undefined) data["InLocality"] = params["inLocality"];
        if (params["faxEnabled"] !== undefined) data["FaxEnabled"] = serialize.bool(params["faxEnabled"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new SharedCostPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new SharedCostPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class SharedCostInstance {
    constructor(_version, payload, accountSid, countryCode){
        this._version = _version;
        this.friendlyName = payload.friendly_name;
        this.phoneNumber = payload.phone_number;
        this.lata = payload.lata;
        this.locality = payload.locality;
        this.rateCenter = payload.rate_center;
        this.latitude = payload.latitude;
        this.longitude = payload.longitude;
        this.region = payload.region;
        this.postalCode = payload.postal_code;
        this.isoCountry = payload.iso_country;
        this.addressRequirements = payload.address_requirements;
        this.beta = payload.beta;
        this.capabilities = payload.capabilities;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            friendlyName: this.friendlyName,
            phoneNumber: this.phoneNumber,
            lata: this.lata,
            locality: this.locality,
            rateCenter: this.rateCenter,
            latitude: this.latitude,
            longitude: this.longitude,
            region: this.region,
            postalCode: this.postalCode,
            isoCountry: this.isoCountry,
            addressRequirements: this.addressRequirements,
            beta: this.beta,
            capabilities: this.capabilities
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.SharedCostInstance = SharedCostInstance;
class SharedCostPage extends Page_1.default {
    /**
     * Initialize the SharedCostPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of SharedCostInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new SharedCostInstance(this._version, payload, this._solution.accountSid, this._solution.countryCode);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.SharedCostPage = SharedCostPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/availablePhoneNumberCountry/tollFree.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TollFreePage = exports.TollFreeInstance = void 0;
exports.TollFreeListInstance = TollFreeListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
function TollFreeListInstance(version, accountSid, countryCode) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    if (!(0, utility_1.isValidPathParam)(countryCode)) {
        throw new Error("Parameter 'countryCode' is not valid.");
    }
    const instance = {};
    instance._version = version;
    instance._solution = {
        accountSid,
        countryCode
    };
    instance._uri = `/Accounts/${accountSid}/AvailablePhoneNumbers/${countryCode}/TollFree.json`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["areaCode"] !== undefined) data["AreaCode"] = params["areaCode"];
        if (params["contains"] !== undefined) data["Contains"] = params["contains"];
        if (params["smsEnabled"] !== undefined) data["SmsEnabled"] = serialize.bool(params["smsEnabled"]);
        if (params["mmsEnabled"] !== undefined) data["MmsEnabled"] = serialize.bool(params["mmsEnabled"]);
        if (params["voiceEnabled"] !== undefined) data["VoiceEnabled"] = serialize.bool(params["voiceEnabled"]);
        if (params["excludeAllAddressRequired"] !== undefined) data["ExcludeAllAddressRequired"] = serialize.bool(params["excludeAllAddressRequired"]);
        if (params["excludeLocalAddressRequired"] !== undefined) data["ExcludeLocalAddressRequired"] = serialize.bool(params["excludeLocalAddressRequired"]);
        if (params["excludeForeignAddressRequired"] !== undefined) data["ExcludeForeignAddressRequired"] = serialize.bool(params["excludeForeignAddressRequired"]);
        if (params["beta"] !== undefined) data["Beta"] = serialize.bool(params["beta"]);
        if (params["nearNumber"] !== undefined) data["NearNumber"] = params["nearNumber"];
        if (params["nearLatLong"] !== undefined) data["NearLatLong"] = params["nearLatLong"];
        if (params["distance"] !== undefined) data["Distance"] = params["distance"];
        if (params["inPostalCode"] !== undefined) data["InPostalCode"] = params["inPostalCode"];
        if (params["inRegion"] !== undefined) data["InRegion"] = params["inRegion"];
        if (params["inRateCenter"] !== undefined) data["InRateCenter"] = params["inRateCenter"];
        if (params["inLata"] !== undefined) data["InLata"] = params["inLata"];
        if (params["inLocality"] !== undefined) data["InLocality"] = params["inLocality"];
        if (params["faxEnabled"] !== undefined) data["FaxEnabled"] = serialize.bool(params["faxEnabled"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new TollFreePage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new TollFreePage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["areaCode"] !== undefined) data["AreaCode"] = params["areaCode"];
        if (params["contains"] !== undefined) data["Contains"] = params["contains"];
        if (params["smsEnabled"] !== undefined) data["SmsEnabled"] = serialize.bool(params["smsEnabled"]);
        if (params["mmsEnabled"] !== undefined) data["MmsEnabled"] = serialize.bool(params["mmsEnabled"]);
        if (params["voiceEnabled"] !== undefined) data["VoiceEnabled"] = serialize.bool(params["voiceEnabled"]);
        if (params["excludeAllAddressRequired"] !== undefined) data["ExcludeAllAddressRequired"] = serialize.bool(params["excludeAllAddressRequired"]);
        if (params["excludeLocalAddressRequired"] !== undefined) data["ExcludeLocalAddressRequired"] = serialize.bool(params["excludeLocalAddressRequired"]);
        if (params["excludeForeignAddressRequired"] !== undefined) data["ExcludeForeignAddressRequired"] = serialize.bool(params["excludeForeignAddressRequired"]);
        if (params["beta"] !== undefined) data["Beta"] = serialize.bool(params["beta"]);
        if (params["nearNumber"] !== undefined) data["NearNumber"] = params["nearNumber"];
        if (params["nearLatLong"] !== undefined) data["NearLatLong"] = params["nearLatLong"];
        if (params["distance"] !== undefined) data["Distance"] = params["distance"];
        if (params["inPostalCode"] !== undefined) data["InPostalCode"] = params["inPostalCode"];
        if (params["inRegion"] !== undefined) data["InRegion"] = params["inRegion"];
        if (params["inRateCenter"] !== undefined) data["InRateCenter"] = params["inRateCenter"];
        if (params["inLata"] !== undefined) data["InLata"] = params["inLata"];
        if (params["inLocality"] !== undefined) data["InLocality"] = params["inLocality"];
        if (params["faxEnabled"] !== undefined) data["FaxEnabled"] = serialize.bool(params["faxEnabled"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new TollFreePage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new TollFreePage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class TollFreeInstance {
    constructor(_version, payload, accountSid, countryCode){
        this._version = _version;
        this.friendlyName = payload.friendly_name;
        this.phoneNumber = payload.phone_number;
        this.lata = payload.lata;
        this.locality = payload.locality;
        this.rateCenter = payload.rate_center;
        this.latitude = payload.latitude;
        this.longitude = payload.longitude;
        this.region = payload.region;
        this.postalCode = payload.postal_code;
        this.isoCountry = payload.iso_country;
        this.addressRequirements = payload.address_requirements;
        this.beta = payload.beta;
        this.capabilities = payload.capabilities;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            friendlyName: this.friendlyName,
            phoneNumber: this.phoneNumber,
            lata: this.lata,
            locality: this.locality,
            rateCenter: this.rateCenter,
            latitude: this.latitude,
            longitude: this.longitude,
            region: this.region,
            postalCode: this.postalCode,
            isoCountry: this.isoCountry,
            addressRequirements: this.addressRequirements,
            beta: this.beta,
            capabilities: this.capabilities
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.TollFreeInstance = TollFreeInstance;
class TollFreePage extends Page_1.default {
    /**
     * Initialize the TollFreePage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of TollFreeInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new TollFreeInstance(this._version, payload, this._solution.accountSid, this._solution.countryCode);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.TollFreePage = TollFreePage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/availablePhoneNumberCountry/voip.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VoipPage = exports.VoipInstance = void 0;
exports.VoipListInstance = VoipListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
function VoipListInstance(version, accountSid, countryCode) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    if (!(0, utility_1.isValidPathParam)(countryCode)) {
        throw new Error("Parameter 'countryCode' is not valid.");
    }
    const instance = {};
    instance._version = version;
    instance._solution = {
        accountSid,
        countryCode
    };
    instance._uri = `/Accounts/${accountSid}/AvailablePhoneNumbers/${countryCode}/Voip.json`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["areaCode"] !== undefined) data["AreaCode"] = params["areaCode"];
        if (params["contains"] !== undefined) data["Contains"] = params["contains"];
        if (params["smsEnabled"] !== undefined) data["SmsEnabled"] = serialize.bool(params["smsEnabled"]);
        if (params["mmsEnabled"] !== undefined) data["MmsEnabled"] = serialize.bool(params["mmsEnabled"]);
        if (params["voiceEnabled"] !== undefined) data["VoiceEnabled"] = serialize.bool(params["voiceEnabled"]);
        if (params["excludeAllAddressRequired"] !== undefined) data["ExcludeAllAddressRequired"] = serialize.bool(params["excludeAllAddressRequired"]);
        if (params["excludeLocalAddressRequired"] !== undefined) data["ExcludeLocalAddressRequired"] = serialize.bool(params["excludeLocalAddressRequired"]);
        if (params["excludeForeignAddressRequired"] !== undefined) data["ExcludeForeignAddressRequired"] = serialize.bool(params["excludeForeignAddressRequired"]);
        if (params["beta"] !== undefined) data["Beta"] = serialize.bool(params["beta"]);
        if (params["nearNumber"] !== undefined) data["NearNumber"] = params["nearNumber"];
        if (params["nearLatLong"] !== undefined) data["NearLatLong"] = params["nearLatLong"];
        if (params["distance"] !== undefined) data["Distance"] = params["distance"];
        if (params["inPostalCode"] !== undefined) data["InPostalCode"] = params["inPostalCode"];
        if (params["inRegion"] !== undefined) data["InRegion"] = params["inRegion"];
        if (params["inRateCenter"] !== undefined) data["InRateCenter"] = params["inRateCenter"];
        if (params["inLata"] !== undefined) data["InLata"] = params["inLata"];
        if (params["inLocality"] !== undefined) data["InLocality"] = params["inLocality"];
        if (params["faxEnabled"] !== undefined) data["FaxEnabled"] = serialize.bool(params["faxEnabled"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new VoipPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new VoipPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["areaCode"] !== undefined) data["AreaCode"] = params["areaCode"];
        if (params["contains"] !== undefined) data["Contains"] = params["contains"];
        if (params["smsEnabled"] !== undefined) data["SmsEnabled"] = serialize.bool(params["smsEnabled"]);
        if (params["mmsEnabled"] !== undefined) data["MmsEnabled"] = serialize.bool(params["mmsEnabled"]);
        if (params["voiceEnabled"] !== undefined) data["VoiceEnabled"] = serialize.bool(params["voiceEnabled"]);
        if (params["excludeAllAddressRequired"] !== undefined) data["ExcludeAllAddressRequired"] = serialize.bool(params["excludeAllAddressRequired"]);
        if (params["excludeLocalAddressRequired"] !== undefined) data["ExcludeLocalAddressRequired"] = serialize.bool(params["excludeLocalAddressRequired"]);
        if (params["excludeForeignAddressRequired"] !== undefined) data["ExcludeForeignAddressRequired"] = serialize.bool(params["excludeForeignAddressRequired"]);
        if (params["beta"] !== undefined) data["Beta"] = serialize.bool(params["beta"]);
        if (params["nearNumber"] !== undefined) data["NearNumber"] = params["nearNumber"];
        if (params["nearLatLong"] !== undefined) data["NearLatLong"] = params["nearLatLong"];
        if (params["distance"] !== undefined) data["Distance"] = params["distance"];
        if (params["inPostalCode"] !== undefined) data["InPostalCode"] = params["inPostalCode"];
        if (params["inRegion"] !== undefined) data["InRegion"] = params["inRegion"];
        if (params["inRateCenter"] !== undefined) data["InRateCenter"] = params["inRateCenter"];
        if (params["inLata"] !== undefined) data["InLata"] = params["inLata"];
        if (params["inLocality"] !== undefined) data["InLocality"] = params["inLocality"];
        if (params["faxEnabled"] !== undefined) data["FaxEnabled"] = serialize.bool(params["faxEnabled"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new VoipPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new VoipPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class VoipInstance {
    constructor(_version, payload, accountSid, countryCode){
        this._version = _version;
        this.friendlyName = payload.friendly_name;
        this.phoneNumber = payload.phone_number;
        this.lata = payload.lata;
        this.locality = payload.locality;
        this.rateCenter = payload.rate_center;
        this.latitude = payload.latitude;
        this.longitude = payload.longitude;
        this.region = payload.region;
        this.postalCode = payload.postal_code;
        this.isoCountry = payload.iso_country;
        this.addressRequirements = payload.address_requirements;
        this.beta = payload.beta;
        this.capabilities = payload.capabilities;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            friendlyName: this.friendlyName,
            phoneNumber: this.phoneNumber,
            lata: this.lata,
            locality: this.locality,
            rateCenter: this.rateCenter,
            latitude: this.latitude,
            longitude: this.longitude,
            region: this.region,
            postalCode: this.postalCode,
            isoCountry: this.isoCountry,
            addressRequirements: this.addressRequirements,
            beta: this.beta,
            capabilities: this.capabilities
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.VoipInstance = VoipInstance;
class VoipPage extends Page_1.default {
    /**
     * Initialize the VoipPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of VoipInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new VoipInstance(this._version, payload, this._solution.accountSid, this._solution.countryCode);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.VoipPage = VoipPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/availablePhoneNumberCountry.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AvailablePhoneNumberCountryPage = exports.AvailablePhoneNumberCountryInstance = exports.AvailablePhoneNumberCountryContextImpl = void 0;
exports.AvailablePhoneNumberCountryListInstance = AvailablePhoneNumberCountryListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
const local_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/availablePhoneNumberCountry/local.js [app-route] (ecmascript)");
const machineToMachine_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/availablePhoneNumberCountry/machineToMachine.js [app-route] (ecmascript)");
const mobile_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/availablePhoneNumberCountry/mobile.js [app-route] (ecmascript)");
const national_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/availablePhoneNumberCountry/national.js [app-route] (ecmascript)");
const sharedCost_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/availablePhoneNumberCountry/sharedCost.js [app-route] (ecmascript)");
const tollFree_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/availablePhoneNumberCountry/tollFree.js [app-route] (ecmascript)");
const voip_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/availablePhoneNumberCountry/voip.js [app-route] (ecmascript)");
class AvailablePhoneNumberCountryContextImpl {
    constructor(_version, accountSid, countryCode){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(accountSid)) {
            throw new Error("Parameter 'accountSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(countryCode)) {
            throw new Error("Parameter 'countryCode' is not valid.");
        }
        this._solution = {
            accountSid,
            countryCode
        };
        this._uri = `/Accounts/${accountSid}/AvailablePhoneNumbers/${countryCode}.json`;
    }
    get local() {
        this._local = this._local || (0, local_1.LocalListInstance)(this._version, this._solution.accountSid, this._solution.countryCode);
        return this._local;
    }
    get machineToMachine() {
        this._machineToMachine = this._machineToMachine || (0, machineToMachine_1.MachineToMachineListInstance)(this._version, this._solution.accountSid, this._solution.countryCode);
        return this._machineToMachine;
    }
    get mobile() {
        this._mobile = this._mobile || (0, mobile_1.MobileListInstance)(this._version, this._solution.accountSid, this._solution.countryCode);
        return this._mobile;
    }
    get national() {
        this._national = this._national || (0, national_1.NationalListInstance)(this._version, this._solution.accountSid, this._solution.countryCode);
        return this._national;
    }
    get sharedCost() {
        this._sharedCost = this._sharedCost || (0, sharedCost_1.SharedCostListInstance)(this._version, this._solution.accountSid, this._solution.countryCode);
        return this._sharedCost;
    }
    get tollFree() {
        this._tollFree = this._tollFree || (0, tollFree_1.TollFreeListInstance)(this._version, this._solution.accountSid, this._solution.countryCode);
        return this._tollFree;
    }
    get voip() {
        this._voip = this._voip || (0, voip_1.VoipListInstance)(this._version, this._solution.accountSid, this._solution.countryCode);
        return this._voip;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new AvailablePhoneNumberCountryInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.countryCode));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new AvailablePhoneNumberCountryInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.countryCode)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.AvailablePhoneNumberCountryContextImpl = AvailablePhoneNumberCountryContextImpl;
class AvailablePhoneNumberCountryInstance {
    constructor(_version, payload, accountSid, countryCode){
        this._version = _version;
        this.countryCode = payload.country_code;
        this.country = payload.country;
        this.uri = payload.uri;
        this.beta = payload.beta;
        this.subresourceUris = payload.subresource_uris;
        this._solution = {
            accountSid,
            countryCode: countryCode || this.countryCode
        };
    }
    get _proxy() {
        this._context = this._context || new AvailablePhoneNumberCountryContextImpl(this._version, this._solution.accountSid, this._solution.countryCode);
        return this._context;
    }
    /**
     * Fetch a AvailablePhoneNumberCountryInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed AvailablePhoneNumberCountryInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a AvailablePhoneNumberCountryInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed AvailablePhoneNumberCountryInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    /**
     * Access the local.
     */ local() {
        return this._proxy.local;
    }
    /**
     * Access the machineToMachine.
     */ machineToMachine() {
        return this._proxy.machineToMachine;
    }
    /**
     * Access the mobile.
     */ mobile() {
        return this._proxy.mobile;
    }
    /**
     * Access the national.
     */ national() {
        return this._proxy.national;
    }
    /**
     * Access the sharedCost.
     */ sharedCost() {
        return this._proxy.sharedCost;
    }
    /**
     * Access the tollFree.
     */ tollFree() {
        return this._proxy.tollFree;
    }
    /**
     * Access the voip.
     */ voip() {
        return this._proxy.voip;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            countryCode: this.countryCode,
            country: this.country,
            uri: this.uri,
            beta: this.beta,
            subresourceUris: this.subresourceUris
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.AvailablePhoneNumberCountryInstance = AvailablePhoneNumberCountryInstance;
function AvailablePhoneNumberCountryListInstance(version, accountSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    const instance = (countryCode)=>instance.get(countryCode);
    instance.get = function get(countryCode) {
        return new AvailablePhoneNumberCountryContextImpl(version, accountSid, countryCode);
    };
    instance._version = version;
    instance._solution = {
        accountSid
    };
    instance._uri = `/Accounts/${accountSid}/AvailablePhoneNumbers.json`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new AvailablePhoneNumberCountryPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new AvailablePhoneNumberCountryPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new AvailablePhoneNumberCountryPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new AvailablePhoneNumberCountryPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class AvailablePhoneNumberCountryPage extends Page_1.default {
    /**
     * Initialize the AvailablePhoneNumberCountryPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of AvailablePhoneNumberCountryInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new AvailablePhoneNumberCountryInstance(this._version, payload, this._solution.accountSid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.AvailablePhoneNumberCountryPage = AvailablePhoneNumberCountryPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/balance.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BalanceInstance = void 0;
exports.BalanceListInstance = BalanceListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
function BalanceListInstance(version, accountSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    const instance = {};
    instance._version = version;
    instance._solution = {
        accountSid
    };
    instance._uri = `/Accounts/${accountSid}/Balance.json`;
    instance.fetch = function fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new BalanceInstance(operationVersion, payload, instance._solution.accountSid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.fetchWithHttpInfo = function fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new BalanceInstance(operationVersion, response.body, instance._solution.accountSid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class BalanceInstance {
    constructor(_version, payload, accountSid){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.balance = payload.balance;
        this.currency = payload.currency;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            balance: this.balance,
            currency: this.currency
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.BalanceInstance = BalanceInstance;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/call.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CallPage = exports.CallInstance = exports.CallContextImpl = void 0;
exports.CallListInstance = CallListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
const event_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/call/event.js [app-route] (ecmascript)");
const notification_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/call/notification.js [app-route] (ecmascript)");
const payment_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/call/payment.js [app-route] (ecmascript)");
const recording_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/call/recording.js [app-route] (ecmascript)");
const siprec_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/call/siprec.js [app-route] (ecmascript)");
const stream_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/call/stream.js [app-route] (ecmascript)");
const transcription_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/call/transcription.js [app-route] (ecmascript)");
const userDefinedMessage_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/call/userDefinedMessage.js [app-route] (ecmascript)");
const userDefinedMessageSubscription_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/call/userDefinedMessageSubscription.js [app-route] (ecmascript)");
class CallContextImpl {
    constructor(_version, accountSid, sid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(accountSid)) {
            throw new Error("Parameter 'accountSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(sid)) {
            throw new Error("Parameter 'sid' is not valid.");
        }
        this._solution = {
            accountSid,
            sid
        };
        this._uri = `/Accounts/${accountSid}/Calls/${sid}.json`;
    }
    get events() {
        this._events = this._events || (0, event_1.EventListInstance)(this._version, this._solution.accountSid, this._solution.sid);
        return this._events;
    }
    get notifications() {
        this._notifications = this._notifications || (0, notification_1.NotificationListInstance)(this._version, this._solution.accountSid, this._solution.sid);
        return this._notifications;
    }
    get payments() {
        this._payments = this._payments || (0, payment_1.PaymentListInstance)(this._version, this._solution.accountSid, this._solution.sid);
        return this._payments;
    }
    get recordings() {
        this._recordings = this._recordings || (0, recording_1.RecordingListInstance)(this._version, this._solution.accountSid, this._solution.sid);
        return this._recordings;
    }
    get siprec() {
        this._siprec = this._siprec || (0, siprec_1.SiprecListInstance)(this._version, this._solution.accountSid, this._solution.sid);
        return this._siprec;
    }
    get streams() {
        this._streams = this._streams || (0, stream_1.StreamListInstance)(this._version, this._solution.accountSid, this._solution.sid);
        return this._streams;
    }
    get transcriptions() {
        this._transcriptions = this._transcriptions || (0, transcription_1.TranscriptionListInstance)(this._version, this._solution.accountSid, this._solution.sid);
        return this._transcriptions;
    }
    get userDefinedMessages() {
        this._userDefinedMessages = this._userDefinedMessages || (0, userDefinedMessage_1.UserDefinedMessageListInstance)(this._version, this._solution.accountSid, this._solution.sid);
        return this._userDefinedMessages;
    }
    get userDefinedMessageSubscriptions() {
        this._userDefinedMessageSubscriptions = this._userDefinedMessageSubscriptions || (0, userDefinedMessageSubscription_1.UserDefinedMessageSubscriptionListInstance)(this._version, this._solution.accountSid, this._solution.sid);
        return this._userDefinedMessageSubscriptions;
    }
    remove(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.remove({
            uri: instance._uri,
            method: "delete",
            headers
        });
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    removeWithHttpInfo(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version;
        // DELETE operation - returns boolean based on status code
        let operationPromise = operationVersion.removeWithResponseInfo({
            uri: instance._uri,
            method: "delete",
            headers
        }).then((response)=>({
                ...response,
                body: response.statusCode === 204
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new CallInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new CallInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    update(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["url"] !== undefined) data["Url"] = params["url"];
        if (params["method"] !== undefined) data["Method"] = params["method"];
        if (params["status"] !== undefined) data["Status"] = params["status"];
        if (params["fallbackUrl"] !== undefined) data["FallbackUrl"] = params["fallbackUrl"];
        if (params["fallbackMethod"] !== undefined) data["FallbackMethod"] = params["fallbackMethod"];
        if (params["statusCallback"] !== undefined) data["StatusCallback"] = params["statusCallback"];
        if (params["statusCallbackMethod"] !== undefined) data["StatusCallbackMethod"] = params["statusCallbackMethod"];
        if (params["twiml"] !== undefined) data["Twiml"] = serialize.twiml(params["twiml"]);
        if (params["timeLimit"] !== undefined) data["TimeLimit"] = params["timeLimit"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.update({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new CallInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    updateWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["url"] !== undefined) data["Url"] = params["url"];
        if (params["method"] !== undefined) data["Method"] = params["method"];
        if (params["status"] !== undefined) data["Status"] = params["status"];
        if (params["fallbackUrl"] !== undefined) data["FallbackUrl"] = params["fallbackUrl"];
        if (params["fallbackMethod"] !== undefined) data["FallbackMethod"] = params["fallbackMethod"];
        if (params["statusCallback"] !== undefined) data["StatusCallback"] = params["statusCallback"];
        if (params["statusCallbackMethod"] !== undefined) data["StatusCallbackMethod"] = params["statusCallbackMethod"];
        if (params["twiml"] !== undefined) data["Twiml"] = serialize.twiml(params["twiml"]);
        if (params["timeLimit"] !== undefined) data["TimeLimit"] = params["timeLimit"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.updateWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new CallInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.CallContextImpl = CallContextImpl;
class CallInstance {
    constructor(_version, payload, accountSid, sid){
        this._version = _version;
        this.sid = payload.sid;
        this.dateCreated = deserialize.rfc2822DateTime(payload.date_created);
        this.dateUpdated = deserialize.rfc2822DateTime(payload.date_updated);
        this.parentCallSid = payload.parent_call_sid;
        this.accountSid = payload.account_sid;
        this.to = payload.to;
        this.toFormatted = payload.to_formatted;
        this.from = payload.from;
        this.fromFormatted = payload.from_formatted;
        this.phoneNumberSid = payload.phone_number_sid;
        this.status = payload.status;
        this.startTime = deserialize.rfc2822DateTime(payload.start_time);
        this.endTime = deserialize.rfc2822DateTime(payload.end_time);
        this.duration = payload.duration;
        this.price = payload.price;
        this.priceUnit = payload.price_unit;
        this.direction = payload.direction;
        this.answeredBy = payload.answered_by;
        this.apiVersion = payload.api_version;
        this.forwardedFrom = payload.forwarded_from;
        this.groupSid = payload.group_sid;
        this.callerName = payload.caller_name;
        this.queueTime = payload.queue_time;
        this.trunkSid = payload.trunk_sid;
        this.uri = payload.uri;
        this.subresourceUris = payload.subresource_uris;
        this._solution = {
            accountSid,
            sid: sid || this.sid
        };
    }
    get _proxy() {
        this._context = this._context || new CallContextImpl(this._version, this._solution.accountSid, this._solution.sid);
        return this._context;
    }
    /**
     * Remove a CallInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean
     */ remove(callback) {
        return this._proxy.remove(callback);
    }
    /**
     * Remove a CallInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean with HTTP metadata
     */ removeWithHttpInfo(callback) {
        return this._proxy.removeWithHttpInfo(callback);
    }
    /**
     * Fetch a CallInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed CallInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a CallInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed CallInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    update(params, callback) {
        return this._proxy.update(params, callback);
    }
    updateWithHttpInfo(params, callback) {
        return this._proxy.updateWithHttpInfo(params, callback);
    }
    /**
     * Access the events.
     */ events() {
        return this._proxy.events;
    }
    /**
     * Access the notifications.
     */ notifications() {
        return this._proxy.notifications;
    }
    /**
     * Access the payments.
     */ payments() {
        return this._proxy.payments;
    }
    /**
     * Access the recordings.
     */ recordings() {
        return this._proxy.recordings;
    }
    /**
     * Access the siprec.
     */ siprec() {
        return this._proxy.siprec;
    }
    /**
     * Access the streams.
     */ streams() {
        return this._proxy.streams;
    }
    /**
     * Access the transcriptions.
     */ transcriptions() {
        return this._proxy.transcriptions;
    }
    /**
     * Access the userDefinedMessages.
     */ userDefinedMessages() {
        return this._proxy.userDefinedMessages;
    }
    /**
     * Access the userDefinedMessageSubscriptions.
     */ userDefinedMessageSubscriptions() {
        return this._proxy.userDefinedMessageSubscriptions;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            sid: this.sid,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated,
            parentCallSid: this.parentCallSid,
            accountSid: this.accountSid,
            to: this.to,
            toFormatted: this.toFormatted,
            from: this.from,
            fromFormatted: this.fromFormatted,
            phoneNumberSid: this.phoneNumberSid,
            status: this.status,
            startTime: this.startTime,
            endTime: this.endTime,
            duration: this.duration,
            price: this.price,
            priceUnit: this.priceUnit,
            direction: this.direction,
            answeredBy: this.answeredBy,
            apiVersion: this.apiVersion,
            forwardedFrom: this.forwardedFrom,
            groupSid: this.groupSid,
            callerName: this.callerName,
            queueTime: this.queueTime,
            trunkSid: this.trunkSid,
            uri: this.uri,
            subresourceUris: this.subresourceUris
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.CallInstance = CallInstance;
function CallListInstance(version, accountSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    const instance = (sid)=>instance.get(sid);
    instance.get = function get(sid) {
        return new CallContextImpl(version, accountSid, sid);
    };
    instance._version = version;
    instance._solution = {
        accountSid
    };
    instance._uri = `/Accounts/${accountSid}/Calls.json`;
    instance.create = function create(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["to"] === null || params["to"] === undefined) {
            throw new Error("Required parameter \"params['to']\" missing.");
        }
        if (params["from"] === null || params["from"] === undefined) {
            throw new Error("Required parameter \"params['from']\" missing.");
        }
        let data = {};
        data["To"] = params["to"];
        data["From"] = params["from"];
        if (params["method"] !== undefined) data["Method"] = params["method"];
        if (params["fallbackUrl"] !== undefined) data["FallbackUrl"] = params["fallbackUrl"];
        if (params["fallbackMethod"] !== undefined) data["FallbackMethod"] = params["fallbackMethod"];
        if (params["statusCallback"] !== undefined) data["StatusCallback"] = params["statusCallback"];
        if (params["statusCallbackEvent"] !== undefined) data["StatusCallbackEvent"] = serialize.map(params["statusCallbackEvent"], (e)=>e);
        if (params["statusCallbackMethod"] !== undefined) data["StatusCallbackMethod"] = params["statusCallbackMethod"];
        if (params["sendDigits"] !== undefined) data["SendDigits"] = params["sendDigits"];
        if (params["timeout"] !== undefined) data["Timeout"] = params["timeout"];
        if (params["record"] !== undefined) data["Record"] = serialize.bool(params["record"]);
        if (params["recordingChannels"] !== undefined) data["RecordingChannels"] = params["recordingChannels"];
        if (params["recordingStatusCallback"] !== undefined) data["RecordingStatusCallback"] = params["recordingStatusCallback"];
        if (params["recordingStatusCallbackMethod"] !== undefined) data["RecordingStatusCallbackMethod"] = params["recordingStatusCallbackMethod"];
        if (params["sipAuthUsername"] !== undefined) data["SipAuthUsername"] = params["sipAuthUsername"];
        if (params["sipAuthPassword"] !== undefined) data["SipAuthPassword"] = params["sipAuthPassword"];
        if (params["machineDetection"] !== undefined) data["MachineDetection"] = params["machineDetection"];
        if (params["machineDetectionTimeout"] !== undefined) data["MachineDetectionTimeout"] = params["machineDetectionTimeout"];
        if (params["recordingStatusCallbackEvent"] !== undefined) data["RecordingStatusCallbackEvent"] = serialize.map(params["recordingStatusCallbackEvent"], (e)=>e);
        if (params["trim"] !== undefined) data["Trim"] = params["trim"];
        if (params["callerId"] !== undefined) data["CallerId"] = params["callerId"];
        if (params["machineDetectionSpeechThreshold"] !== undefined) data["MachineDetectionSpeechThreshold"] = params["machineDetectionSpeechThreshold"];
        if (params["machineDetectionSpeechEndThreshold"] !== undefined) data["MachineDetectionSpeechEndThreshold"] = params["machineDetectionSpeechEndThreshold"];
        if (params["machineDetectionSilenceTimeout"] !== undefined) data["MachineDetectionSilenceTimeout"] = params["machineDetectionSilenceTimeout"];
        if (params["asyncAmd"] !== undefined) data["AsyncAmd"] = params["asyncAmd"];
        if (params["asyncAmdStatusCallback"] !== undefined) data["AsyncAmdStatusCallback"] = params["asyncAmdStatusCallback"];
        if (params["asyncAmdStatusCallbackMethod"] !== undefined) data["AsyncAmdStatusCallbackMethod"] = params["asyncAmdStatusCallbackMethod"];
        if (params["byoc"] !== undefined) data["Byoc"] = params["byoc"];
        if (params["callReason"] !== undefined) data["CallReason"] = params["callReason"];
        if (params["callToken"] !== undefined) data["CallToken"] = params["callToken"];
        if (params["recordingTrack"] !== undefined) data["RecordingTrack"] = params["recordingTrack"];
        if (params["timeLimit"] !== undefined) data["TimeLimit"] = params["timeLimit"];
        if (params["clientNotificationUrl"] !== undefined) data["ClientNotificationUrl"] = params["clientNotificationUrl"];
        if (params["url"] !== undefined) data["Url"] = params["url"];
        if (params["twiml"] !== undefined) data["Twiml"] = serialize.twiml(params["twiml"]);
        if (params["applicationSid"] !== undefined) data["ApplicationSid"] = params["applicationSid"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.create({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new CallInstance(operationVersion, payload, instance._solution.accountSid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.createWithHttpInfo = function createWithHttpInfo(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["to"] === null || params["to"] === undefined) {
            throw new Error("Required parameter \"params['to']\" missing.");
        }
        if (params["from"] === null || params["from"] === undefined) {
            throw new Error("Required parameter \"params['from']\" missing.");
        }
        let data = {};
        data["To"] = params["to"];
        data["From"] = params["from"];
        if (params["method"] !== undefined) data["Method"] = params["method"];
        if (params["fallbackUrl"] !== undefined) data["FallbackUrl"] = params["fallbackUrl"];
        if (params["fallbackMethod"] !== undefined) data["FallbackMethod"] = params["fallbackMethod"];
        if (params["statusCallback"] !== undefined) data["StatusCallback"] = params["statusCallback"];
        if (params["statusCallbackEvent"] !== undefined) data["StatusCallbackEvent"] = serialize.map(params["statusCallbackEvent"], (e)=>e);
        if (params["statusCallbackMethod"] !== undefined) data["StatusCallbackMethod"] = params["statusCallbackMethod"];
        if (params["sendDigits"] !== undefined) data["SendDigits"] = params["sendDigits"];
        if (params["timeout"] !== undefined) data["Timeout"] = params["timeout"];
        if (params["record"] !== undefined) data["Record"] = serialize.bool(params["record"]);
        if (params["recordingChannels"] !== undefined) data["RecordingChannels"] = params["recordingChannels"];
        if (params["recordingStatusCallback"] !== undefined) data["RecordingStatusCallback"] = params["recordingStatusCallback"];
        if (params["recordingStatusCallbackMethod"] !== undefined) data["RecordingStatusCallbackMethod"] = params["recordingStatusCallbackMethod"];
        if (params["sipAuthUsername"] !== undefined) data["SipAuthUsername"] = params["sipAuthUsername"];
        if (params["sipAuthPassword"] !== undefined) data["SipAuthPassword"] = params["sipAuthPassword"];
        if (params["machineDetection"] !== undefined) data["MachineDetection"] = params["machineDetection"];
        if (params["machineDetectionTimeout"] !== undefined) data["MachineDetectionTimeout"] = params["machineDetectionTimeout"];
        if (params["recordingStatusCallbackEvent"] !== undefined) data["RecordingStatusCallbackEvent"] = serialize.map(params["recordingStatusCallbackEvent"], (e)=>e);
        if (params["trim"] !== undefined) data["Trim"] = params["trim"];
        if (params["callerId"] !== undefined) data["CallerId"] = params["callerId"];
        if (params["machineDetectionSpeechThreshold"] !== undefined) data["MachineDetectionSpeechThreshold"] = params["machineDetectionSpeechThreshold"];
        if (params["machineDetectionSpeechEndThreshold"] !== undefined) data["MachineDetectionSpeechEndThreshold"] = params["machineDetectionSpeechEndThreshold"];
        if (params["machineDetectionSilenceTimeout"] !== undefined) data["MachineDetectionSilenceTimeout"] = params["machineDetectionSilenceTimeout"];
        if (params["asyncAmd"] !== undefined) data["AsyncAmd"] = params["asyncAmd"];
        if (params["asyncAmdStatusCallback"] !== undefined) data["AsyncAmdStatusCallback"] = params["asyncAmdStatusCallback"];
        if (params["asyncAmdStatusCallbackMethod"] !== undefined) data["AsyncAmdStatusCallbackMethod"] = params["asyncAmdStatusCallbackMethod"];
        if (params["byoc"] !== undefined) data["Byoc"] = params["byoc"];
        if (params["callReason"] !== undefined) data["CallReason"] = params["callReason"];
        if (params["callToken"] !== undefined) data["CallToken"] = params["callToken"];
        if (params["recordingTrack"] !== undefined) data["RecordingTrack"] = params["recordingTrack"];
        if (params["timeLimit"] !== undefined) data["TimeLimit"] = params["timeLimit"];
        if (params["clientNotificationUrl"] !== undefined) data["ClientNotificationUrl"] = params["clientNotificationUrl"];
        if (params["url"] !== undefined) data["Url"] = params["url"];
        if (params["twiml"] !== undefined) data["Twiml"] = serialize.twiml(params["twiml"]);
        if (params["applicationSid"] !== undefined) data["ApplicationSid"] = params["applicationSid"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.createWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new CallInstance(operationVersion, response.body, instance._solution.accountSid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["to"] !== undefined) data["To"] = params["to"];
        if (params["from"] !== undefined) data["From"] = params["from"];
        if (params["parentCallSid"] !== undefined) data["ParentCallSid"] = params["parentCallSid"];
        if (params["status"] !== undefined) data["Status"] = params["status"];
        if (params["startTime"] !== undefined) data["StartTime"] = serialize.iso8601DateTime(params["startTime"]);
        if (params["startTimeBefore"] !== undefined) data["StartTime<"] = serialize.iso8601DateTime(params["startTimeBefore"]);
        if (params["startTimeAfter"] !== undefined) data["StartTime>"] = serialize.iso8601DateTime(params["startTimeAfter"]);
        if (params["endTime"] !== undefined) data["EndTime"] = serialize.iso8601DateTime(params["endTime"]);
        if (params["endTimeBefore"] !== undefined) data["EndTime<"] = serialize.iso8601DateTime(params["endTimeBefore"]);
        if (params["endTimeAfter"] !== undefined) data["EndTime>"] = serialize.iso8601DateTime(params["endTimeAfter"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new CallPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new CallPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["to"] !== undefined) data["To"] = params["to"];
        if (params["from"] !== undefined) data["From"] = params["from"];
        if (params["parentCallSid"] !== undefined) data["ParentCallSid"] = params["parentCallSid"];
        if (params["status"] !== undefined) data["Status"] = params["status"];
        if (params["startTime"] !== undefined) data["StartTime"] = serialize.iso8601DateTime(params["startTime"]);
        if (params["startTimeBefore"] !== undefined) data["StartTime<"] = serialize.iso8601DateTime(params["startTimeBefore"]);
        if (params["startTimeAfter"] !== undefined) data["StartTime>"] = serialize.iso8601DateTime(params["startTimeAfter"]);
        if (params["endTime"] !== undefined) data["EndTime"] = serialize.iso8601DateTime(params["endTime"]);
        if (params["endTimeBefore"] !== undefined) data["EndTime<"] = serialize.iso8601DateTime(params["endTimeBefore"]);
        if (params["endTimeAfter"] !== undefined) data["EndTime>"] = serialize.iso8601DateTime(params["endTimeAfter"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new CallPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new CallPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class CallPage extends Page_1.default {
    /**
     * Initialize the CallPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of CallInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new CallInstance(this._version, payload, this._solution.accountSid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.CallPage = CallPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/conference/participant.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ParticipantPage = exports.ParticipantInstance = exports.ParticipantContextImpl = void 0;
exports.ParticipantListInstance = ParticipantListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
class ParticipantContextImpl {
    constructor(_version, accountSid, conferenceSid, callSid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(accountSid)) {
            throw new Error("Parameter 'accountSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(conferenceSid)) {
            throw new Error("Parameter 'conferenceSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(callSid)) {
            throw new Error("Parameter 'callSid' is not valid.");
        }
        this._solution = {
            accountSid,
            conferenceSid,
            callSid
        };
        this._uri = `/Accounts/${accountSid}/Conferences/${conferenceSid}/Participants/${callSid}.json`;
    }
    remove(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.remove({
            uri: instance._uri,
            method: "delete",
            headers
        });
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    removeWithHttpInfo(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version;
        // DELETE operation - returns boolean based on status code
        let operationPromise = operationVersion.removeWithResponseInfo({
            uri: instance._uri,
            method: "delete",
            headers
        }).then((response)=>({
                ...response,
                body: response.statusCode === 204
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new ParticipantInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.conferenceSid, instance._solution.callSid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new ParticipantInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.conferenceSid, instance._solution.callSid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    update(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["muted"] !== undefined) data["Muted"] = serialize.bool(params["muted"]);
        if (params["hold"] !== undefined) data["Hold"] = serialize.bool(params["hold"]);
        if (params["holdUrl"] !== undefined) data["HoldUrl"] = params["holdUrl"];
        if (params["holdMethod"] !== undefined) data["HoldMethod"] = params["holdMethod"];
        if (params["announceUrl"] !== undefined) data["AnnounceUrl"] = params["announceUrl"];
        if (params["announceMethod"] !== undefined) data["AnnounceMethod"] = params["announceMethod"];
        if (params["waitUrl"] !== undefined) data["WaitUrl"] = params["waitUrl"];
        if (params["waitMethod"] !== undefined) data["WaitMethod"] = params["waitMethod"];
        if (params["beepOnExit"] !== undefined) data["BeepOnExit"] = serialize.bool(params["beepOnExit"]);
        if (params["endConferenceOnExit"] !== undefined) data["EndConferenceOnExit"] = serialize.bool(params["endConferenceOnExit"]);
        if (params["coaching"] !== undefined) data["Coaching"] = serialize.bool(params["coaching"]);
        if (params["callSidToCoach"] !== undefined) data["CallSidToCoach"] = params["callSidToCoach"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.update({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new ParticipantInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.conferenceSid, instance._solution.callSid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    updateWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["muted"] !== undefined) data["Muted"] = serialize.bool(params["muted"]);
        if (params["hold"] !== undefined) data["Hold"] = serialize.bool(params["hold"]);
        if (params["holdUrl"] !== undefined) data["HoldUrl"] = params["holdUrl"];
        if (params["holdMethod"] !== undefined) data["HoldMethod"] = params["holdMethod"];
        if (params["announceUrl"] !== undefined) data["AnnounceUrl"] = params["announceUrl"];
        if (params["announceMethod"] !== undefined) data["AnnounceMethod"] = params["announceMethod"];
        if (params["waitUrl"] !== undefined) data["WaitUrl"] = params["waitUrl"];
        if (params["waitMethod"] !== undefined) data["WaitMethod"] = params["waitMethod"];
        if (params["beepOnExit"] !== undefined) data["BeepOnExit"] = serialize.bool(params["beepOnExit"]);
        if (params["endConferenceOnExit"] !== undefined) data["EndConferenceOnExit"] = serialize.bool(params["endConferenceOnExit"]);
        if (params["coaching"] !== undefined) data["Coaching"] = serialize.bool(params["coaching"]);
        if (params["callSidToCoach"] !== undefined) data["CallSidToCoach"] = params["callSidToCoach"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.updateWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new ParticipantInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.conferenceSid, instance._solution.callSid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.ParticipantContextImpl = ParticipantContextImpl;
class ParticipantInstance {
    constructor(_version, payload, accountSid, conferenceSid, callSid){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.callSid = payload.call_sid;
        this.label = payload.label;
        this.callSidToCoach = payload.call_sid_to_coach;
        this.coaching = payload.coaching;
        this.conferenceSid = payload.conference_sid;
        this.dateCreated = deserialize.rfc2822DateTime(payload.date_created);
        this.dateUpdated = deserialize.rfc2822DateTime(payload.date_updated);
        this.endConferenceOnExit = payload.end_conference_on_exit;
        this.muted = payload.muted;
        this.hold = payload.hold;
        this.startConferenceOnEnter = payload.start_conference_on_enter;
        this.status = payload.status;
        this.queueTime = payload.queue_time;
        this.uri = payload.uri;
        this._solution = {
            accountSid,
            conferenceSid,
            callSid: callSid || this.callSid
        };
    }
    get _proxy() {
        this._context = this._context || new ParticipantContextImpl(this._version, this._solution.accountSid, this._solution.conferenceSid, this._solution.callSid);
        return this._context;
    }
    /**
     * Remove a ParticipantInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean
     */ remove(callback) {
        return this._proxy.remove(callback);
    }
    /**
     * Remove a ParticipantInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean with HTTP metadata
     */ removeWithHttpInfo(callback) {
        return this._proxy.removeWithHttpInfo(callback);
    }
    /**
     * Fetch a ParticipantInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed ParticipantInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a ParticipantInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed ParticipantInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    update(params, callback) {
        return this._proxy.update(params, callback);
    }
    updateWithHttpInfo(params, callback) {
        return this._proxy.updateWithHttpInfo(params, callback);
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            callSid: this.callSid,
            label: this.label,
            callSidToCoach: this.callSidToCoach,
            coaching: this.coaching,
            conferenceSid: this.conferenceSid,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated,
            endConferenceOnExit: this.endConferenceOnExit,
            muted: this.muted,
            hold: this.hold,
            startConferenceOnEnter: this.startConferenceOnEnter,
            status: this.status,
            queueTime: this.queueTime,
            uri: this.uri
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.ParticipantInstance = ParticipantInstance;
function ParticipantListInstance(version, accountSid, conferenceSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    if (!(0, utility_1.isValidPathParam)(conferenceSid)) {
        throw new Error("Parameter 'conferenceSid' is not valid.");
    }
    const instance = (callSid)=>instance.get(callSid);
    instance.get = function get(callSid) {
        return new ParticipantContextImpl(version, accountSid, conferenceSid, callSid);
    };
    instance._version = version;
    instance._solution = {
        accountSid,
        conferenceSid
    };
    instance._uri = `/Accounts/${accountSid}/Conferences/${conferenceSid}/Participants.json`;
    instance.create = function create(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["from"] === null || params["from"] === undefined) {
            throw new Error("Required parameter \"params['from']\" missing.");
        }
        if (params["to"] === null || params["to"] === undefined) {
            throw new Error("Required parameter \"params['to']\" missing.");
        }
        let data = {};
        data["From"] = params["from"];
        data["To"] = params["to"];
        if (params["statusCallback"] !== undefined) data["StatusCallback"] = params["statusCallback"];
        if (params["statusCallbackMethod"] !== undefined) data["StatusCallbackMethod"] = params["statusCallbackMethod"];
        if (params["statusCallbackEvent"] !== undefined) data["StatusCallbackEvent"] = serialize.map(params["statusCallbackEvent"], (e)=>e);
        if (params["label"] !== undefined) data["Label"] = params["label"];
        if (params["timeout"] !== undefined) data["Timeout"] = params["timeout"];
        if (params["record"] !== undefined) data["Record"] = serialize.bool(params["record"]);
        if (params["muted"] !== undefined) data["Muted"] = serialize.bool(params["muted"]);
        if (params["beep"] !== undefined) data["Beep"] = params["beep"];
        if (params["startConferenceOnEnter"] !== undefined) data["StartConferenceOnEnter"] = serialize.bool(params["startConferenceOnEnter"]);
        if (params["endConferenceOnExit"] !== undefined) data["EndConferenceOnExit"] = serialize.bool(params["endConferenceOnExit"]);
        if (params["waitUrl"] !== undefined) data["WaitUrl"] = params["waitUrl"];
        if (params["waitMethod"] !== undefined) data["WaitMethod"] = params["waitMethod"];
        if (params["earlyMedia"] !== undefined) data["EarlyMedia"] = serialize.bool(params["earlyMedia"]);
        if (params["maxParticipants"] !== undefined) data["MaxParticipants"] = params["maxParticipants"];
        if (params["conferenceRecord"] !== undefined) data["ConferenceRecord"] = params["conferenceRecord"];
        if (params["conferenceTrim"] !== undefined) data["ConferenceTrim"] = params["conferenceTrim"];
        if (params["conferenceStatusCallback"] !== undefined) data["ConferenceStatusCallback"] = params["conferenceStatusCallback"];
        if (params["conferenceStatusCallbackMethod"] !== undefined) data["ConferenceStatusCallbackMethod"] = params["conferenceStatusCallbackMethod"];
        if (params["conferenceStatusCallbackEvent"] !== undefined) data["ConferenceStatusCallbackEvent"] = serialize.map(params["conferenceStatusCallbackEvent"], (e)=>e);
        if (params["recordingChannels"] !== undefined) data["RecordingChannels"] = params["recordingChannels"];
        if (params["recordingStatusCallback"] !== undefined) data["RecordingStatusCallback"] = params["recordingStatusCallback"];
        if (params["recordingStatusCallbackMethod"] !== undefined) data["RecordingStatusCallbackMethod"] = params["recordingStatusCallbackMethod"];
        if (params["sipAuthUsername"] !== undefined) data["SipAuthUsername"] = params["sipAuthUsername"];
        if (params["sipAuthPassword"] !== undefined) data["SipAuthPassword"] = params["sipAuthPassword"];
        if (params["region"] !== undefined) data["Region"] = params["region"];
        if (params["conferenceRecordingStatusCallback"] !== undefined) data["ConferenceRecordingStatusCallback"] = params["conferenceRecordingStatusCallback"];
        if (params["conferenceRecordingStatusCallbackMethod"] !== undefined) data["ConferenceRecordingStatusCallbackMethod"] = params["conferenceRecordingStatusCallbackMethod"];
        if (params["recordingStatusCallbackEvent"] !== undefined) data["RecordingStatusCallbackEvent"] = serialize.map(params["recordingStatusCallbackEvent"], (e)=>e);
        if (params["conferenceRecordingStatusCallbackEvent"] !== undefined) data["ConferenceRecordingStatusCallbackEvent"] = serialize.map(params["conferenceRecordingStatusCallbackEvent"], (e)=>e);
        if (params["coaching"] !== undefined) data["Coaching"] = serialize.bool(params["coaching"]);
        if (params["callSidToCoach"] !== undefined) data["CallSidToCoach"] = params["callSidToCoach"];
        if (params["jitterBufferSize"] !== undefined) data["JitterBufferSize"] = params["jitterBufferSize"];
        if (params["byoc"] !== undefined) data["Byoc"] = params["byoc"];
        if (params["callerId"] !== undefined) data["CallerId"] = params["callerId"];
        if (params["callReason"] !== undefined) data["CallReason"] = params["callReason"];
        if (params["recordingTrack"] !== undefined) data["RecordingTrack"] = params["recordingTrack"];
        if (params["timeLimit"] !== undefined) data["TimeLimit"] = params["timeLimit"];
        if (params["machineDetection"] !== undefined) data["MachineDetection"] = params["machineDetection"];
        if (params["machineDetectionTimeout"] !== undefined) data["MachineDetectionTimeout"] = params["machineDetectionTimeout"];
        if (params["machineDetectionSpeechThreshold"] !== undefined) data["MachineDetectionSpeechThreshold"] = params["machineDetectionSpeechThreshold"];
        if (params["machineDetectionSpeechEndThreshold"] !== undefined) data["MachineDetectionSpeechEndThreshold"] = params["machineDetectionSpeechEndThreshold"];
        if (params["machineDetectionSilenceTimeout"] !== undefined) data["MachineDetectionSilenceTimeout"] = params["machineDetectionSilenceTimeout"];
        if (params["amdStatusCallback"] !== undefined) data["AmdStatusCallback"] = params["amdStatusCallback"];
        if (params["amdStatusCallbackMethod"] !== undefined) data["AmdStatusCallbackMethod"] = params["amdStatusCallbackMethod"];
        if (params["trim"] !== undefined) data["Trim"] = params["trim"];
        if (params["callToken"] !== undefined) data["CallToken"] = params["callToken"];
        if (params["clientNotificationUrl"] !== undefined) data["ClientNotificationUrl"] = params["clientNotificationUrl"];
        if (params["callerDisplayName"] !== undefined) data["CallerDisplayName"] = params["callerDisplayName"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.create({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new ParticipantInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.conferenceSid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.createWithHttpInfo = function createWithHttpInfo(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["from"] === null || params["from"] === undefined) {
            throw new Error("Required parameter \"params['from']\" missing.");
        }
        if (params["to"] === null || params["to"] === undefined) {
            throw new Error("Required parameter \"params['to']\" missing.");
        }
        let data = {};
        data["From"] = params["from"];
        data["To"] = params["to"];
        if (params["statusCallback"] !== undefined) data["StatusCallback"] = params["statusCallback"];
        if (params["statusCallbackMethod"] !== undefined) data["StatusCallbackMethod"] = params["statusCallbackMethod"];
        if (params["statusCallbackEvent"] !== undefined) data["StatusCallbackEvent"] = serialize.map(params["statusCallbackEvent"], (e)=>e);
        if (params["label"] !== undefined) data["Label"] = params["label"];
        if (params["timeout"] !== undefined) data["Timeout"] = params["timeout"];
        if (params["record"] !== undefined) data["Record"] = serialize.bool(params["record"]);
        if (params["muted"] !== undefined) data["Muted"] = serialize.bool(params["muted"]);
        if (params["beep"] !== undefined) data["Beep"] = params["beep"];
        if (params["startConferenceOnEnter"] !== undefined) data["StartConferenceOnEnter"] = serialize.bool(params["startConferenceOnEnter"]);
        if (params["endConferenceOnExit"] !== undefined) data["EndConferenceOnExit"] = serialize.bool(params["endConferenceOnExit"]);
        if (params["waitUrl"] !== undefined) data["WaitUrl"] = params["waitUrl"];
        if (params["waitMethod"] !== undefined) data["WaitMethod"] = params["waitMethod"];
        if (params["earlyMedia"] !== undefined) data["EarlyMedia"] = serialize.bool(params["earlyMedia"]);
        if (params["maxParticipants"] !== undefined) data["MaxParticipants"] = params["maxParticipants"];
        if (params["conferenceRecord"] !== undefined) data["ConferenceRecord"] = params["conferenceRecord"];
        if (params["conferenceTrim"] !== undefined) data["ConferenceTrim"] = params["conferenceTrim"];
        if (params["conferenceStatusCallback"] !== undefined) data["ConferenceStatusCallback"] = params["conferenceStatusCallback"];
        if (params["conferenceStatusCallbackMethod"] !== undefined) data["ConferenceStatusCallbackMethod"] = params["conferenceStatusCallbackMethod"];
        if (params["conferenceStatusCallbackEvent"] !== undefined) data["ConferenceStatusCallbackEvent"] = serialize.map(params["conferenceStatusCallbackEvent"], (e)=>e);
        if (params["recordingChannels"] !== undefined) data["RecordingChannels"] = params["recordingChannels"];
        if (params["recordingStatusCallback"] !== undefined) data["RecordingStatusCallback"] = params["recordingStatusCallback"];
        if (params["recordingStatusCallbackMethod"] !== undefined) data["RecordingStatusCallbackMethod"] = params["recordingStatusCallbackMethod"];
        if (params["sipAuthUsername"] !== undefined) data["SipAuthUsername"] = params["sipAuthUsername"];
        if (params["sipAuthPassword"] !== undefined) data["SipAuthPassword"] = params["sipAuthPassword"];
        if (params["region"] !== undefined) data["Region"] = params["region"];
        if (params["conferenceRecordingStatusCallback"] !== undefined) data["ConferenceRecordingStatusCallback"] = params["conferenceRecordingStatusCallback"];
        if (params["conferenceRecordingStatusCallbackMethod"] !== undefined) data["ConferenceRecordingStatusCallbackMethod"] = params["conferenceRecordingStatusCallbackMethod"];
        if (params["recordingStatusCallbackEvent"] !== undefined) data["RecordingStatusCallbackEvent"] = serialize.map(params["recordingStatusCallbackEvent"], (e)=>e);
        if (params["conferenceRecordingStatusCallbackEvent"] !== undefined) data["ConferenceRecordingStatusCallbackEvent"] = serialize.map(params["conferenceRecordingStatusCallbackEvent"], (e)=>e);
        if (params["coaching"] !== undefined) data["Coaching"] = serialize.bool(params["coaching"]);
        if (params["callSidToCoach"] !== undefined) data["CallSidToCoach"] = params["callSidToCoach"];
        if (params["jitterBufferSize"] !== undefined) data["JitterBufferSize"] = params["jitterBufferSize"];
        if (params["byoc"] !== undefined) data["Byoc"] = params["byoc"];
        if (params["callerId"] !== undefined) data["CallerId"] = params["callerId"];
        if (params["callReason"] !== undefined) data["CallReason"] = params["callReason"];
        if (params["recordingTrack"] !== undefined) data["RecordingTrack"] = params["recordingTrack"];
        if (params["timeLimit"] !== undefined) data["TimeLimit"] = params["timeLimit"];
        if (params["machineDetection"] !== undefined) data["MachineDetection"] = params["machineDetection"];
        if (params["machineDetectionTimeout"] !== undefined) data["MachineDetectionTimeout"] = params["machineDetectionTimeout"];
        if (params["machineDetectionSpeechThreshold"] !== undefined) data["MachineDetectionSpeechThreshold"] = params["machineDetectionSpeechThreshold"];
        if (params["machineDetectionSpeechEndThreshold"] !== undefined) data["MachineDetectionSpeechEndThreshold"] = params["machineDetectionSpeechEndThreshold"];
        if (params["machineDetectionSilenceTimeout"] !== undefined) data["MachineDetectionSilenceTimeout"] = params["machineDetectionSilenceTimeout"];
        if (params["amdStatusCallback"] !== undefined) data["AmdStatusCallback"] = params["amdStatusCallback"];
        if (params["amdStatusCallbackMethod"] !== undefined) data["AmdStatusCallbackMethod"] = params["amdStatusCallbackMethod"];
        if (params["trim"] !== undefined) data["Trim"] = params["trim"];
        if (params["callToken"] !== undefined) data["CallToken"] = params["callToken"];
        if (params["clientNotificationUrl"] !== undefined) data["ClientNotificationUrl"] = params["clientNotificationUrl"];
        if (params["callerDisplayName"] !== undefined) data["CallerDisplayName"] = params["callerDisplayName"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.createWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new ParticipantInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.conferenceSid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["muted"] !== undefined) data["Muted"] = serialize.bool(params["muted"]);
        if (params["hold"] !== undefined) data["Hold"] = serialize.bool(params["hold"]);
        if (params["coaching"] !== undefined) data["Coaching"] = serialize.bool(params["coaching"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new ParticipantPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new ParticipantPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["muted"] !== undefined) data["Muted"] = serialize.bool(params["muted"]);
        if (params["hold"] !== undefined) data["Hold"] = serialize.bool(params["hold"]);
        if (params["coaching"] !== undefined) data["Coaching"] = serialize.bool(params["coaching"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new ParticipantPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new ParticipantPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class ParticipantPage extends Page_1.default {
    /**
     * Initialize the ParticipantPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of ParticipantInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new ParticipantInstance(this._version, payload, this._solution.accountSid, this._solution.conferenceSid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.ParticipantPage = ParticipantPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/conference/recording.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RecordingPage = exports.RecordingInstance = exports.RecordingContextImpl = void 0;
exports.RecordingListInstance = RecordingListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
class RecordingContextImpl {
    constructor(_version, accountSid, conferenceSid, sid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(accountSid)) {
            throw new Error("Parameter 'accountSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(conferenceSid)) {
            throw new Error("Parameter 'conferenceSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(sid)) {
            throw new Error("Parameter 'sid' is not valid.");
        }
        this._solution = {
            accountSid,
            conferenceSid,
            sid
        };
        this._uri = `/Accounts/${accountSid}/Conferences/${conferenceSid}/Recordings/${sid}.json`;
    }
    remove(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.remove({
            uri: instance._uri,
            method: "delete",
            headers
        });
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    removeWithHttpInfo(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version;
        // DELETE operation - returns boolean based on status code
        let operationPromise = operationVersion.removeWithResponseInfo({
            uri: instance._uri,
            method: "delete",
            headers
        }).then((response)=>({
                ...response,
                body: response.statusCode === 204
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new RecordingInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.conferenceSid, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new RecordingInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.conferenceSid, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    update(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["status"] === null || params["status"] === undefined) {
            throw new Error("Required parameter \"params['status']\" missing.");
        }
        let data = {};
        data["Status"] = params["status"];
        if (params["pauseBehavior"] !== undefined) data["PauseBehavior"] = params["pauseBehavior"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.update({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new RecordingInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.conferenceSid, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    updateWithHttpInfo(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["status"] === null || params["status"] === undefined) {
            throw new Error("Required parameter \"params['status']\" missing.");
        }
        let data = {};
        data["Status"] = params["status"];
        if (params["pauseBehavior"] !== undefined) data["PauseBehavior"] = params["pauseBehavior"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.updateWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new RecordingInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.conferenceSid, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.RecordingContextImpl = RecordingContextImpl;
class RecordingInstance {
    constructor(_version, payload, accountSid, conferenceSid, sid){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.apiVersion = payload.api_version;
        this.callSid = payload.call_sid;
        this.conferenceSid = payload.conference_sid;
        this.dateCreated = deserialize.rfc2822DateTime(payload.date_created);
        this.dateUpdated = deserialize.rfc2822DateTime(payload.date_updated);
        this.startTime = deserialize.rfc2822DateTime(payload.start_time);
        this.duration = payload.duration;
        this.sid = payload.sid;
        this.price = payload.price;
        this.priceUnit = payload.price_unit;
        this.status = payload.status;
        this.channels = deserialize.integer(payload.channels);
        this.source = payload.source;
        this.errorCode = deserialize.integer(payload.error_code);
        this.encryptionDetails = payload.encryption_details;
        this.uri = payload.uri;
        this._solution = {
            accountSid,
            conferenceSid,
            sid: sid || this.sid
        };
    }
    get _proxy() {
        this._context = this._context || new RecordingContextImpl(this._version, this._solution.accountSid, this._solution.conferenceSid, this._solution.sid);
        return this._context;
    }
    /**
     * Remove a RecordingInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean
     */ remove(callback) {
        return this._proxy.remove(callback);
    }
    /**
     * Remove a RecordingInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean with HTTP metadata
     */ removeWithHttpInfo(callback) {
        return this._proxy.removeWithHttpInfo(callback);
    }
    /**
     * Fetch a RecordingInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed RecordingInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a RecordingInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed RecordingInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    update(params, callback) {
        return this._proxy.update(params, callback);
    }
    updateWithHttpInfo(params, callback) {
        return this._proxy.updateWithHttpInfo(params, callback);
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            apiVersion: this.apiVersion,
            callSid: this.callSid,
            conferenceSid: this.conferenceSid,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated,
            startTime: this.startTime,
            duration: this.duration,
            sid: this.sid,
            price: this.price,
            priceUnit: this.priceUnit,
            status: this.status,
            channels: this.channels,
            source: this.source,
            errorCode: this.errorCode,
            encryptionDetails: this.encryptionDetails,
            uri: this.uri
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.RecordingInstance = RecordingInstance;
function RecordingListInstance(version, accountSid, conferenceSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    if (!(0, utility_1.isValidPathParam)(conferenceSid)) {
        throw new Error("Parameter 'conferenceSid' is not valid.");
    }
    const instance = (sid)=>instance.get(sid);
    instance.get = function get(sid) {
        return new RecordingContextImpl(version, accountSid, conferenceSid, sid);
    };
    instance._version = version;
    instance._solution = {
        accountSid,
        conferenceSid
    };
    instance._uri = `/Accounts/${accountSid}/Conferences/${conferenceSid}/Recordings.json`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["dateCreated"] !== undefined) data["DateCreated"] = serialize.iso8601Date(params["dateCreated"]);
        if (params["dateCreatedBefore"] !== undefined) data["DateCreated<"] = serialize.iso8601Date(params["dateCreatedBefore"]);
        if (params["dateCreatedAfter"] !== undefined) data["DateCreated>"] = serialize.iso8601Date(params["dateCreatedAfter"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new RecordingPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new RecordingPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["dateCreated"] !== undefined) data["DateCreated"] = serialize.iso8601Date(params["dateCreated"]);
        if (params["dateCreatedBefore"] !== undefined) data["DateCreated<"] = serialize.iso8601Date(params["dateCreatedBefore"]);
        if (params["dateCreatedAfter"] !== undefined) data["DateCreated>"] = serialize.iso8601Date(params["dateCreatedAfter"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new RecordingPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new RecordingPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class RecordingPage extends Page_1.default {
    /**
     * Initialize the RecordingPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of RecordingInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new RecordingInstance(this._version, payload, this._solution.accountSid, this._solution.conferenceSid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.RecordingPage = RecordingPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/conference.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConferencePage = exports.ConferenceInstance = exports.ConferenceContextImpl = void 0;
exports.ConferenceListInstance = ConferenceListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
const participant_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/conference/participant.js [app-route] (ecmascript)");
const recording_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/conference/recording.js [app-route] (ecmascript)");
class ConferenceContextImpl {
    constructor(_version, accountSid, sid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(accountSid)) {
            throw new Error("Parameter 'accountSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(sid)) {
            throw new Error("Parameter 'sid' is not valid.");
        }
        this._solution = {
            accountSid,
            sid
        };
        this._uri = `/Accounts/${accountSid}/Conferences/${sid}.json`;
    }
    get participants() {
        this._participants = this._participants || (0, participant_1.ParticipantListInstance)(this._version, this._solution.accountSid, this._solution.sid);
        return this._participants;
    }
    get recordings() {
        this._recordings = this._recordings || (0, recording_1.RecordingListInstance)(this._version, this._solution.accountSid, this._solution.sid);
        return this._recordings;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new ConferenceInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new ConferenceInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    update(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["status"] !== undefined) data["Status"] = params["status"];
        if (params["announceUrl"] !== undefined) data["AnnounceUrl"] = params["announceUrl"];
        if (params["announceMethod"] !== undefined) data["AnnounceMethod"] = params["announceMethod"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.update({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new ConferenceInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    updateWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["status"] !== undefined) data["Status"] = params["status"];
        if (params["announceUrl"] !== undefined) data["AnnounceUrl"] = params["announceUrl"];
        if (params["announceMethod"] !== undefined) data["AnnounceMethod"] = params["announceMethod"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.updateWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new ConferenceInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.ConferenceContextImpl = ConferenceContextImpl;
class ConferenceInstance {
    constructor(_version, payload, accountSid, sid){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.dateCreated = deserialize.rfc2822DateTime(payload.date_created);
        this.dateUpdated = deserialize.rfc2822DateTime(payload.date_updated);
        this.apiVersion = payload.api_version;
        this.friendlyName = payload.friendly_name;
        this.region = payload.region;
        this.sid = payload.sid;
        this.status = payload.status;
        this.uri = payload.uri;
        this.subresourceUris = payload.subresource_uris;
        this.reasonConferenceEnded = payload.reason_conference_ended;
        this.callSidEndingConference = payload.call_sid_ending_conference;
        this._solution = {
            accountSid,
            sid: sid || this.sid
        };
    }
    get _proxy() {
        this._context = this._context || new ConferenceContextImpl(this._version, this._solution.accountSid, this._solution.sid);
        return this._context;
    }
    /**
     * Fetch a ConferenceInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed ConferenceInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a ConferenceInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed ConferenceInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    update(params, callback) {
        return this._proxy.update(params, callback);
    }
    updateWithHttpInfo(params, callback) {
        return this._proxy.updateWithHttpInfo(params, callback);
    }
    /**
     * Access the participants.
     */ participants() {
        return this._proxy.participants;
    }
    /**
     * Access the recordings.
     */ recordings() {
        return this._proxy.recordings;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated,
            apiVersion: this.apiVersion,
            friendlyName: this.friendlyName,
            region: this.region,
            sid: this.sid,
            status: this.status,
            uri: this.uri,
            subresourceUris: this.subresourceUris,
            reasonConferenceEnded: this.reasonConferenceEnded,
            callSidEndingConference: this.callSidEndingConference
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.ConferenceInstance = ConferenceInstance;
function ConferenceListInstance(version, accountSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    const instance = (sid)=>instance.get(sid);
    instance.get = function get(sid) {
        return new ConferenceContextImpl(version, accountSid, sid);
    };
    instance._version = version;
    instance._solution = {
        accountSid
    };
    instance._uri = `/Accounts/${accountSid}/Conferences.json`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["dateCreated"] !== undefined) data["DateCreated"] = serialize.iso8601Date(params["dateCreated"]);
        if (params["dateCreatedBefore"] !== undefined) data["DateCreated<"] = serialize.iso8601Date(params["dateCreatedBefore"]);
        if (params["dateCreatedAfter"] !== undefined) data["DateCreated>"] = serialize.iso8601Date(params["dateCreatedAfter"]);
        if (params["dateUpdated"] !== undefined) data["DateUpdated"] = serialize.iso8601Date(params["dateUpdated"]);
        if (params["dateUpdatedBefore"] !== undefined) data["DateUpdated<"] = serialize.iso8601Date(params["dateUpdatedBefore"]);
        if (params["dateUpdatedAfter"] !== undefined) data["DateUpdated>"] = serialize.iso8601Date(params["dateUpdatedAfter"]);
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["status"] !== undefined) data["Status"] = params["status"];
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new ConferencePage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new ConferencePage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["dateCreated"] !== undefined) data["DateCreated"] = serialize.iso8601Date(params["dateCreated"]);
        if (params["dateCreatedBefore"] !== undefined) data["DateCreated<"] = serialize.iso8601Date(params["dateCreatedBefore"]);
        if (params["dateCreatedAfter"] !== undefined) data["DateCreated>"] = serialize.iso8601Date(params["dateCreatedAfter"]);
        if (params["dateUpdated"] !== undefined) data["DateUpdated"] = serialize.iso8601Date(params["dateUpdated"]);
        if (params["dateUpdatedBefore"] !== undefined) data["DateUpdated<"] = serialize.iso8601Date(params["dateUpdatedBefore"]);
        if (params["dateUpdatedAfter"] !== undefined) data["DateUpdated>"] = serialize.iso8601Date(params["dateUpdatedAfter"]);
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["status"] !== undefined) data["Status"] = params["status"];
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new ConferencePage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new ConferencePage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class ConferencePage extends Page_1.default {
    /**
     * Initialize the ConferencePage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of ConferenceInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new ConferenceInstance(this._version, payload, this._solution.accountSid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.ConferencePage = ConferencePage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/connectApp.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ConnectAppPage = exports.ConnectAppInstance = exports.ConnectAppContextImpl = void 0;
exports.ConnectAppListInstance = ConnectAppListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
class ConnectAppContextImpl {
    constructor(_version, accountSid, sid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(accountSid)) {
            throw new Error("Parameter 'accountSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(sid)) {
            throw new Error("Parameter 'sid' is not valid.");
        }
        this._solution = {
            accountSid,
            sid
        };
        this._uri = `/Accounts/${accountSid}/ConnectApps/${sid}.json`;
    }
    remove(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.remove({
            uri: instance._uri,
            method: "delete",
            headers
        });
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    removeWithHttpInfo(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version;
        // DELETE operation - returns boolean based on status code
        let operationPromise = operationVersion.removeWithResponseInfo({
            uri: instance._uri,
            method: "delete",
            headers
        }).then((response)=>({
                ...response,
                body: response.statusCode === 204
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new ConnectAppInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new ConnectAppInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    update(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["authorizeRedirectUrl"] !== undefined) data["AuthorizeRedirectUrl"] = params["authorizeRedirectUrl"];
        if (params["companyName"] !== undefined) data["CompanyName"] = params["companyName"];
        if (params["deauthorizeCallbackMethod"] !== undefined) data["DeauthorizeCallbackMethod"] = params["deauthorizeCallbackMethod"];
        if (params["deauthorizeCallbackUrl"] !== undefined) data["DeauthorizeCallbackUrl"] = params["deauthorizeCallbackUrl"];
        if (params["description"] !== undefined) data["Description"] = params["description"];
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["homepageUrl"] !== undefined) data["HomepageUrl"] = params["homepageUrl"];
        if (params["permissions"] !== undefined) data["Permissions"] = serialize.map(params["permissions"], (e)=>e);
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.update({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new ConnectAppInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    updateWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["authorizeRedirectUrl"] !== undefined) data["AuthorizeRedirectUrl"] = params["authorizeRedirectUrl"];
        if (params["companyName"] !== undefined) data["CompanyName"] = params["companyName"];
        if (params["deauthorizeCallbackMethod"] !== undefined) data["DeauthorizeCallbackMethod"] = params["deauthorizeCallbackMethod"];
        if (params["deauthorizeCallbackUrl"] !== undefined) data["DeauthorizeCallbackUrl"] = params["deauthorizeCallbackUrl"];
        if (params["description"] !== undefined) data["Description"] = params["description"];
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["homepageUrl"] !== undefined) data["HomepageUrl"] = params["homepageUrl"];
        if (params["permissions"] !== undefined) data["Permissions"] = serialize.map(params["permissions"], (e)=>e);
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.updateWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new ConnectAppInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.ConnectAppContextImpl = ConnectAppContextImpl;
class ConnectAppInstance {
    constructor(_version, payload, accountSid, sid){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.authorizeRedirectUrl = payload.authorize_redirect_url;
        this.companyName = payload.company_name;
        this.deauthorizeCallbackMethod = payload.deauthorize_callback_method;
        this.deauthorizeCallbackUrl = payload.deauthorize_callback_url;
        this.description = payload.description;
        this.friendlyName = payload.friendly_name;
        this.homepageUrl = payload.homepage_url;
        this.permissions = payload.permissions;
        this.sid = payload.sid;
        this.uri = payload.uri;
        this._solution = {
            accountSid,
            sid: sid || this.sid
        };
    }
    get _proxy() {
        this._context = this._context || new ConnectAppContextImpl(this._version, this._solution.accountSid, this._solution.sid);
        return this._context;
    }
    /**
     * Remove a ConnectAppInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean
     */ remove(callback) {
        return this._proxy.remove(callback);
    }
    /**
     * Remove a ConnectAppInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean with HTTP metadata
     */ removeWithHttpInfo(callback) {
        return this._proxy.removeWithHttpInfo(callback);
    }
    /**
     * Fetch a ConnectAppInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed ConnectAppInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a ConnectAppInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed ConnectAppInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    update(params, callback) {
        return this._proxy.update(params, callback);
    }
    updateWithHttpInfo(params, callback) {
        return this._proxy.updateWithHttpInfo(params, callback);
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            authorizeRedirectUrl: this.authorizeRedirectUrl,
            companyName: this.companyName,
            deauthorizeCallbackMethod: this.deauthorizeCallbackMethod,
            deauthorizeCallbackUrl: this.deauthorizeCallbackUrl,
            description: this.description,
            friendlyName: this.friendlyName,
            homepageUrl: this.homepageUrl,
            permissions: this.permissions,
            sid: this.sid,
            uri: this.uri
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.ConnectAppInstance = ConnectAppInstance;
function ConnectAppListInstance(version, accountSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    const instance = (sid)=>instance.get(sid);
    instance.get = function get(sid) {
        return new ConnectAppContextImpl(version, accountSid, sid);
    };
    instance._version = version;
    instance._solution = {
        accountSid
    };
    instance._uri = `/Accounts/${accountSid}/ConnectApps.json`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new ConnectAppPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new ConnectAppPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new ConnectAppPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new ConnectAppPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class ConnectAppPage extends Page_1.default {
    /**
     * Initialize the ConnectAppPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of ConnectAppInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new ConnectAppInstance(this._version, payload, this._solution.accountSid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.ConnectAppPage = ConnectAppPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/incomingPhoneNumber/assignedAddOn/assignedAddOnExtension.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AssignedAddOnExtensionPage = exports.AssignedAddOnExtensionInstance = exports.AssignedAddOnExtensionContextImpl = void 0;
exports.AssignedAddOnExtensionListInstance = AssignedAddOnExtensionListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
class AssignedAddOnExtensionContextImpl {
    constructor(_version, accountSid, resourceSid, assignedAddOnSid, sid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(accountSid)) {
            throw new Error("Parameter 'accountSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(resourceSid)) {
            throw new Error("Parameter 'resourceSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(assignedAddOnSid)) {
            throw new Error("Parameter 'assignedAddOnSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(sid)) {
            throw new Error("Parameter 'sid' is not valid.");
        }
        this._solution = {
            accountSid,
            resourceSid,
            assignedAddOnSid,
            sid
        };
        this._uri = `/Accounts/${accountSid}/IncomingPhoneNumbers/${resourceSid}/AssignedAddOns/${assignedAddOnSid}/Extensions/${sid}.json`;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new AssignedAddOnExtensionInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.resourceSid, instance._solution.assignedAddOnSid, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new AssignedAddOnExtensionInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.resourceSid, instance._solution.assignedAddOnSid, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.AssignedAddOnExtensionContextImpl = AssignedAddOnExtensionContextImpl;
class AssignedAddOnExtensionInstance {
    constructor(_version, payload, accountSid, resourceSid, assignedAddOnSid, sid){
        this._version = _version;
        this.sid = payload.sid;
        this.accountSid = payload.account_sid;
        this.resourceSid = payload.resource_sid;
        this.assignedAddOnSid = payload.assigned_add_on_sid;
        this.friendlyName = payload.friendly_name;
        this.productName = payload.product_name;
        this.uniqueName = payload.unique_name;
        this.uri = payload.uri;
        this.enabled = payload.enabled;
        this._solution = {
            accountSid,
            resourceSid,
            assignedAddOnSid,
            sid: sid || this.sid
        };
    }
    get _proxy() {
        this._context = this._context || new AssignedAddOnExtensionContextImpl(this._version, this._solution.accountSid, this._solution.resourceSid, this._solution.assignedAddOnSid, this._solution.sid);
        return this._context;
    }
    /**
     * Fetch a AssignedAddOnExtensionInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed AssignedAddOnExtensionInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a AssignedAddOnExtensionInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed AssignedAddOnExtensionInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            sid: this.sid,
            accountSid: this.accountSid,
            resourceSid: this.resourceSid,
            assignedAddOnSid: this.assignedAddOnSid,
            friendlyName: this.friendlyName,
            productName: this.productName,
            uniqueName: this.uniqueName,
            uri: this.uri,
            enabled: this.enabled
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.AssignedAddOnExtensionInstance = AssignedAddOnExtensionInstance;
function AssignedAddOnExtensionListInstance(version, accountSid, resourceSid, assignedAddOnSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    if (!(0, utility_1.isValidPathParam)(resourceSid)) {
        throw new Error("Parameter 'resourceSid' is not valid.");
    }
    if (!(0, utility_1.isValidPathParam)(assignedAddOnSid)) {
        throw new Error("Parameter 'assignedAddOnSid' is not valid.");
    }
    const instance = (sid)=>instance.get(sid);
    instance.get = function get(sid) {
        return new AssignedAddOnExtensionContextImpl(version, accountSid, resourceSid, assignedAddOnSid, sid);
    };
    instance._version = version;
    instance._solution = {
        accountSid,
        resourceSid,
        assignedAddOnSid
    };
    instance._uri = `/Accounts/${accountSid}/IncomingPhoneNumbers/${resourceSid}/AssignedAddOns/${assignedAddOnSid}/Extensions.json`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new AssignedAddOnExtensionPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new AssignedAddOnExtensionPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new AssignedAddOnExtensionPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new AssignedAddOnExtensionPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class AssignedAddOnExtensionPage extends Page_1.default {
    /**
     * Initialize the AssignedAddOnExtensionPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of AssignedAddOnExtensionInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new AssignedAddOnExtensionInstance(this._version, payload, this._solution.accountSid, this._solution.resourceSid, this._solution.assignedAddOnSid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.AssignedAddOnExtensionPage = AssignedAddOnExtensionPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/incomingPhoneNumber/assignedAddOn.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AssignedAddOnPage = exports.AssignedAddOnInstance = exports.AssignedAddOnContextImpl = void 0;
exports.AssignedAddOnListInstance = AssignedAddOnListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
const assignedAddOnExtension_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/incomingPhoneNumber/assignedAddOn/assignedAddOnExtension.js [app-route] (ecmascript)");
class AssignedAddOnContextImpl {
    constructor(_version, accountSid, resourceSid, sid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(accountSid)) {
            throw new Error("Parameter 'accountSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(resourceSid)) {
            throw new Error("Parameter 'resourceSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(sid)) {
            throw new Error("Parameter 'sid' is not valid.");
        }
        this._solution = {
            accountSid,
            resourceSid,
            sid
        };
        this._uri = `/Accounts/${accountSid}/IncomingPhoneNumbers/${resourceSid}/AssignedAddOns/${sid}.json`;
    }
    get extensions() {
        this._extensions = this._extensions || (0, assignedAddOnExtension_1.AssignedAddOnExtensionListInstance)(this._version, this._solution.accountSid, this._solution.resourceSid, this._solution.sid);
        return this._extensions;
    }
    remove(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.remove({
            uri: instance._uri,
            method: "delete",
            headers
        });
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    removeWithHttpInfo(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version;
        // DELETE operation - returns boolean based on status code
        let operationPromise = operationVersion.removeWithResponseInfo({
            uri: instance._uri,
            method: "delete",
            headers
        }).then((response)=>({
                ...response,
                body: response.statusCode === 204
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new AssignedAddOnInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.resourceSid, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new AssignedAddOnInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.resourceSid, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.AssignedAddOnContextImpl = AssignedAddOnContextImpl;
class AssignedAddOnInstance {
    constructor(_version, payload, accountSid, resourceSid, sid){
        this._version = _version;
        this.sid = payload.sid;
        this.accountSid = payload.account_sid;
        this.resourceSid = payload.resource_sid;
        this.friendlyName = payload.friendly_name;
        this.description = payload.description;
        this.configuration = payload.configuration;
        this.uniqueName = payload.unique_name;
        this.dateCreated = deserialize.rfc2822DateTime(payload.date_created);
        this.dateUpdated = deserialize.rfc2822DateTime(payload.date_updated);
        this.uri = payload.uri;
        this.subresourceUris = payload.subresource_uris;
        this._solution = {
            accountSid,
            resourceSid,
            sid: sid || this.sid
        };
    }
    get _proxy() {
        this._context = this._context || new AssignedAddOnContextImpl(this._version, this._solution.accountSid, this._solution.resourceSid, this._solution.sid);
        return this._context;
    }
    /**
     * Remove a AssignedAddOnInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean
     */ remove(callback) {
        return this._proxy.remove(callback);
    }
    /**
     * Remove a AssignedAddOnInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean with HTTP metadata
     */ removeWithHttpInfo(callback) {
        return this._proxy.removeWithHttpInfo(callback);
    }
    /**
     * Fetch a AssignedAddOnInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed AssignedAddOnInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a AssignedAddOnInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed AssignedAddOnInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    /**
     * Access the extensions.
     */ extensions() {
        return this._proxy.extensions;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            sid: this.sid,
            accountSid: this.accountSid,
            resourceSid: this.resourceSid,
            friendlyName: this.friendlyName,
            description: this.description,
            configuration: this.configuration,
            uniqueName: this.uniqueName,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated,
            uri: this.uri,
            subresourceUris: this.subresourceUris
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.AssignedAddOnInstance = AssignedAddOnInstance;
function AssignedAddOnListInstance(version, accountSid, resourceSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    if (!(0, utility_1.isValidPathParam)(resourceSid)) {
        throw new Error("Parameter 'resourceSid' is not valid.");
    }
    const instance = (sid)=>instance.get(sid);
    instance.get = function get(sid) {
        return new AssignedAddOnContextImpl(version, accountSid, resourceSid, sid);
    };
    instance._version = version;
    instance._solution = {
        accountSid,
        resourceSid
    };
    instance._uri = `/Accounts/${accountSid}/IncomingPhoneNumbers/${resourceSid}/AssignedAddOns.json`;
    instance.create = function create(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["installedAddOnSid"] === null || params["installedAddOnSid"] === undefined) {
            throw new Error("Required parameter \"params['installedAddOnSid']\" missing.");
        }
        let data = {};
        data["InstalledAddOnSid"] = params["installedAddOnSid"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.create({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new AssignedAddOnInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.resourceSid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.createWithHttpInfo = function createWithHttpInfo(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["installedAddOnSid"] === null || params["installedAddOnSid"] === undefined) {
            throw new Error("Required parameter \"params['installedAddOnSid']\" missing.");
        }
        let data = {};
        data["InstalledAddOnSid"] = params["installedAddOnSid"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.createWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new AssignedAddOnInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.resourceSid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new AssignedAddOnPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new AssignedAddOnPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new AssignedAddOnPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new AssignedAddOnPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class AssignedAddOnPage extends Page_1.default {
    /**
     * Initialize the AssignedAddOnPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of AssignedAddOnInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new AssignedAddOnInstance(this._version, payload, this._solution.accountSid, this._solution.resourceSid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.AssignedAddOnPage = AssignedAddOnPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/incomingPhoneNumber/local.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LocalPage = exports.LocalInstance = void 0;
exports.LocalListInstance = LocalListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
function LocalListInstance(version, accountSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    const instance = {};
    instance._version = version;
    instance._solution = {
        accountSid
    };
    instance._uri = `/Accounts/${accountSid}/IncomingPhoneNumbers/Local.json`;
    instance.create = function create(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["phoneNumber"] === null || params["phoneNumber"] === undefined) {
            throw new Error("Required parameter \"params['phoneNumber']\" missing.");
        }
        let data = {};
        data["PhoneNumber"] = params["phoneNumber"];
        if (params["apiVersion"] !== undefined) data["ApiVersion"] = params["apiVersion"];
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["smsApplicationSid"] !== undefined) data["SmsApplicationSid"] = params["smsApplicationSid"];
        if (params["smsFallbackMethod"] !== undefined) data["SmsFallbackMethod"] = params["smsFallbackMethod"];
        if (params["smsFallbackUrl"] !== undefined) data["SmsFallbackUrl"] = params["smsFallbackUrl"];
        if (params["smsMethod"] !== undefined) data["SmsMethod"] = params["smsMethod"];
        if (params["smsUrl"] !== undefined) data["SmsUrl"] = params["smsUrl"];
        if (params["statusCallback"] !== undefined) data["StatusCallback"] = params["statusCallback"];
        if (params["statusCallbackMethod"] !== undefined) data["StatusCallbackMethod"] = params["statusCallbackMethod"];
        if (params["voiceApplicationSid"] !== undefined) data["VoiceApplicationSid"] = params["voiceApplicationSid"];
        if (params["voiceCallerIdLookup"] !== undefined) data["VoiceCallerIdLookup"] = serialize.bool(params["voiceCallerIdLookup"]);
        if (params["voiceFallbackMethod"] !== undefined) data["VoiceFallbackMethod"] = params["voiceFallbackMethod"];
        if (params["voiceFallbackUrl"] !== undefined) data["VoiceFallbackUrl"] = params["voiceFallbackUrl"];
        if (params["voiceMethod"] !== undefined) data["VoiceMethod"] = params["voiceMethod"];
        if (params["voiceUrl"] !== undefined) data["VoiceUrl"] = params["voiceUrl"];
        if (params["identitySid"] !== undefined) data["IdentitySid"] = params["identitySid"];
        if (params["addressSid"] !== undefined) data["AddressSid"] = params["addressSid"];
        if (params["emergencyStatus"] !== undefined) data["EmergencyStatus"] = params["emergencyStatus"];
        if (params["emergencyAddressSid"] !== undefined) data["EmergencyAddressSid"] = params["emergencyAddressSid"];
        if (params["trunkSid"] !== undefined) data["TrunkSid"] = params["trunkSid"];
        if (params["voiceReceiveMode"] !== undefined) data["VoiceReceiveMode"] = params["voiceReceiveMode"];
        if (params["bundleSid"] !== undefined) data["BundleSid"] = params["bundleSid"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.create({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new LocalInstance(operationVersion, payload, instance._solution.accountSid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.createWithHttpInfo = function createWithHttpInfo(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["phoneNumber"] === null || params["phoneNumber"] === undefined) {
            throw new Error("Required parameter \"params['phoneNumber']\" missing.");
        }
        let data = {};
        data["PhoneNumber"] = params["phoneNumber"];
        if (params["apiVersion"] !== undefined) data["ApiVersion"] = params["apiVersion"];
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["smsApplicationSid"] !== undefined) data["SmsApplicationSid"] = params["smsApplicationSid"];
        if (params["smsFallbackMethod"] !== undefined) data["SmsFallbackMethod"] = params["smsFallbackMethod"];
        if (params["smsFallbackUrl"] !== undefined) data["SmsFallbackUrl"] = params["smsFallbackUrl"];
        if (params["smsMethod"] !== undefined) data["SmsMethod"] = params["smsMethod"];
        if (params["smsUrl"] !== undefined) data["SmsUrl"] = params["smsUrl"];
        if (params["statusCallback"] !== undefined) data["StatusCallback"] = params["statusCallback"];
        if (params["statusCallbackMethod"] !== undefined) data["StatusCallbackMethod"] = params["statusCallbackMethod"];
        if (params["voiceApplicationSid"] !== undefined) data["VoiceApplicationSid"] = params["voiceApplicationSid"];
        if (params["voiceCallerIdLookup"] !== undefined) data["VoiceCallerIdLookup"] = serialize.bool(params["voiceCallerIdLookup"]);
        if (params["voiceFallbackMethod"] !== undefined) data["VoiceFallbackMethod"] = params["voiceFallbackMethod"];
        if (params["voiceFallbackUrl"] !== undefined) data["VoiceFallbackUrl"] = params["voiceFallbackUrl"];
        if (params["voiceMethod"] !== undefined) data["VoiceMethod"] = params["voiceMethod"];
        if (params["voiceUrl"] !== undefined) data["VoiceUrl"] = params["voiceUrl"];
        if (params["identitySid"] !== undefined) data["IdentitySid"] = params["identitySid"];
        if (params["addressSid"] !== undefined) data["AddressSid"] = params["addressSid"];
        if (params["emergencyStatus"] !== undefined) data["EmergencyStatus"] = params["emergencyStatus"];
        if (params["emergencyAddressSid"] !== undefined) data["EmergencyAddressSid"] = params["emergencyAddressSid"];
        if (params["trunkSid"] !== undefined) data["TrunkSid"] = params["trunkSid"];
        if (params["voiceReceiveMode"] !== undefined) data["VoiceReceiveMode"] = params["voiceReceiveMode"];
        if (params["bundleSid"] !== undefined) data["BundleSid"] = params["bundleSid"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.createWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new LocalInstance(operationVersion, response.body, instance._solution.accountSid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["beta"] !== undefined) data["Beta"] = serialize.bool(params["beta"]);
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["phoneNumber"] !== undefined) data["PhoneNumber"] = params["phoneNumber"];
        if (params["origin"] !== undefined) data["Origin"] = params["origin"];
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new LocalPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new LocalPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["beta"] !== undefined) data["Beta"] = serialize.bool(params["beta"]);
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["phoneNumber"] !== undefined) data["PhoneNumber"] = params["phoneNumber"];
        if (params["origin"] !== undefined) data["Origin"] = params["origin"];
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new LocalPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new LocalPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class LocalInstance {
    constructor(_version, payload, accountSid){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.addressSid = payload.address_sid;
        this.addressRequirements = payload.address_requirements;
        this.apiVersion = payload.api_version;
        this.beta = payload.beta;
        this.capabilities = payload.capabilities;
        this.dateCreated = deserialize.rfc2822DateTime(payload.date_created);
        this.dateUpdated = deserialize.rfc2822DateTime(payload.date_updated);
        this.friendlyName = payload.friendly_name;
        this.identitySid = payload.identity_sid;
        this.phoneNumber = payload.phone_number;
        this.origin = payload.origin;
        this.sid = payload.sid;
        this.smsApplicationSid = payload.sms_application_sid;
        this.smsFallbackMethod = payload.sms_fallback_method;
        this.smsFallbackUrl = payload.sms_fallback_url;
        this.smsMethod = payload.sms_method;
        this.smsUrl = payload.sms_url;
        this.statusCallback = payload.status_callback;
        this.statusCallbackMethod = payload.status_callback_method;
        this.trunkSid = payload.trunk_sid;
        this.uri = payload.uri;
        this.voiceReceiveMode = payload.voice_receive_mode;
        this.voiceApplicationSid = payload.voice_application_sid;
        this.voiceCallerIdLookup = payload.voice_caller_id_lookup;
        this.voiceFallbackMethod = payload.voice_fallback_method;
        this.voiceFallbackUrl = payload.voice_fallback_url;
        this.voiceMethod = payload.voice_method;
        this.voiceUrl = payload.voice_url;
        this.emergencyStatus = payload.emergency_status;
        this.emergencyAddressSid = payload.emergency_address_sid;
        this.emergencyAddressStatus = payload.emergency_address_status;
        this.bundleSid = payload.bundle_sid;
        this.status = payload.status;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            addressSid: this.addressSid,
            addressRequirements: this.addressRequirements,
            apiVersion: this.apiVersion,
            beta: this.beta,
            capabilities: this.capabilities,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated,
            friendlyName: this.friendlyName,
            identitySid: this.identitySid,
            phoneNumber: this.phoneNumber,
            origin: this.origin,
            sid: this.sid,
            smsApplicationSid: this.smsApplicationSid,
            smsFallbackMethod: this.smsFallbackMethod,
            smsFallbackUrl: this.smsFallbackUrl,
            smsMethod: this.smsMethod,
            smsUrl: this.smsUrl,
            statusCallback: this.statusCallback,
            statusCallbackMethod: this.statusCallbackMethod,
            trunkSid: this.trunkSid,
            uri: this.uri,
            voiceReceiveMode: this.voiceReceiveMode,
            voiceApplicationSid: this.voiceApplicationSid,
            voiceCallerIdLookup: this.voiceCallerIdLookup,
            voiceFallbackMethod: this.voiceFallbackMethod,
            voiceFallbackUrl: this.voiceFallbackUrl,
            voiceMethod: this.voiceMethod,
            voiceUrl: this.voiceUrl,
            emergencyStatus: this.emergencyStatus,
            emergencyAddressSid: this.emergencyAddressSid,
            emergencyAddressStatus: this.emergencyAddressStatus,
            bundleSid: this.bundleSid,
            status: this.status
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.LocalInstance = LocalInstance;
class LocalPage extends Page_1.default {
    /**
     * Initialize the LocalPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of LocalInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new LocalInstance(this._version, payload, this._solution.accountSid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.LocalPage = LocalPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/incomingPhoneNumber/mobile.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MobilePage = exports.MobileInstance = void 0;
exports.MobileListInstance = MobileListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
function MobileListInstance(version, accountSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    const instance = {};
    instance._version = version;
    instance._solution = {
        accountSid
    };
    instance._uri = `/Accounts/${accountSid}/IncomingPhoneNumbers/Mobile.json`;
    instance.create = function create(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["phoneNumber"] === null || params["phoneNumber"] === undefined) {
            throw new Error("Required parameter \"params['phoneNumber']\" missing.");
        }
        let data = {};
        data["PhoneNumber"] = params["phoneNumber"];
        if (params["apiVersion"] !== undefined) data["ApiVersion"] = params["apiVersion"];
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["smsApplicationSid"] !== undefined) data["SmsApplicationSid"] = params["smsApplicationSid"];
        if (params["smsFallbackMethod"] !== undefined) data["SmsFallbackMethod"] = params["smsFallbackMethod"];
        if (params["smsFallbackUrl"] !== undefined) data["SmsFallbackUrl"] = params["smsFallbackUrl"];
        if (params["smsMethod"] !== undefined) data["SmsMethod"] = params["smsMethod"];
        if (params["smsUrl"] !== undefined) data["SmsUrl"] = params["smsUrl"];
        if (params["statusCallback"] !== undefined) data["StatusCallback"] = params["statusCallback"];
        if (params["statusCallbackMethod"] !== undefined) data["StatusCallbackMethod"] = params["statusCallbackMethod"];
        if (params["voiceApplicationSid"] !== undefined) data["VoiceApplicationSid"] = params["voiceApplicationSid"];
        if (params["voiceCallerIdLookup"] !== undefined) data["VoiceCallerIdLookup"] = serialize.bool(params["voiceCallerIdLookup"]);
        if (params["voiceFallbackMethod"] !== undefined) data["VoiceFallbackMethod"] = params["voiceFallbackMethod"];
        if (params["voiceFallbackUrl"] !== undefined) data["VoiceFallbackUrl"] = params["voiceFallbackUrl"];
        if (params["voiceMethod"] !== undefined) data["VoiceMethod"] = params["voiceMethod"];
        if (params["voiceUrl"] !== undefined) data["VoiceUrl"] = params["voiceUrl"];
        if (params["identitySid"] !== undefined) data["IdentitySid"] = params["identitySid"];
        if (params["addressSid"] !== undefined) data["AddressSid"] = params["addressSid"];
        if (params["emergencyStatus"] !== undefined) data["EmergencyStatus"] = params["emergencyStatus"];
        if (params["emergencyAddressSid"] !== undefined) data["EmergencyAddressSid"] = params["emergencyAddressSid"];
        if (params["trunkSid"] !== undefined) data["TrunkSid"] = params["trunkSid"];
        if (params["voiceReceiveMode"] !== undefined) data["VoiceReceiveMode"] = params["voiceReceiveMode"];
        if (params["bundleSid"] !== undefined) data["BundleSid"] = params["bundleSid"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.create({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new MobileInstance(operationVersion, payload, instance._solution.accountSid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.createWithHttpInfo = function createWithHttpInfo(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["phoneNumber"] === null || params["phoneNumber"] === undefined) {
            throw new Error("Required parameter \"params['phoneNumber']\" missing.");
        }
        let data = {};
        data["PhoneNumber"] = params["phoneNumber"];
        if (params["apiVersion"] !== undefined) data["ApiVersion"] = params["apiVersion"];
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["smsApplicationSid"] !== undefined) data["SmsApplicationSid"] = params["smsApplicationSid"];
        if (params["smsFallbackMethod"] !== undefined) data["SmsFallbackMethod"] = params["smsFallbackMethod"];
        if (params["smsFallbackUrl"] !== undefined) data["SmsFallbackUrl"] = params["smsFallbackUrl"];
        if (params["smsMethod"] !== undefined) data["SmsMethod"] = params["smsMethod"];
        if (params["smsUrl"] !== undefined) data["SmsUrl"] = params["smsUrl"];
        if (params["statusCallback"] !== undefined) data["StatusCallback"] = params["statusCallback"];
        if (params["statusCallbackMethod"] !== undefined) data["StatusCallbackMethod"] = params["statusCallbackMethod"];
        if (params["voiceApplicationSid"] !== undefined) data["VoiceApplicationSid"] = params["voiceApplicationSid"];
        if (params["voiceCallerIdLookup"] !== undefined) data["VoiceCallerIdLookup"] = serialize.bool(params["voiceCallerIdLookup"]);
        if (params["voiceFallbackMethod"] !== undefined) data["VoiceFallbackMethod"] = params["voiceFallbackMethod"];
        if (params["voiceFallbackUrl"] !== undefined) data["VoiceFallbackUrl"] = params["voiceFallbackUrl"];
        if (params["voiceMethod"] !== undefined) data["VoiceMethod"] = params["voiceMethod"];
        if (params["voiceUrl"] !== undefined) data["VoiceUrl"] = params["voiceUrl"];
        if (params["identitySid"] !== undefined) data["IdentitySid"] = params["identitySid"];
        if (params["addressSid"] !== undefined) data["AddressSid"] = params["addressSid"];
        if (params["emergencyStatus"] !== undefined) data["EmergencyStatus"] = params["emergencyStatus"];
        if (params["emergencyAddressSid"] !== undefined) data["EmergencyAddressSid"] = params["emergencyAddressSid"];
        if (params["trunkSid"] !== undefined) data["TrunkSid"] = params["trunkSid"];
        if (params["voiceReceiveMode"] !== undefined) data["VoiceReceiveMode"] = params["voiceReceiveMode"];
        if (params["bundleSid"] !== undefined) data["BundleSid"] = params["bundleSid"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.createWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new MobileInstance(operationVersion, response.body, instance._solution.accountSid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["beta"] !== undefined) data["Beta"] = serialize.bool(params["beta"]);
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["phoneNumber"] !== undefined) data["PhoneNumber"] = params["phoneNumber"];
        if (params["origin"] !== undefined) data["Origin"] = params["origin"];
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new MobilePage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new MobilePage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["beta"] !== undefined) data["Beta"] = serialize.bool(params["beta"]);
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["phoneNumber"] !== undefined) data["PhoneNumber"] = params["phoneNumber"];
        if (params["origin"] !== undefined) data["Origin"] = params["origin"];
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new MobilePage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new MobilePage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class MobileInstance {
    constructor(_version, payload, accountSid){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.addressSid = payload.address_sid;
        this.addressRequirements = payload.address_requirements;
        this.apiVersion = payload.api_version;
        this.beta = payload.beta;
        this.capabilities = payload.capabilities;
        this.dateCreated = deserialize.rfc2822DateTime(payload.date_created);
        this.dateUpdated = deserialize.rfc2822DateTime(payload.date_updated);
        this.friendlyName = payload.friendly_name;
        this.identitySid = payload.identity_sid;
        this.phoneNumber = payload.phone_number;
        this.origin = payload.origin;
        this.sid = payload.sid;
        this.smsApplicationSid = payload.sms_application_sid;
        this.smsFallbackMethod = payload.sms_fallback_method;
        this.smsFallbackUrl = payload.sms_fallback_url;
        this.smsMethod = payload.sms_method;
        this.smsUrl = payload.sms_url;
        this.statusCallback = payload.status_callback;
        this.statusCallbackMethod = payload.status_callback_method;
        this.trunkSid = payload.trunk_sid;
        this.uri = payload.uri;
        this.voiceReceiveMode = payload.voice_receive_mode;
        this.voiceApplicationSid = payload.voice_application_sid;
        this.voiceCallerIdLookup = payload.voice_caller_id_lookup;
        this.voiceFallbackMethod = payload.voice_fallback_method;
        this.voiceFallbackUrl = payload.voice_fallback_url;
        this.voiceMethod = payload.voice_method;
        this.voiceUrl = payload.voice_url;
        this.emergencyStatus = payload.emergency_status;
        this.emergencyAddressSid = payload.emergency_address_sid;
        this.emergencyAddressStatus = payload.emergency_address_status;
        this.bundleSid = payload.bundle_sid;
        this.status = payload.status;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            addressSid: this.addressSid,
            addressRequirements: this.addressRequirements,
            apiVersion: this.apiVersion,
            beta: this.beta,
            capabilities: this.capabilities,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated,
            friendlyName: this.friendlyName,
            identitySid: this.identitySid,
            phoneNumber: this.phoneNumber,
            origin: this.origin,
            sid: this.sid,
            smsApplicationSid: this.smsApplicationSid,
            smsFallbackMethod: this.smsFallbackMethod,
            smsFallbackUrl: this.smsFallbackUrl,
            smsMethod: this.smsMethod,
            smsUrl: this.smsUrl,
            statusCallback: this.statusCallback,
            statusCallbackMethod: this.statusCallbackMethod,
            trunkSid: this.trunkSid,
            uri: this.uri,
            voiceReceiveMode: this.voiceReceiveMode,
            voiceApplicationSid: this.voiceApplicationSid,
            voiceCallerIdLookup: this.voiceCallerIdLookup,
            voiceFallbackMethod: this.voiceFallbackMethod,
            voiceFallbackUrl: this.voiceFallbackUrl,
            voiceMethod: this.voiceMethod,
            voiceUrl: this.voiceUrl,
            emergencyStatus: this.emergencyStatus,
            emergencyAddressSid: this.emergencyAddressSid,
            emergencyAddressStatus: this.emergencyAddressStatus,
            bundleSid: this.bundleSid,
            status: this.status
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.MobileInstance = MobileInstance;
class MobilePage extends Page_1.default {
    /**
     * Initialize the MobilePage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of MobileInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new MobileInstance(this._version, payload, this._solution.accountSid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.MobilePage = MobilePage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/incomingPhoneNumber/tollFree.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TollFreePage = exports.TollFreeInstance = void 0;
exports.TollFreeListInstance = TollFreeListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
function TollFreeListInstance(version, accountSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    const instance = {};
    instance._version = version;
    instance._solution = {
        accountSid
    };
    instance._uri = `/Accounts/${accountSid}/IncomingPhoneNumbers/TollFree.json`;
    instance.create = function create(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["phoneNumber"] === null || params["phoneNumber"] === undefined) {
            throw new Error("Required parameter \"params['phoneNumber']\" missing.");
        }
        let data = {};
        data["PhoneNumber"] = params["phoneNumber"];
        if (params["apiVersion"] !== undefined) data["ApiVersion"] = params["apiVersion"];
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["smsApplicationSid"] !== undefined) data["SmsApplicationSid"] = params["smsApplicationSid"];
        if (params["smsFallbackMethod"] !== undefined) data["SmsFallbackMethod"] = params["smsFallbackMethod"];
        if (params["smsFallbackUrl"] !== undefined) data["SmsFallbackUrl"] = params["smsFallbackUrl"];
        if (params["smsMethod"] !== undefined) data["SmsMethod"] = params["smsMethod"];
        if (params["smsUrl"] !== undefined) data["SmsUrl"] = params["smsUrl"];
        if (params["statusCallback"] !== undefined) data["StatusCallback"] = params["statusCallback"];
        if (params["statusCallbackMethod"] !== undefined) data["StatusCallbackMethod"] = params["statusCallbackMethod"];
        if (params["voiceApplicationSid"] !== undefined) data["VoiceApplicationSid"] = params["voiceApplicationSid"];
        if (params["voiceCallerIdLookup"] !== undefined) data["VoiceCallerIdLookup"] = serialize.bool(params["voiceCallerIdLookup"]);
        if (params["voiceFallbackMethod"] !== undefined) data["VoiceFallbackMethod"] = params["voiceFallbackMethod"];
        if (params["voiceFallbackUrl"] !== undefined) data["VoiceFallbackUrl"] = params["voiceFallbackUrl"];
        if (params["voiceMethod"] !== undefined) data["VoiceMethod"] = params["voiceMethod"];
        if (params["voiceUrl"] !== undefined) data["VoiceUrl"] = params["voiceUrl"];
        if (params["identitySid"] !== undefined) data["IdentitySid"] = params["identitySid"];
        if (params["addressSid"] !== undefined) data["AddressSid"] = params["addressSid"];
        if (params["emergencyStatus"] !== undefined) data["EmergencyStatus"] = params["emergencyStatus"];
        if (params["emergencyAddressSid"] !== undefined) data["EmergencyAddressSid"] = params["emergencyAddressSid"];
        if (params["trunkSid"] !== undefined) data["TrunkSid"] = params["trunkSid"];
        if (params["voiceReceiveMode"] !== undefined) data["VoiceReceiveMode"] = params["voiceReceiveMode"];
        if (params["bundleSid"] !== undefined) data["BundleSid"] = params["bundleSid"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.create({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new TollFreeInstance(operationVersion, payload, instance._solution.accountSid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.createWithHttpInfo = function createWithHttpInfo(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["phoneNumber"] === null || params["phoneNumber"] === undefined) {
            throw new Error("Required parameter \"params['phoneNumber']\" missing.");
        }
        let data = {};
        data["PhoneNumber"] = params["phoneNumber"];
        if (params["apiVersion"] !== undefined) data["ApiVersion"] = params["apiVersion"];
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["smsApplicationSid"] !== undefined) data["SmsApplicationSid"] = params["smsApplicationSid"];
        if (params["smsFallbackMethod"] !== undefined) data["SmsFallbackMethod"] = params["smsFallbackMethod"];
        if (params["smsFallbackUrl"] !== undefined) data["SmsFallbackUrl"] = params["smsFallbackUrl"];
        if (params["smsMethod"] !== undefined) data["SmsMethod"] = params["smsMethod"];
        if (params["smsUrl"] !== undefined) data["SmsUrl"] = params["smsUrl"];
        if (params["statusCallback"] !== undefined) data["StatusCallback"] = params["statusCallback"];
        if (params["statusCallbackMethod"] !== undefined) data["StatusCallbackMethod"] = params["statusCallbackMethod"];
        if (params["voiceApplicationSid"] !== undefined) data["VoiceApplicationSid"] = params["voiceApplicationSid"];
        if (params["voiceCallerIdLookup"] !== undefined) data["VoiceCallerIdLookup"] = serialize.bool(params["voiceCallerIdLookup"]);
        if (params["voiceFallbackMethod"] !== undefined) data["VoiceFallbackMethod"] = params["voiceFallbackMethod"];
        if (params["voiceFallbackUrl"] !== undefined) data["VoiceFallbackUrl"] = params["voiceFallbackUrl"];
        if (params["voiceMethod"] !== undefined) data["VoiceMethod"] = params["voiceMethod"];
        if (params["voiceUrl"] !== undefined) data["VoiceUrl"] = params["voiceUrl"];
        if (params["identitySid"] !== undefined) data["IdentitySid"] = params["identitySid"];
        if (params["addressSid"] !== undefined) data["AddressSid"] = params["addressSid"];
        if (params["emergencyStatus"] !== undefined) data["EmergencyStatus"] = params["emergencyStatus"];
        if (params["emergencyAddressSid"] !== undefined) data["EmergencyAddressSid"] = params["emergencyAddressSid"];
        if (params["trunkSid"] !== undefined) data["TrunkSid"] = params["trunkSid"];
        if (params["voiceReceiveMode"] !== undefined) data["VoiceReceiveMode"] = params["voiceReceiveMode"];
        if (params["bundleSid"] !== undefined) data["BundleSid"] = params["bundleSid"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.createWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new TollFreeInstance(operationVersion, response.body, instance._solution.accountSid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["beta"] !== undefined) data["Beta"] = serialize.bool(params["beta"]);
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["phoneNumber"] !== undefined) data["PhoneNumber"] = params["phoneNumber"];
        if (params["origin"] !== undefined) data["Origin"] = params["origin"];
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new TollFreePage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new TollFreePage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["beta"] !== undefined) data["Beta"] = serialize.bool(params["beta"]);
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["phoneNumber"] !== undefined) data["PhoneNumber"] = params["phoneNumber"];
        if (params["origin"] !== undefined) data["Origin"] = params["origin"];
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new TollFreePage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new TollFreePage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class TollFreeInstance {
    constructor(_version, payload, accountSid){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.addressSid = payload.address_sid;
        this.addressRequirements = payload.address_requirements;
        this.apiVersion = payload.api_version;
        this.beta = payload.beta;
        this.capabilities = payload.capabilities;
        this.dateCreated = deserialize.rfc2822DateTime(payload.date_created);
        this.dateUpdated = deserialize.rfc2822DateTime(payload.date_updated);
        this.friendlyName = payload.friendly_name;
        this.identitySid = payload.identity_sid;
        this.phoneNumber = payload.phone_number;
        this.origin = payload.origin;
        this.sid = payload.sid;
        this.smsApplicationSid = payload.sms_application_sid;
        this.smsFallbackMethod = payload.sms_fallback_method;
        this.smsFallbackUrl = payload.sms_fallback_url;
        this.smsMethod = payload.sms_method;
        this.smsUrl = payload.sms_url;
        this.statusCallback = payload.status_callback;
        this.statusCallbackMethod = payload.status_callback_method;
        this.trunkSid = payload.trunk_sid;
        this.uri = payload.uri;
        this.voiceReceiveMode = payload.voice_receive_mode;
        this.voiceApplicationSid = payload.voice_application_sid;
        this.voiceCallerIdLookup = payload.voice_caller_id_lookup;
        this.voiceFallbackMethod = payload.voice_fallback_method;
        this.voiceFallbackUrl = payload.voice_fallback_url;
        this.voiceMethod = payload.voice_method;
        this.voiceUrl = payload.voice_url;
        this.emergencyStatus = payload.emergency_status;
        this.emergencyAddressSid = payload.emergency_address_sid;
        this.emergencyAddressStatus = payload.emergency_address_status;
        this.bundleSid = payload.bundle_sid;
        this.status = payload.status;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            addressSid: this.addressSid,
            addressRequirements: this.addressRequirements,
            apiVersion: this.apiVersion,
            beta: this.beta,
            capabilities: this.capabilities,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated,
            friendlyName: this.friendlyName,
            identitySid: this.identitySid,
            phoneNumber: this.phoneNumber,
            origin: this.origin,
            sid: this.sid,
            smsApplicationSid: this.smsApplicationSid,
            smsFallbackMethod: this.smsFallbackMethod,
            smsFallbackUrl: this.smsFallbackUrl,
            smsMethod: this.smsMethod,
            smsUrl: this.smsUrl,
            statusCallback: this.statusCallback,
            statusCallbackMethod: this.statusCallbackMethod,
            trunkSid: this.trunkSid,
            uri: this.uri,
            voiceReceiveMode: this.voiceReceiveMode,
            voiceApplicationSid: this.voiceApplicationSid,
            voiceCallerIdLookup: this.voiceCallerIdLookup,
            voiceFallbackMethod: this.voiceFallbackMethod,
            voiceFallbackUrl: this.voiceFallbackUrl,
            voiceMethod: this.voiceMethod,
            voiceUrl: this.voiceUrl,
            emergencyStatus: this.emergencyStatus,
            emergencyAddressSid: this.emergencyAddressSid,
            emergencyAddressStatus: this.emergencyAddressStatus,
            bundleSid: this.bundleSid,
            status: this.status
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.TollFreeInstance = TollFreeInstance;
class TollFreePage extends Page_1.default {
    /**
     * Initialize the TollFreePage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of TollFreeInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new TollFreeInstance(this._version, payload, this._solution.accountSid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.TollFreePage = TollFreePage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/incomingPhoneNumber.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.IncomingPhoneNumberPage = exports.IncomingPhoneNumberInstance = exports.IncomingPhoneNumberContextImpl = void 0;
exports.IncomingPhoneNumberListInstance = IncomingPhoneNumberListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
const assignedAddOn_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/incomingPhoneNumber/assignedAddOn.js [app-route] (ecmascript)");
const local_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/incomingPhoneNumber/local.js [app-route] (ecmascript)");
const mobile_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/incomingPhoneNumber/mobile.js [app-route] (ecmascript)");
const tollFree_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/incomingPhoneNumber/tollFree.js [app-route] (ecmascript)");
class IncomingPhoneNumberContextImpl {
    constructor(_version, accountSid, sid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(accountSid)) {
            throw new Error("Parameter 'accountSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(sid)) {
            throw new Error("Parameter 'sid' is not valid.");
        }
        this._solution = {
            accountSid,
            sid
        };
        this._uri = `/Accounts/${accountSid}/IncomingPhoneNumbers/${sid}.json`;
    }
    get assignedAddOns() {
        this._assignedAddOns = this._assignedAddOns || (0, assignedAddOn_1.AssignedAddOnListInstance)(this._version, this._solution.accountSid, this._solution.sid);
        return this._assignedAddOns;
    }
    remove(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.remove({
            uri: instance._uri,
            method: "delete",
            headers
        });
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    removeWithHttpInfo(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version;
        // DELETE operation - returns boolean based on status code
        let operationPromise = operationVersion.removeWithResponseInfo({
            uri: instance._uri,
            method: "delete",
            headers
        }).then((response)=>({
                ...response,
                body: response.statusCode === 204
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new IncomingPhoneNumberInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new IncomingPhoneNumberInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    update(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["accountSid"] !== undefined) data["AccountSid"] = params["accountSid"];
        if (params["apiVersion"] !== undefined) data["ApiVersion"] = params["apiVersion"];
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["smsApplicationSid"] !== undefined) data["SmsApplicationSid"] = params["smsApplicationSid"];
        if (params["smsFallbackMethod"] !== undefined) data["SmsFallbackMethod"] = params["smsFallbackMethod"];
        if (params["smsFallbackUrl"] !== undefined) data["SmsFallbackUrl"] = params["smsFallbackUrl"];
        if (params["smsMethod"] !== undefined) data["SmsMethod"] = params["smsMethod"];
        if (params["smsUrl"] !== undefined) data["SmsUrl"] = params["smsUrl"];
        if (params["statusCallback"] !== undefined) data["StatusCallback"] = params["statusCallback"];
        if (params["statusCallbackMethod"] !== undefined) data["StatusCallbackMethod"] = params["statusCallbackMethod"];
        if (params["voiceApplicationSid"] !== undefined) data["VoiceApplicationSid"] = params["voiceApplicationSid"];
        if (params["voiceCallerIdLookup"] !== undefined) data["VoiceCallerIdLookup"] = serialize.bool(params["voiceCallerIdLookup"]);
        if (params["voiceFallbackMethod"] !== undefined) data["VoiceFallbackMethod"] = params["voiceFallbackMethod"];
        if (params["voiceFallbackUrl"] !== undefined) data["VoiceFallbackUrl"] = params["voiceFallbackUrl"];
        if (params["voiceMethod"] !== undefined) data["VoiceMethod"] = params["voiceMethod"];
        if (params["voiceUrl"] !== undefined) data["VoiceUrl"] = params["voiceUrl"];
        if (params["emergencyStatus"] !== undefined) data["EmergencyStatus"] = params["emergencyStatus"];
        if (params["emergencyAddressSid"] !== undefined) data["EmergencyAddressSid"] = params["emergencyAddressSid"];
        if (params["trunkSid"] !== undefined) data["TrunkSid"] = params["trunkSid"];
        if (params["voiceReceiveMode"] !== undefined) data["VoiceReceiveMode"] = params["voiceReceiveMode"];
        if (params["identitySid"] !== undefined) data["IdentitySid"] = params["identitySid"];
        if (params["addressSid"] !== undefined) data["AddressSid"] = params["addressSid"];
        if (params["bundleSid"] !== undefined) data["BundleSid"] = params["bundleSid"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.update({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new IncomingPhoneNumberInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    updateWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["accountSid"] !== undefined) data["AccountSid"] = params["accountSid"];
        if (params["apiVersion"] !== undefined) data["ApiVersion"] = params["apiVersion"];
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["smsApplicationSid"] !== undefined) data["SmsApplicationSid"] = params["smsApplicationSid"];
        if (params["smsFallbackMethod"] !== undefined) data["SmsFallbackMethod"] = params["smsFallbackMethod"];
        if (params["smsFallbackUrl"] !== undefined) data["SmsFallbackUrl"] = params["smsFallbackUrl"];
        if (params["smsMethod"] !== undefined) data["SmsMethod"] = params["smsMethod"];
        if (params["smsUrl"] !== undefined) data["SmsUrl"] = params["smsUrl"];
        if (params["statusCallback"] !== undefined) data["StatusCallback"] = params["statusCallback"];
        if (params["statusCallbackMethod"] !== undefined) data["StatusCallbackMethod"] = params["statusCallbackMethod"];
        if (params["voiceApplicationSid"] !== undefined) data["VoiceApplicationSid"] = params["voiceApplicationSid"];
        if (params["voiceCallerIdLookup"] !== undefined) data["VoiceCallerIdLookup"] = serialize.bool(params["voiceCallerIdLookup"]);
        if (params["voiceFallbackMethod"] !== undefined) data["VoiceFallbackMethod"] = params["voiceFallbackMethod"];
        if (params["voiceFallbackUrl"] !== undefined) data["VoiceFallbackUrl"] = params["voiceFallbackUrl"];
        if (params["voiceMethod"] !== undefined) data["VoiceMethod"] = params["voiceMethod"];
        if (params["voiceUrl"] !== undefined) data["VoiceUrl"] = params["voiceUrl"];
        if (params["emergencyStatus"] !== undefined) data["EmergencyStatus"] = params["emergencyStatus"];
        if (params["emergencyAddressSid"] !== undefined) data["EmergencyAddressSid"] = params["emergencyAddressSid"];
        if (params["trunkSid"] !== undefined) data["TrunkSid"] = params["trunkSid"];
        if (params["voiceReceiveMode"] !== undefined) data["VoiceReceiveMode"] = params["voiceReceiveMode"];
        if (params["identitySid"] !== undefined) data["IdentitySid"] = params["identitySid"];
        if (params["addressSid"] !== undefined) data["AddressSid"] = params["addressSid"];
        if (params["bundleSid"] !== undefined) data["BundleSid"] = params["bundleSid"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.updateWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new IncomingPhoneNumberInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.IncomingPhoneNumberContextImpl = IncomingPhoneNumberContextImpl;
class IncomingPhoneNumberInstance {
    constructor(_version, payload, accountSid, sid){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.addressSid = payload.address_sid;
        this.addressRequirements = payload.address_requirements;
        this.apiVersion = payload.api_version;
        this.beta = payload.beta;
        this.capabilities = payload.capabilities;
        this.dateCreated = deserialize.rfc2822DateTime(payload.date_created);
        this.dateUpdated = deserialize.rfc2822DateTime(payload.date_updated);
        this.friendlyName = payload.friendly_name;
        this.identitySid = payload.identity_sid;
        this.phoneNumber = payload.phone_number;
        this.origin = payload.origin;
        this.sid = payload.sid;
        this.smsApplicationSid = payload.sms_application_sid;
        this.smsFallbackMethod = payload.sms_fallback_method;
        this.smsFallbackUrl = payload.sms_fallback_url;
        this.smsMethod = payload.sms_method;
        this.smsUrl = payload.sms_url;
        this.statusCallback = payload.status_callback;
        this.statusCallbackMethod = payload.status_callback_method;
        this.trunkSid = payload.trunk_sid;
        this.uri = payload.uri;
        this.voiceReceiveMode = payload.voice_receive_mode;
        this.voiceApplicationSid = payload.voice_application_sid;
        this.voiceCallerIdLookup = payload.voice_caller_id_lookup;
        this.voiceFallbackMethod = payload.voice_fallback_method;
        this.voiceFallbackUrl = payload.voice_fallback_url;
        this.voiceMethod = payload.voice_method;
        this.voiceUrl = payload.voice_url;
        this.emergencyStatus = payload.emergency_status;
        this.emergencyAddressSid = payload.emergency_address_sid;
        this.emergencyAddressStatus = payload.emergency_address_status;
        this.bundleSid = payload.bundle_sid;
        this.status = payload.status;
        this._solution = {
            accountSid,
            sid: sid || this.sid
        };
    }
    get _proxy() {
        this._context = this._context || new IncomingPhoneNumberContextImpl(this._version, this._solution.accountSid, this._solution.sid);
        return this._context;
    }
    /**
     * Remove a IncomingPhoneNumberInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean
     */ remove(callback) {
        return this._proxy.remove(callback);
    }
    /**
     * Remove a IncomingPhoneNumberInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean with HTTP metadata
     */ removeWithHttpInfo(callback) {
        return this._proxy.removeWithHttpInfo(callback);
    }
    /**
     * Fetch a IncomingPhoneNumberInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed IncomingPhoneNumberInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a IncomingPhoneNumberInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed IncomingPhoneNumberInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    update(params, callback) {
        return this._proxy.update(params, callback);
    }
    updateWithHttpInfo(params, callback) {
        return this._proxy.updateWithHttpInfo(params, callback);
    }
    /**
     * Access the assignedAddOns.
     */ assignedAddOns() {
        return this._proxy.assignedAddOns;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            addressSid: this.addressSid,
            addressRequirements: this.addressRequirements,
            apiVersion: this.apiVersion,
            beta: this.beta,
            capabilities: this.capabilities,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated,
            friendlyName: this.friendlyName,
            identitySid: this.identitySid,
            phoneNumber: this.phoneNumber,
            origin: this.origin,
            sid: this.sid,
            smsApplicationSid: this.smsApplicationSid,
            smsFallbackMethod: this.smsFallbackMethod,
            smsFallbackUrl: this.smsFallbackUrl,
            smsMethod: this.smsMethod,
            smsUrl: this.smsUrl,
            statusCallback: this.statusCallback,
            statusCallbackMethod: this.statusCallbackMethod,
            trunkSid: this.trunkSid,
            uri: this.uri,
            voiceReceiveMode: this.voiceReceiveMode,
            voiceApplicationSid: this.voiceApplicationSid,
            voiceCallerIdLookup: this.voiceCallerIdLookup,
            voiceFallbackMethod: this.voiceFallbackMethod,
            voiceFallbackUrl: this.voiceFallbackUrl,
            voiceMethod: this.voiceMethod,
            voiceUrl: this.voiceUrl,
            emergencyStatus: this.emergencyStatus,
            emergencyAddressSid: this.emergencyAddressSid,
            emergencyAddressStatus: this.emergencyAddressStatus,
            bundleSid: this.bundleSid,
            status: this.status
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.IncomingPhoneNumberInstance = IncomingPhoneNumberInstance;
function IncomingPhoneNumberListInstance(version, accountSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    const instance = (sid)=>instance.get(sid);
    instance.get = function get(sid) {
        return new IncomingPhoneNumberContextImpl(version, accountSid, sid);
    };
    instance._version = version;
    instance._solution = {
        accountSid
    };
    instance._uri = `/Accounts/${accountSid}/IncomingPhoneNumbers.json`;
    Object.defineProperty(instance, "local", {
        get: function local() {
            if (!instance._local) {
                instance._local = (0, local_1.LocalListInstance)(instance._version, instance._solution.accountSid);
            }
            return instance._local;
        }
    });
    Object.defineProperty(instance, "mobile", {
        get: function mobile() {
            if (!instance._mobile) {
                instance._mobile = (0, mobile_1.MobileListInstance)(instance._version, instance._solution.accountSid);
            }
            return instance._mobile;
        }
    });
    Object.defineProperty(instance, "tollFree", {
        get: function tollFree() {
            if (!instance._tollFree) {
                instance._tollFree = (0, tollFree_1.TollFreeListInstance)(instance._version, instance._solution.accountSid);
            }
            return instance._tollFree;
        }
    });
    instance.create = function create(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["apiVersion"] !== undefined) data["ApiVersion"] = params["apiVersion"];
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["smsApplicationSid"] !== undefined) data["SmsApplicationSid"] = params["smsApplicationSid"];
        if (params["smsFallbackMethod"] !== undefined) data["SmsFallbackMethod"] = params["smsFallbackMethod"];
        if (params["smsFallbackUrl"] !== undefined) data["SmsFallbackUrl"] = params["smsFallbackUrl"];
        if (params["smsMethod"] !== undefined) data["SmsMethod"] = params["smsMethod"];
        if (params["smsUrl"] !== undefined) data["SmsUrl"] = params["smsUrl"];
        if (params["statusCallback"] !== undefined) data["StatusCallback"] = params["statusCallback"];
        if (params["statusCallbackMethod"] !== undefined) data["StatusCallbackMethod"] = params["statusCallbackMethod"];
        if (params["voiceApplicationSid"] !== undefined) data["VoiceApplicationSid"] = params["voiceApplicationSid"];
        if (params["voiceCallerIdLookup"] !== undefined) data["VoiceCallerIdLookup"] = serialize.bool(params["voiceCallerIdLookup"]);
        if (params["voiceFallbackMethod"] !== undefined) data["VoiceFallbackMethod"] = params["voiceFallbackMethod"];
        if (params["voiceFallbackUrl"] !== undefined) data["VoiceFallbackUrl"] = params["voiceFallbackUrl"];
        if (params["voiceMethod"] !== undefined) data["VoiceMethod"] = params["voiceMethod"];
        if (params["voiceUrl"] !== undefined) data["VoiceUrl"] = params["voiceUrl"];
        if (params["emergencyStatus"] !== undefined) data["EmergencyStatus"] = params["emergencyStatus"];
        if (params["emergencyAddressSid"] !== undefined) data["EmergencyAddressSid"] = params["emergencyAddressSid"];
        if (params["trunkSid"] !== undefined) data["TrunkSid"] = params["trunkSid"];
        if (params["identitySid"] !== undefined) data["IdentitySid"] = params["identitySid"];
        if (params["addressSid"] !== undefined) data["AddressSid"] = params["addressSid"];
        if (params["voiceReceiveMode"] !== undefined) data["VoiceReceiveMode"] = params["voiceReceiveMode"];
        if (params["bundleSid"] !== undefined) data["BundleSid"] = params["bundleSid"];
        if (params["phoneNumber"] !== undefined) data["PhoneNumber"] = params["phoneNumber"];
        if (params["areaCode"] !== undefined) data["AreaCode"] = params["areaCode"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.create({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new IncomingPhoneNumberInstance(operationVersion, payload, instance._solution.accountSid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.createWithHttpInfo = function createWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["apiVersion"] !== undefined) data["ApiVersion"] = params["apiVersion"];
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["smsApplicationSid"] !== undefined) data["SmsApplicationSid"] = params["smsApplicationSid"];
        if (params["smsFallbackMethod"] !== undefined) data["SmsFallbackMethod"] = params["smsFallbackMethod"];
        if (params["smsFallbackUrl"] !== undefined) data["SmsFallbackUrl"] = params["smsFallbackUrl"];
        if (params["smsMethod"] !== undefined) data["SmsMethod"] = params["smsMethod"];
        if (params["smsUrl"] !== undefined) data["SmsUrl"] = params["smsUrl"];
        if (params["statusCallback"] !== undefined) data["StatusCallback"] = params["statusCallback"];
        if (params["statusCallbackMethod"] !== undefined) data["StatusCallbackMethod"] = params["statusCallbackMethod"];
        if (params["voiceApplicationSid"] !== undefined) data["VoiceApplicationSid"] = params["voiceApplicationSid"];
        if (params["voiceCallerIdLookup"] !== undefined) data["VoiceCallerIdLookup"] = serialize.bool(params["voiceCallerIdLookup"]);
        if (params["voiceFallbackMethod"] !== undefined) data["VoiceFallbackMethod"] = params["voiceFallbackMethod"];
        if (params["voiceFallbackUrl"] !== undefined) data["VoiceFallbackUrl"] = params["voiceFallbackUrl"];
        if (params["voiceMethod"] !== undefined) data["VoiceMethod"] = params["voiceMethod"];
        if (params["voiceUrl"] !== undefined) data["VoiceUrl"] = params["voiceUrl"];
        if (params["emergencyStatus"] !== undefined) data["EmergencyStatus"] = params["emergencyStatus"];
        if (params["emergencyAddressSid"] !== undefined) data["EmergencyAddressSid"] = params["emergencyAddressSid"];
        if (params["trunkSid"] !== undefined) data["TrunkSid"] = params["trunkSid"];
        if (params["identitySid"] !== undefined) data["IdentitySid"] = params["identitySid"];
        if (params["addressSid"] !== undefined) data["AddressSid"] = params["addressSid"];
        if (params["voiceReceiveMode"] !== undefined) data["VoiceReceiveMode"] = params["voiceReceiveMode"];
        if (params["bundleSid"] !== undefined) data["BundleSid"] = params["bundleSid"];
        if (params["phoneNumber"] !== undefined) data["PhoneNumber"] = params["phoneNumber"];
        if (params["areaCode"] !== undefined) data["AreaCode"] = params["areaCode"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.createWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new IncomingPhoneNumberInstance(operationVersion, response.body, instance._solution.accountSid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["beta"] !== undefined) data["Beta"] = serialize.bool(params["beta"]);
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["phoneNumber"] !== undefined) data["PhoneNumber"] = params["phoneNumber"];
        if (params["origin"] !== undefined) data["Origin"] = params["origin"];
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new IncomingPhoneNumberPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new IncomingPhoneNumberPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["beta"] !== undefined) data["Beta"] = serialize.bool(params["beta"]);
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["phoneNumber"] !== undefined) data["PhoneNumber"] = params["phoneNumber"];
        if (params["origin"] !== undefined) data["Origin"] = params["origin"];
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new IncomingPhoneNumberPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new IncomingPhoneNumberPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class IncomingPhoneNumberPage extends Page_1.default {
    /**
     * Initialize the IncomingPhoneNumberPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of IncomingPhoneNumberInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new IncomingPhoneNumberInstance(this._version, payload, this._solution.accountSid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.IncomingPhoneNumberPage = IncomingPhoneNumberPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/key.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.KeyPage = exports.KeyInstance = exports.KeyContextImpl = void 0;
exports.KeyListInstance = KeyListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
class KeyContextImpl {
    constructor(_version, accountSid, sid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(accountSid)) {
            throw new Error("Parameter 'accountSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(sid)) {
            throw new Error("Parameter 'sid' is not valid.");
        }
        this._solution = {
            accountSid,
            sid
        };
        this._uri = `/Accounts/${accountSid}/Keys/${sid}.json`;
    }
    remove(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.remove({
            uri: instance._uri,
            method: "delete",
            headers
        });
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    removeWithHttpInfo(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version;
        // DELETE operation - returns boolean based on status code
        let operationPromise = operationVersion.removeWithResponseInfo({
            uri: instance._uri,
            method: "delete",
            headers
        }).then((response)=>({
                ...response,
                body: response.statusCode === 204
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new KeyInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new KeyInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    update(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.update({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new KeyInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    updateWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.updateWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new KeyInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.KeyContextImpl = KeyContextImpl;
class KeyInstance {
    constructor(_version, payload, accountSid, sid){
        this._version = _version;
        this.sid = payload.sid;
        this.friendlyName = payload.friendly_name;
        this.dateCreated = deserialize.rfc2822DateTime(payload.date_created);
        this.dateUpdated = deserialize.rfc2822DateTime(payload.date_updated);
        this._solution = {
            accountSid,
            sid: sid || this.sid
        };
    }
    get _proxy() {
        this._context = this._context || new KeyContextImpl(this._version, this._solution.accountSid, this._solution.sid);
        return this._context;
    }
    /**
     * Remove a KeyInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean
     */ remove(callback) {
        return this._proxy.remove(callback);
    }
    /**
     * Remove a KeyInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean with HTTP metadata
     */ removeWithHttpInfo(callback) {
        return this._proxy.removeWithHttpInfo(callback);
    }
    /**
     * Fetch a KeyInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed KeyInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a KeyInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed KeyInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    update(params, callback) {
        return this._proxy.update(params, callback);
    }
    updateWithHttpInfo(params, callback) {
        return this._proxy.updateWithHttpInfo(params, callback);
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            sid: this.sid,
            friendlyName: this.friendlyName,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.KeyInstance = KeyInstance;
function KeyListInstance(version, accountSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    const instance = (sid)=>instance.get(sid);
    instance.get = function get(sid) {
        return new KeyContextImpl(version, accountSid, sid);
    };
    instance._version = version;
    instance._solution = {
        accountSid
    };
    instance._uri = `/Accounts/${accountSid}/Keys.json`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new KeyPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new KeyPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new KeyPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new KeyPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class KeyPage extends Page_1.default {
    /**
     * Initialize the KeyPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of KeyInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new KeyInstance(this._version, payload, this._solution.accountSid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.KeyPage = KeyPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/message/feedback.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FeedbackInstance = void 0;
exports.FeedbackListInstance = FeedbackListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
function FeedbackListInstance(version, accountSid, messageSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    if (!(0, utility_1.isValidPathParam)(messageSid)) {
        throw new Error("Parameter 'messageSid' is not valid.");
    }
    const instance = {};
    instance._version = version;
    instance._solution = {
        accountSid,
        messageSid
    };
    instance._uri = `/Accounts/${accountSid}/Messages/${messageSid}/Feedback.json`;
    instance.create = function create(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["outcome"] !== undefined) data["Outcome"] = params["outcome"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.create({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new FeedbackInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.messageSid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.createWithHttpInfo = function createWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["outcome"] !== undefined) data["Outcome"] = params["outcome"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.createWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new FeedbackInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.messageSid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class FeedbackInstance {
    constructor(_version, payload, accountSid, messageSid){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.messageSid = payload.message_sid;
        this.outcome = payload.outcome;
        this.dateCreated = deserialize.rfc2822DateTime(payload.date_created);
        this.dateUpdated = deserialize.rfc2822DateTime(payload.date_updated);
        this.uri = payload.uri;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            messageSid: this.messageSid,
            outcome: this.outcome,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated,
            uri: this.uri
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.FeedbackInstance = FeedbackInstance;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/message/media.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MediaPage = exports.MediaInstance = exports.MediaContextImpl = void 0;
exports.MediaListInstance = MediaListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
class MediaContextImpl {
    constructor(_version, accountSid, messageSid, sid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(accountSid)) {
            throw new Error("Parameter 'accountSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(messageSid)) {
            throw new Error("Parameter 'messageSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(sid)) {
            throw new Error("Parameter 'sid' is not valid.");
        }
        this._solution = {
            accountSid,
            messageSid,
            sid
        };
        this._uri = `/Accounts/${accountSid}/Messages/${messageSid}/Media/${sid}.json`;
    }
    remove(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.remove({
            uri: instance._uri,
            method: "delete",
            headers
        });
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    removeWithHttpInfo(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version;
        // DELETE operation - returns boolean based on status code
        let operationPromise = operationVersion.removeWithResponseInfo({
            uri: instance._uri,
            method: "delete",
            headers
        }).then((response)=>({
                ...response,
                body: response.statusCode === 204
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new MediaInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.messageSid, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new MediaInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.messageSid, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.MediaContextImpl = MediaContextImpl;
class MediaInstance {
    constructor(_version, payload, accountSid, messageSid, sid){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.contentType = payload.content_type;
        this.dateCreated = deserialize.rfc2822DateTime(payload.date_created);
        this.dateUpdated = deserialize.rfc2822DateTime(payload.date_updated);
        this.parentSid = payload.parent_sid;
        this.sid = payload.sid;
        this.uri = payload.uri;
        this._solution = {
            accountSid,
            messageSid,
            sid: sid || this.sid
        };
    }
    get _proxy() {
        this._context = this._context || new MediaContextImpl(this._version, this._solution.accountSid, this._solution.messageSid, this._solution.sid);
        return this._context;
    }
    /**
     * Remove a MediaInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean
     */ remove(callback) {
        return this._proxy.remove(callback);
    }
    /**
     * Remove a MediaInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean with HTTP metadata
     */ removeWithHttpInfo(callback) {
        return this._proxy.removeWithHttpInfo(callback);
    }
    /**
     * Fetch a MediaInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed MediaInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a MediaInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed MediaInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            contentType: this.contentType,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated,
            parentSid: this.parentSid,
            sid: this.sid,
            uri: this.uri
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.MediaInstance = MediaInstance;
function MediaListInstance(version, accountSid, messageSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    if (!(0, utility_1.isValidPathParam)(messageSid)) {
        throw new Error("Parameter 'messageSid' is not valid.");
    }
    const instance = (sid)=>instance.get(sid);
    instance.get = function get(sid) {
        return new MediaContextImpl(version, accountSid, messageSid, sid);
    };
    instance._version = version;
    instance._solution = {
        accountSid,
        messageSid
    };
    instance._uri = `/Accounts/${accountSid}/Messages/${messageSid}/Media.json`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["dateCreated"] !== undefined) data["DateCreated"] = serialize.iso8601DateTime(params["dateCreated"]);
        if (params["dateCreatedBefore"] !== undefined) data["DateCreated<"] = serialize.iso8601DateTime(params["dateCreatedBefore"]);
        if (params["dateCreatedAfter"] !== undefined) data["DateCreated>"] = serialize.iso8601DateTime(params["dateCreatedAfter"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new MediaPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new MediaPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["dateCreated"] !== undefined) data["DateCreated"] = serialize.iso8601DateTime(params["dateCreated"]);
        if (params["dateCreatedBefore"] !== undefined) data["DateCreated<"] = serialize.iso8601DateTime(params["dateCreatedBefore"]);
        if (params["dateCreatedAfter"] !== undefined) data["DateCreated>"] = serialize.iso8601DateTime(params["dateCreatedAfter"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new MediaPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new MediaPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class MediaPage extends Page_1.default {
    /**
     * Initialize the MediaPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of MediaInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new MediaInstance(this._version, payload, this._solution.accountSid, this._solution.messageSid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.MediaPage = MediaPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/message.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MessagePage = exports.MessageInstance = exports.MessageContextImpl = void 0;
exports.MessageListInstance = MessageListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
const feedback_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/message/feedback.js [app-route] (ecmascript)");
const media_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/message/media.js [app-route] (ecmascript)");
class MessageContextImpl {
    constructor(_version, accountSid, sid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(accountSid)) {
            throw new Error("Parameter 'accountSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(sid)) {
            throw new Error("Parameter 'sid' is not valid.");
        }
        this._solution = {
            accountSid,
            sid
        };
        this._uri = `/Accounts/${accountSid}/Messages/${sid}.json`;
    }
    get feedback() {
        this._feedback = this._feedback || (0, feedback_1.FeedbackListInstance)(this._version, this._solution.accountSid, this._solution.sid);
        return this._feedback;
    }
    get media() {
        this._media = this._media || (0, media_1.MediaListInstance)(this._version, this._solution.accountSid, this._solution.sid);
        return this._media;
    }
    remove(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.remove({
            uri: instance._uri,
            method: "delete",
            headers
        });
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    removeWithHttpInfo(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version;
        // DELETE operation - returns boolean based on status code
        let operationPromise = operationVersion.removeWithResponseInfo({
            uri: instance._uri,
            method: "delete",
            headers
        }).then((response)=>({
                ...response,
                body: response.statusCode === 204
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new MessageInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new MessageInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    update(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["body"] !== undefined) data["Body"] = params["body"];
        if (params["status"] !== undefined) data["Status"] = params["status"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.update({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new MessageInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    updateWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["body"] !== undefined) data["Body"] = params["body"];
        if (params["status"] !== undefined) data["Status"] = params["status"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.updateWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new MessageInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.MessageContextImpl = MessageContextImpl;
class MessageInstance {
    constructor(_version, payload, accountSid, sid){
        this._version = _version;
        this.body = payload.body;
        this.numSegments = payload.num_segments;
        this.direction = payload.direction;
        this.from = payload.from;
        this.to = payload.to;
        this.dateUpdated = deserialize.rfc2822DateTime(payload.date_updated);
        this.price = payload.price;
        this.errorMessage = payload.error_message;
        this.uri = payload.uri;
        this.accountSid = payload.account_sid;
        this.numMedia = payload.num_media;
        this.status = payload.status;
        this.messagingServiceSid = payload.messaging_service_sid;
        this.sid = payload.sid;
        this.dateSent = deserialize.rfc2822DateTime(payload.date_sent);
        this.dateCreated = deserialize.rfc2822DateTime(payload.date_created);
        this.errorCode = deserialize.integer(payload.error_code);
        this.priceUnit = payload.price_unit;
        this.apiVersion = payload.api_version;
        this.subresourceUris = payload.subresource_uris;
        this._solution = {
            accountSid,
            sid: sid || this.sid
        };
    }
    get _proxy() {
        this._context = this._context || new MessageContextImpl(this._version, this._solution.accountSid, this._solution.sid);
        return this._context;
    }
    /**
     * Remove a MessageInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean
     */ remove(callback) {
        return this._proxy.remove(callback);
    }
    /**
     * Remove a MessageInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean with HTTP metadata
     */ removeWithHttpInfo(callback) {
        return this._proxy.removeWithHttpInfo(callback);
    }
    /**
     * Fetch a MessageInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed MessageInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a MessageInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed MessageInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    update(params, callback) {
        return this._proxy.update(params, callback);
    }
    updateWithHttpInfo(params, callback) {
        return this._proxy.updateWithHttpInfo(params, callback);
    }
    /**
     * Access the feedback.
     */ feedback() {
        return this._proxy.feedback;
    }
    /**
     * Access the media.
     */ media() {
        return this._proxy.media;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            body: this.body,
            numSegments: this.numSegments,
            direction: this.direction,
            from: this.from,
            to: this.to,
            dateUpdated: this.dateUpdated,
            price: this.price,
            errorMessage: this.errorMessage,
            uri: this.uri,
            accountSid: this.accountSid,
            numMedia: this.numMedia,
            status: this.status,
            messagingServiceSid: this.messagingServiceSid,
            sid: this.sid,
            dateSent: this.dateSent,
            dateCreated: this.dateCreated,
            errorCode: this.errorCode,
            priceUnit: this.priceUnit,
            apiVersion: this.apiVersion,
            subresourceUris: this.subresourceUris
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.MessageInstance = MessageInstance;
function MessageListInstance(version, accountSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    const instance = (sid)=>instance.get(sid);
    instance.get = function get(sid) {
        return new MessageContextImpl(version, accountSid, sid);
    };
    instance._version = version;
    instance._solution = {
        accountSid
    };
    instance._uri = `/Accounts/${accountSid}/Messages.json`;
    instance.create = function create(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["to"] === null || params["to"] === undefined) {
            throw new Error("Required parameter \"params['to']\" missing.");
        }
        let data = {};
        data["To"] = params["to"];
        if (params["statusCallback"] !== undefined) data["StatusCallback"] = params["statusCallback"];
        if (params["applicationSid"] !== undefined) data["ApplicationSid"] = params["applicationSid"];
        if (params["maxPrice"] !== undefined) data["MaxPrice"] = params["maxPrice"];
        if (params["provideFeedback"] !== undefined) data["ProvideFeedback"] = serialize.bool(params["provideFeedback"]);
        if (params["attempt"] !== undefined) data["Attempt"] = params["attempt"];
        if (params["validityPeriod"] !== undefined) data["ValidityPeriod"] = params["validityPeriod"];
        if (params["forceDelivery"] !== undefined) data["ForceDelivery"] = serialize.bool(params["forceDelivery"]);
        if (params["contentRetention"] !== undefined) data["ContentRetention"] = params["contentRetention"];
        if (params["addressRetention"] !== undefined) data["AddressRetention"] = params["addressRetention"];
        if (params["smartEncoded"] !== undefined) data["SmartEncoded"] = serialize.bool(params["smartEncoded"]);
        if (params["persistentAction"] !== undefined) data["PersistentAction"] = serialize.map(params["persistentAction"], (e)=>e);
        if (params["trafficType"] !== undefined) data["TrafficType"] = params["trafficType"];
        if (params["shortenUrls"] !== undefined) data["ShortenUrls"] = serialize.bool(params["shortenUrls"]);
        if (params["scheduleType"] !== undefined) data["ScheduleType"] = params["scheduleType"];
        if (params["sendAt"] !== undefined) data["SendAt"] = serialize.iso8601DateTime(params["sendAt"]);
        if (params["sendAsMms"] !== undefined) data["SendAsMms"] = serialize.bool(params["sendAsMms"]);
        if (params["contentVariables"] !== undefined) data["ContentVariables"] = params["contentVariables"];
        if (params["riskCheck"] !== undefined) data["RiskCheck"] = params["riskCheck"];
        if (params["from"] !== undefined) data["From"] = params["from"];
        if (params["messagingServiceSid"] !== undefined) data["MessagingServiceSid"] = params["messagingServiceSid"];
        if (params["body"] !== undefined) data["Body"] = params["body"];
        if (params["mediaUrl"] !== undefined) data["MediaUrl"] = serialize.map(params["mediaUrl"], (e)=>e);
        if (params["contentSid"] !== undefined) data["ContentSid"] = params["contentSid"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.create({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new MessageInstance(operationVersion, payload, instance._solution.accountSid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.createWithHttpInfo = function createWithHttpInfo(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["to"] === null || params["to"] === undefined) {
            throw new Error("Required parameter \"params['to']\" missing.");
        }
        let data = {};
        data["To"] = params["to"];
        if (params["statusCallback"] !== undefined) data["StatusCallback"] = params["statusCallback"];
        if (params["applicationSid"] !== undefined) data["ApplicationSid"] = params["applicationSid"];
        if (params["maxPrice"] !== undefined) data["MaxPrice"] = params["maxPrice"];
        if (params["provideFeedback"] !== undefined) data["ProvideFeedback"] = serialize.bool(params["provideFeedback"]);
        if (params["attempt"] !== undefined) data["Attempt"] = params["attempt"];
        if (params["validityPeriod"] !== undefined) data["ValidityPeriod"] = params["validityPeriod"];
        if (params["forceDelivery"] !== undefined) data["ForceDelivery"] = serialize.bool(params["forceDelivery"]);
        if (params["contentRetention"] !== undefined) data["ContentRetention"] = params["contentRetention"];
        if (params["addressRetention"] !== undefined) data["AddressRetention"] = params["addressRetention"];
        if (params["smartEncoded"] !== undefined) data["SmartEncoded"] = serialize.bool(params["smartEncoded"]);
        if (params["persistentAction"] !== undefined) data["PersistentAction"] = serialize.map(params["persistentAction"], (e)=>e);
        if (params["trafficType"] !== undefined) data["TrafficType"] = params["trafficType"];
        if (params["shortenUrls"] !== undefined) data["ShortenUrls"] = serialize.bool(params["shortenUrls"]);
        if (params["scheduleType"] !== undefined) data["ScheduleType"] = params["scheduleType"];
        if (params["sendAt"] !== undefined) data["SendAt"] = serialize.iso8601DateTime(params["sendAt"]);
        if (params["sendAsMms"] !== undefined) data["SendAsMms"] = serialize.bool(params["sendAsMms"]);
        if (params["contentVariables"] !== undefined) data["ContentVariables"] = params["contentVariables"];
        if (params["riskCheck"] !== undefined) data["RiskCheck"] = params["riskCheck"];
        if (params["from"] !== undefined) data["From"] = params["from"];
        if (params["messagingServiceSid"] !== undefined) data["MessagingServiceSid"] = params["messagingServiceSid"];
        if (params["body"] !== undefined) data["Body"] = params["body"];
        if (params["mediaUrl"] !== undefined) data["MediaUrl"] = serialize.map(params["mediaUrl"], (e)=>e);
        if (params["contentSid"] !== undefined) data["ContentSid"] = params["contentSid"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.createWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new MessageInstance(operationVersion, response.body, instance._solution.accountSid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["to"] !== undefined) data["To"] = params["to"];
        if (params["from"] !== undefined) data["From"] = params["from"];
        if (params["dateSent"] !== undefined) data["DateSent"] = serialize.iso8601DateTime(params["dateSent"]);
        if (params["dateSentBefore"] !== undefined) data["DateSent<"] = serialize.iso8601DateTime(params["dateSentBefore"]);
        if (params["dateSentAfter"] !== undefined) data["DateSent>"] = serialize.iso8601DateTime(params["dateSentAfter"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new MessagePage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new MessagePage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["to"] !== undefined) data["To"] = params["to"];
        if (params["from"] !== undefined) data["From"] = params["from"];
        if (params["dateSent"] !== undefined) data["DateSent"] = serialize.iso8601DateTime(params["dateSent"]);
        if (params["dateSentBefore"] !== undefined) data["DateSent<"] = serialize.iso8601DateTime(params["dateSentBefore"]);
        if (params["dateSentAfter"] !== undefined) data["DateSent>"] = serialize.iso8601DateTime(params["dateSentAfter"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new MessagePage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new MessagePage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class MessagePage extends Page_1.default {
    /**
     * Initialize the MessagePage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of MessageInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new MessageInstance(this._version, payload, this._solution.accountSid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.MessagePage = MessagePage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/newKey.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NewKeyInstance = void 0;
exports.NewKeyListInstance = NewKeyListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
function NewKeyListInstance(version, accountSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    const instance = {};
    instance._version = version;
    instance._solution = {
        accountSid
    };
    instance._uri = `/Accounts/${accountSid}/Keys.json`;
    instance.create = function create(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.create({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new NewKeyInstance(operationVersion, payload, instance._solution.accountSid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.createWithHttpInfo = function createWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.createWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new NewKeyInstance(operationVersion, response.body, instance._solution.accountSid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class NewKeyInstance {
    constructor(_version, payload, accountSid){
        this._version = _version;
        this.sid = payload.sid;
        this.friendlyName = payload.friendly_name;
        this.dateCreated = deserialize.rfc2822DateTime(payload.date_created);
        this.dateUpdated = deserialize.rfc2822DateTime(payload.date_updated);
        this.secret = payload.secret;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            sid: this.sid,
            friendlyName: this.friendlyName,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated,
            secret: this.secret
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.NewKeyInstance = NewKeyInstance;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/newSigningKey.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NewSigningKeyInstance = void 0;
exports.NewSigningKeyListInstance = NewSigningKeyListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
function NewSigningKeyListInstance(version, accountSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    const instance = {};
    instance._version = version;
    instance._solution = {
        accountSid
    };
    instance._uri = `/Accounts/${accountSid}/SigningKeys.json`;
    instance.create = function create(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.create({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new NewSigningKeyInstance(operationVersion, payload, instance._solution.accountSid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.createWithHttpInfo = function createWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.createWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new NewSigningKeyInstance(operationVersion, response.body, instance._solution.accountSid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class NewSigningKeyInstance {
    constructor(_version, payload, accountSid){
        this._version = _version;
        this.sid = payload.sid;
        this.friendlyName = payload.friendly_name;
        this.dateCreated = deserialize.rfc2822DateTime(payload.date_created);
        this.dateUpdated = deserialize.rfc2822DateTime(payload.date_updated);
        this.secret = payload.secret;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            sid: this.sid,
            friendlyName: this.friendlyName,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated,
            secret: this.secret
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.NewSigningKeyInstance = NewSigningKeyInstance;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/notification.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NotificationPage = exports.NotificationInstance = exports.NotificationContextImpl = void 0;
exports.NotificationListInstance = NotificationListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
class NotificationContextImpl {
    constructor(_version, accountSid, sid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(accountSid)) {
            throw new Error("Parameter 'accountSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(sid)) {
            throw new Error("Parameter 'sid' is not valid.");
        }
        this._solution = {
            accountSid,
            sid
        };
        this._uri = `/Accounts/${accountSid}/Notifications/${sid}.json`;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new NotificationInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new NotificationInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.NotificationContextImpl = NotificationContextImpl;
class NotificationInstance {
    constructor(_version, payload, accountSid, sid){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.apiVersion = payload.api_version;
        this.callSid = payload.call_sid;
        this.dateCreated = deserialize.rfc2822DateTime(payload.date_created);
        this.dateUpdated = deserialize.rfc2822DateTime(payload.date_updated);
        this.errorCode = payload.error_code;
        this.log = payload.log;
        this.messageDate = deserialize.rfc2822DateTime(payload.message_date);
        this.messageText = payload.message_text;
        this.moreInfo = payload.more_info;
        this.requestMethod = payload.request_method;
        this.requestUrl = payload.request_url;
        this.requestVariables = payload.request_variables;
        this.responseBody = payload.response_body;
        this.responseHeaders = payload.response_headers;
        this.sid = payload.sid;
        this.uri = payload.uri;
        this._solution = {
            accountSid,
            sid: sid || this.sid
        };
    }
    get _proxy() {
        this._context = this._context || new NotificationContextImpl(this._version, this._solution.accountSid, this._solution.sid);
        return this._context;
    }
    /**
     * Fetch a NotificationInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed NotificationInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a NotificationInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed NotificationInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            apiVersion: this.apiVersion,
            callSid: this.callSid,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated,
            errorCode: this.errorCode,
            log: this.log,
            messageDate: this.messageDate,
            messageText: this.messageText,
            moreInfo: this.moreInfo,
            requestMethod: this.requestMethod,
            requestUrl: this.requestUrl,
            requestVariables: this.requestVariables,
            responseBody: this.responseBody,
            responseHeaders: this.responseHeaders,
            sid: this.sid,
            uri: this.uri
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.NotificationInstance = NotificationInstance;
function NotificationListInstance(version, accountSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    const instance = (sid)=>instance.get(sid);
    instance.get = function get(sid) {
        return new NotificationContextImpl(version, accountSid, sid);
    };
    instance._version = version;
    instance._solution = {
        accountSid
    };
    instance._uri = `/Accounts/${accountSid}/Notifications.json`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["log"] !== undefined) data["Log"] = params["log"];
        if (params["messageDate"] !== undefined) data["MessageDate"] = serialize.iso8601Date(params["messageDate"]);
        if (params["messageDateBefore"] !== undefined) data["MessageDate<"] = serialize.iso8601Date(params["messageDateBefore"]);
        if (params["messageDateAfter"] !== undefined) data["MessageDate>"] = serialize.iso8601Date(params["messageDateAfter"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new NotificationPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new NotificationPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["log"] !== undefined) data["Log"] = params["log"];
        if (params["messageDate"] !== undefined) data["MessageDate"] = serialize.iso8601Date(params["messageDate"]);
        if (params["messageDateBefore"] !== undefined) data["MessageDate<"] = serialize.iso8601Date(params["messageDateBefore"]);
        if (params["messageDateAfter"] !== undefined) data["MessageDate>"] = serialize.iso8601Date(params["messageDateAfter"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new NotificationPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new NotificationPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class NotificationPage extends Page_1.default {
    /**
     * Initialize the NotificationPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of NotificationInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new NotificationInstance(this._version, payload, this._solution.accountSid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.NotificationPage = NotificationPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/outgoingCallerId.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OutgoingCallerIdPage = exports.OutgoingCallerIdInstance = exports.OutgoingCallerIdContextImpl = void 0;
exports.OutgoingCallerIdListInstance = OutgoingCallerIdListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
class OutgoingCallerIdContextImpl {
    constructor(_version, accountSid, sid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(accountSid)) {
            throw new Error("Parameter 'accountSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(sid)) {
            throw new Error("Parameter 'sid' is not valid.");
        }
        this._solution = {
            accountSid,
            sid
        };
        this._uri = `/Accounts/${accountSid}/OutgoingCallerIds/${sid}.json`;
    }
    remove(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.remove({
            uri: instance._uri,
            method: "delete",
            headers
        });
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    removeWithHttpInfo(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version;
        // DELETE operation - returns boolean based on status code
        let operationPromise = operationVersion.removeWithResponseInfo({
            uri: instance._uri,
            method: "delete",
            headers
        }).then((response)=>({
                ...response,
                body: response.statusCode === 204
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new OutgoingCallerIdInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new OutgoingCallerIdInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    update(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.update({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new OutgoingCallerIdInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    updateWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.updateWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new OutgoingCallerIdInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.OutgoingCallerIdContextImpl = OutgoingCallerIdContextImpl;
class OutgoingCallerIdInstance {
    constructor(_version, payload, accountSid, sid){
        this._version = _version;
        this.sid = payload.sid;
        this.dateCreated = deserialize.rfc2822DateTime(payload.date_created);
        this.dateUpdated = deserialize.rfc2822DateTime(payload.date_updated);
        this.friendlyName = payload.friendly_name;
        this.accountSid = payload.account_sid;
        this.phoneNumber = payload.phone_number;
        this.uri = payload.uri;
        this._solution = {
            accountSid,
            sid: sid || this.sid
        };
    }
    get _proxy() {
        this._context = this._context || new OutgoingCallerIdContextImpl(this._version, this._solution.accountSid, this._solution.sid);
        return this._context;
    }
    /**
     * Remove a OutgoingCallerIdInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean
     */ remove(callback) {
        return this._proxy.remove(callback);
    }
    /**
     * Remove a OutgoingCallerIdInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean with HTTP metadata
     */ removeWithHttpInfo(callback) {
        return this._proxy.removeWithHttpInfo(callback);
    }
    /**
     * Fetch a OutgoingCallerIdInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed OutgoingCallerIdInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a OutgoingCallerIdInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed OutgoingCallerIdInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    update(params, callback) {
        return this._proxy.update(params, callback);
    }
    updateWithHttpInfo(params, callback) {
        return this._proxy.updateWithHttpInfo(params, callback);
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            sid: this.sid,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated,
            friendlyName: this.friendlyName,
            accountSid: this.accountSid,
            phoneNumber: this.phoneNumber,
            uri: this.uri
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.OutgoingCallerIdInstance = OutgoingCallerIdInstance;
function OutgoingCallerIdListInstance(version, accountSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    const instance = (sid)=>instance.get(sid);
    instance.get = function get(sid) {
        return new OutgoingCallerIdContextImpl(version, accountSid, sid);
    };
    instance._version = version;
    instance._solution = {
        accountSid
    };
    instance._uri = `/Accounts/${accountSid}/OutgoingCallerIds.json`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["phoneNumber"] !== undefined) data["PhoneNumber"] = params["phoneNumber"];
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new OutgoingCallerIdPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new OutgoingCallerIdPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["phoneNumber"] !== undefined) data["PhoneNumber"] = params["phoneNumber"];
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new OutgoingCallerIdPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new OutgoingCallerIdPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class OutgoingCallerIdPage extends Page_1.default {
    /**
     * Initialize the OutgoingCallerIdPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of OutgoingCallerIdInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new OutgoingCallerIdInstance(this._version, payload, this._solution.accountSid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.OutgoingCallerIdPage = OutgoingCallerIdPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/queue/member.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MemberPage = exports.MemberInstance = exports.MemberContextImpl = void 0;
exports.MemberListInstance = MemberListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
class MemberContextImpl {
    constructor(_version, accountSid, queueSid, callSid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(accountSid)) {
            throw new Error("Parameter 'accountSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(queueSid)) {
            throw new Error("Parameter 'queueSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(callSid)) {
            throw new Error("Parameter 'callSid' is not valid.");
        }
        this._solution = {
            accountSid,
            queueSid,
            callSid
        };
        this._uri = `/Accounts/${accountSid}/Queues/${queueSid}/Members/${callSid}.json`;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new MemberInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.queueSid, instance._solution.callSid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new MemberInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.queueSid, instance._solution.callSid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    update(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["url"] === null || params["url"] === undefined) {
            throw new Error("Required parameter \"params['url']\" missing.");
        }
        let data = {};
        data["Url"] = params["url"];
        if (params["method"] !== undefined) data["Method"] = params["method"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.update({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new MemberInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.queueSid, instance._solution.callSid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    updateWithHttpInfo(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["url"] === null || params["url"] === undefined) {
            throw new Error("Required parameter \"params['url']\" missing.");
        }
        let data = {};
        data["Url"] = params["url"];
        if (params["method"] !== undefined) data["Method"] = params["method"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.updateWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new MemberInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.queueSid, instance._solution.callSid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.MemberContextImpl = MemberContextImpl;
class MemberInstance {
    constructor(_version, payload, accountSid, queueSid, callSid){
        this._version = _version;
        this.callSid = payload.call_sid;
        this.dateEnqueued = deserialize.rfc2822DateTime(payload.date_enqueued);
        this.position = deserialize.integer(payload.position);
        this.uri = payload.uri;
        this.waitTime = deserialize.integer(payload.wait_time);
        this.queueSid = payload.queue_sid;
        this._solution = {
            accountSid,
            queueSid,
            callSid: callSid || this.callSid
        };
    }
    get _proxy() {
        this._context = this._context || new MemberContextImpl(this._version, this._solution.accountSid, this._solution.queueSid, this._solution.callSid);
        return this._context;
    }
    /**
     * Fetch a MemberInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed MemberInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a MemberInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed MemberInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    update(params, callback) {
        return this._proxy.update(params, callback);
    }
    updateWithHttpInfo(params, callback) {
        return this._proxy.updateWithHttpInfo(params, callback);
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            callSid: this.callSid,
            dateEnqueued: this.dateEnqueued,
            position: this.position,
            uri: this.uri,
            waitTime: this.waitTime,
            queueSid: this.queueSid
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.MemberInstance = MemberInstance;
function MemberListInstance(version, accountSid, queueSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    if (!(0, utility_1.isValidPathParam)(queueSid)) {
        throw new Error("Parameter 'queueSid' is not valid.");
    }
    const instance = (callSid)=>instance.get(callSid);
    instance.get = function get(callSid) {
        return new MemberContextImpl(version, accountSid, queueSid, callSid);
    };
    instance._version = version;
    instance._solution = {
        accountSid,
        queueSid
    };
    instance._uri = `/Accounts/${accountSid}/Queues/${queueSid}/Members.json`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new MemberPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new MemberPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new MemberPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new MemberPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class MemberPage extends Page_1.default {
    /**
     * Initialize the MemberPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of MemberInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new MemberInstance(this._version, payload, this._solution.accountSid, this._solution.queueSid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.MemberPage = MemberPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/queue.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.QueuePage = exports.QueueInstance = exports.QueueContextImpl = void 0;
exports.QueueListInstance = QueueListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
const member_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/queue/member.js [app-route] (ecmascript)");
class QueueContextImpl {
    constructor(_version, accountSid, sid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(accountSid)) {
            throw new Error("Parameter 'accountSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(sid)) {
            throw new Error("Parameter 'sid' is not valid.");
        }
        this._solution = {
            accountSid,
            sid
        };
        this._uri = `/Accounts/${accountSid}/Queues/${sid}.json`;
    }
    get members() {
        this._members = this._members || (0, member_1.MemberListInstance)(this._version, this._solution.accountSid, this._solution.sid);
        return this._members;
    }
    remove(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.remove({
            uri: instance._uri,
            method: "delete",
            headers
        });
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    removeWithHttpInfo(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version;
        // DELETE operation - returns boolean based on status code
        let operationPromise = operationVersion.removeWithResponseInfo({
            uri: instance._uri,
            method: "delete",
            headers
        }).then((response)=>({
                ...response,
                body: response.statusCode === 204
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new QueueInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new QueueInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    update(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["maxSize"] !== undefined) data["MaxSize"] = params["maxSize"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.update({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new QueueInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    updateWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["maxSize"] !== undefined) data["MaxSize"] = params["maxSize"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.updateWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new QueueInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.QueueContextImpl = QueueContextImpl;
class QueueInstance {
    constructor(_version, payload, accountSid, sid){
        this._version = _version;
        this.dateUpdated = deserialize.rfc2822DateTime(payload.date_updated);
        this.currentSize = deserialize.integer(payload.current_size);
        this.friendlyName = payload.friendly_name;
        this.uri = payload.uri;
        this.accountSid = payload.account_sid;
        this.averageWaitTime = deserialize.integer(payload.average_wait_time);
        this.sid = payload.sid;
        this.dateCreated = deserialize.rfc2822DateTime(payload.date_created);
        this.maxSize = deserialize.integer(payload.max_size);
        this._solution = {
            accountSid,
            sid: sid || this.sid
        };
    }
    get _proxy() {
        this._context = this._context || new QueueContextImpl(this._version, this._solution.accountSid, this._solution.sid);
        return this._context;
    }
    /**
     * Remove a QueueInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean
     */ remove(callback) {
        return this._proxy.remove(callback);
    }
    /**
     * Remove a QueueInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean with HTTP metadata
     */ removeWithHttpInfo(callback) {
        return this._proxy.removeWithHttpInfo(callback);
    }
    /**
     * Fetch a QueueInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed QueueInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a QueueInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed QueueInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    update(params, callback) {
        return this._proxy.update(params, callback);
    }
    updateWithHttpInfo(params, callback) {
        return this._proxy.updateWithHttpInfo(params, callback);
    }
    /**
     * Access the members.
     */ members() {
        return this._proxy.members;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            dateUpdated: this.dateUpdated,
            currentSize: this.currentSize,
            friendlyName: this.friendlyName,
            uri: this.uri,
            accountSid: this.accountSid,
            averageWaitTime: this.averageWaitTime,
            sid: this.sid,
            dateCreated: this.dateCreated,
            maxSize: this.maxSize
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.QueueInstance = QueueInstance;
function QueueListInstance(version, accountSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    const instance = (sid)=>instance.get(sid);
    instance.get = function get(sid) {
        return new QueueContextImpl(version, accountSid, sid);
    };
    instance._version = version;
    instance._solution = {
        accountSid
    };
    instance._uri = `/Accounts/${accountSid}/Queues.json`;
    instance.create = function create(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["friendlyName"] === null || params["friendlyName"] === undefined) {
            throw new Error("Required parameter \"params['friendlyName']\" missing.");
        }
        let data = {};
        data["FriendlyName"] = params["friendlyName"];
        if (params["maxSize"] !== undefined) data["MaxSize"] = params["maxSize"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.create({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new QueueInstance(operationVersion, payload, instance._solution.accountSid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.createWithHttpInfo = function createWithHttpInfo(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["friendlyName"] === null || params["friendlyName"] === undefined) {
            throw new Error("Required parameter \"params['friendlyName']\" missing.");
        }
        let data = {};
        data["FriendlyName"] = params["friendlyName"];
        if (params["maxSize"] !== undefined) data["MaxSize"] = params["maxSize"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.createWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new QueueInstance(operationVersion, response.body, instance._solution.accountSid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new QueuePage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new QueuePage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new QueuePage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new QueuePage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class QueuePage extends Page_1.default {
    /**
     * Initialize the QueuePage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of QueueInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new QueueInstance(this._version, payload, this._solution.accountSid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.QueuePage = QueuePage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/recording/addOnResult/payload/data.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DataInstance = exports.DataContextImpl = void 0;
exports.DataListInstance = DataListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
class DataContextImpl {
    constructor(_version, accountSid, referenceSid, addOnResultSid, payloadSid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(accountSid)) {
            throw new Error("Parameter 'accountSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(referenceSid)) {
            throw new Error("Parameter 'referenceSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(addOnResultSid)) {
            throw new Error("Parameter 'addOnResultSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(payloadSid)) {
            throw new Error("Parameter 'payloadSid' is not valid.");
        }
        this._solution = {
            accountSid,
            referenceSid,
            addOnResultSid,
            payloadSid
        };
        this._uri = `/Accounts/${accountSid}/Recordings/${referenceSid}/AddOnResults/${addOnResultSid}/Payloads/${payloadSid}/Data.json`;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new DataInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.referenceSid, instance._solution.addOnResultSid, instance._solution.payloadSid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new DataInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.referenceSid, instance._solution.addOnResultSid, instance._solution.payloadSid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.DataContextImpl = DataContextImpl;
class DataInstance {
    constructor(_version, payload, accountSid, referenceSid, addOnResultSid, payloadSid){
        this._version = _version;
        this.redirectTo = payload.redirect_to;
        this._solution = {
            accountSid,
            referenceSid,
            addOnResultSid,
            payloadSid
        };
    }
    get _proxy() {
        this._context = this._context || new DataContextImpl(this._version, this._solution.accountSid, this._solution.referenceSid, this._solution.addOnResultSid, this._solution.payloadSid);
        return this._context;
    }
    /**
     * Fetch a DataInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed DataInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a DataInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed DataInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            redirectTo: this.redirectTo
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.DataInstance = DataInstance;
function DataListInstance(version, accountSid, referenceSid, addOnResultSid, payloadSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    if (!(0, utility_1.isValidPathParam)(referenceSid)) {
        throw new Error("Parameter 'referenceSid' is not valid.");
    }
    if (!(0, utility_1.isValidPathParam)(addOnResultSid)) {
        throw new Error("Parameter 'addOnResultSid' is not valid.");
    }
    if (!(0, utility_1.isValidPathParam)(payloadSid)) {
        throw new Error("Parameter 'payloadSid' is not valid.");
    }
    const instance = ()=>instance.get();
    instance.get = function get() {
        return new DataContextImpl(version, accountSid, referenceSid, addOnResultSid, payloadSid);
    };
    instance._version = version;
    instance._solution = {
        accountSid,
        referenceSid,
        addOnResultSid,
        payloadSid
    };
    instance._uri = ``;
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/recording/addOnResult/payload.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PayloadPage = exports.PayloadInstance = exports.PayloadContextImpl = void 0;
exports.PayloadListInstance = PayloadListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
const data_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/recording/addOnResult/payload/data.js [app-route] (ecmascript)");
class PayloadContextImpl {
    constructor(_version, accountSid, referenceSid, addOnResultSid, sid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(accountSid)) {
            throw new Error("Parameter 'accountSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(referenceSid)) {
            throw new Error("Parameter 'referenceSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(addOnResultSid)) {
            throw new Error("Parameter 'addOnResultSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(sid)) {
            throw new Error("Parameter 'sid' is not valid.");
        }
        this._solution = {
            accountSid,
            referenceSid,
            addOnResultSid,
            sid
        };
        this._uri = `/Accounts/${accountSid}/Recordings/${referenceSid}/AddOnResults/${addOnResultSid}/Payloads/${sid}.json`;
    }
    get data() {
        this._data = this._data || (0, data_1.DataListInstance)(this._version, this._solution.accountSid, this._solution.referenceSid, this._solution.addOnResultSid, this._solution.sid);
        return this._data;
    }
    remove(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.remove({
            uri: instance._uri,
            method: "delete",
            headers
        });
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    removeWithHttpInfo(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version;
        // DELETE operation - returns boolean based on status code
        let operationPromise = operationVersion.removeWithResponseInfo({
            uri: instance._uri,
            method: "delete",
            headers
        }).then((response)=>({
                ...response,
                body: response.statusCode === 204
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new PayloadInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.referenceSid, instance._solution.addOnResultSid, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new PayloadInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.referenceSid, instance._solution.addOnResultSid, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.PayloadContextImpl = PayloadContextImpl;
class PayloadInstance {
    constructor(_version, payload, accountSid, referenceSid, addOnResultSid, sid){
        this._version = _version;
        this.sid = payload.sid;
        this.addOnResultSid = payload.add_on_result_sid;
        this.accountSid = payload.account_sid;
        this.label = payload.label;
        this.addOnSid = payload.add_on_sid;
        this.addOnConfigurationSid = payload.add_on_configuration_sid;
        this.contentType = payload.content_type;
        this.dateCreated = deserialize.rfc2822DateTime(payload.date_created);
        this.dateUpdated = deserialize.rfc2822DateTime(payload.date_updated);
        this.referenceSid = payload.reference_sid;
        this.subresourceUris = payload.subresource_uris;
        this._solution = {
            accountSid,
            referenceSid,
            addOnResultSid,
            sid: sid || this.sid
        };
    }
    get _proxy() {
        this._context = this._context || new PayloadContextImpl(this._version, this._solution.accountSid, this._solution.referenceSid, this._solution.addOnResultSid, this._solution.sid);
        return this._context;
    }
    /**
     * Remove a PayloadInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean
     */ remove(callback) {
        return this._proxy.remove(callback);
    }
    /**
     * Remove a PayloadInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean with HTTP metadata
     */ removeWithHttpInfo(callback) {
        return this._proxy.removeWithHttpInfo(callback);
    }
    /**
     * Fetch a PayloadInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed PayloadInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a PayloadInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed PayloadInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    /**
     * Access the data.
     */ data() {
        return this._proxy.data;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            sid: this.sid,
            addOnResultSid: this.addOnResultSid,
            accountSid: this.accountSid,
            label: this.label,
            addOnSid: this.addOnSid,
            addOnConfigurationSid: this.addOnConfigurationSid,
            contentType: this.contentType,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated,
            referenceSid: this.referenceSid,
            subresourceUris: this.subresourceUris
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.PayloadInstance = PayloadInstance;
function PayloadListInstance(version, accountSid, referenceSid, addOnResultSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    if (!(0, utility_1.isValidPathParam)(referenceSid)) {
        throw new Error("Parameter 'referenceSid' is not valid.");
    }
    if (!(0, utility_1.isValidPathParam)(addOnResultSid)) {
        throw new Error("Parameter 'addOnResultSid' is not valid.");
    }
    const instance = (sid)=>instance.get(sid);
    instance.get = function get(sid) {
        return new PayloadContextImpl(version, accountSid, referenceSid, addOnResultSid, sid);
    };
    instance._version = version;
    instance._solution = {
        accountSid,
        referenceSid,
        addOnResultSid
    };
    instance._uri = `/Accounts/${accountSid}/Recordings/${referenceSid}/AddOnResults/${addOnResultSid}/Payloads.json`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new PayloadPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new PayloadPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new PayloadPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new PayloadPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class PayloadPage extends Page_1.default {
    /**
     * Initialize the PayloadPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of PayloadInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new PayloadInstance(this._version, payload, this._solution.accountSid, this._solution.referenceSid, this._solution.addOnResultSid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.PayloadPage = PayloadPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/recording/addOnResult.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AddOnResultPage = exports.AddOnResultInstance = exports.AddOnResultContextImpl = void 0;
exports.AddOnResultListInstance = AddOnResultListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
const payload_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/recording/addOnResult/payload.js [app-route] (ecmascript)");
class AddOnResultContextImpl {
    constructor(_version, accountSid, referenceSid, sid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(accountSid)) {
            throw new Error("Parameter 'accountSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(referenceSid)) {
            throw new Error("Parameter 'referenceSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(sid)) {
            throw new Error("Parameter 'sid' is not valid.");
        }
        this._solution = {
            accountSid,
            referenceSid,
            sid
        };
        this._uri = `/Accounts/${accountSid}/Recordings/${referenceSid}/AddOnResults/${sid}.json`;
    }
    get payloads() {
        this._payloads = this._payloads || (0, payload_1.PayloadListInstance)(this._version, this._solution.accountSid, this._solution.referenceSid, this._solution.sid);
        return this._payloads;
    }
    remove(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.remove({
            uri: instance._uri,
            method: "delete",
            headers
        });
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    removeWithHttpInfo(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version;
        // DELETE operation - returns boolean based on status code
        let operationPromise = operationVersion.removeWithResponseInfo({
            uri: instance._uri,
            method: "delete",
            headers
        }).then((response)=>({
                ...response,
                body: response.statusCode === 204
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new AddOnResultInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.referenceSid, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new AddOnResultInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.referenceSid, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.AddOnResultContextImpl = AddOnResultContextImpl;
class AddOnResultInstance {
    constructor(_version, payload, accountSid, referenceSid, sid){
        this._version = _version;
        this.sid = payload.sid;
        this.accountSid = payload.account_sid;
        this.status = payload.status;
        this.addOnSid = payload.add_on_sid;
        this.addOnConfigurationSid = payload.add_on_configuration_sid;
        this.dateCreated = deserialize.rfc2822DateTime(payload.date_created);
        this.dateUpdated = deserialize.rfc2822DateTime(payload.date_updated);
        this.dateCompleted = deserialize.rfc2822DateTime(payload.date_completed);
        this.referenceSid = payload.reference_sid;
        this.subresourceUris = payload.subresource_uris;
        this._solution = {
            accountSid,
            referenceSid,
            sid: sid || this.sid
        };
    }
    get _proxy() {
        this._context = this._context || new AddOnResultContextImpl(this._version, this._solution.accountSid, this._solution.referenceSid, this._solution.sid);
        return this._context;
    }
    /**
     * Remove a AddOnResultInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean
     */ remove(callback) {
        return this._proxy.remove(callback);
    }
    /**
     * Remove a AddOnResultInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean with HTTP metadata
     */ removeWithHttpInfo(callback) {
        return this._proxy.removeWithHttpInfo(callback);
    }
    /**
     * Fetch a AddOnResultInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed AddOnResultInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a AddOnResultInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed AddOnResultInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    /**
     * Access the payloads.
     */ payloads() {
        return this._proxy.payloads;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            sid: this.sid,
            accountSid: this.accountSid,
            status: this.status,
            addOnSid: this.addOnSid,
            addOnConfigurationSid: this.addOnConfigurationSid,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated,
            dateCompleted: this.dateCompleted,
            referenceSid: this.referenceSid,
            subresourceUris: this.subresourceUris
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.AddOnResultInstance = AddOnResultInstance;
function AddOnResultListInstance(version, accountSid, referenceSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    if (!(0, utility_1.isValidPathParam)(referenceSid)) {
        throw new Error("Parameter 'referenceSid' is not valid.");
    }
    const instance = (sid)=>instance.get(sid);
    instance.get = function get(sid) {
        return new AddOnResultContextImpl(version, accountSid, referenceSid, sid);
    };
    instance._version = version;
    instance._solution = {
        accountSid,
        referenceSid
    };
    instance._uri = `/Accounts/${accountSid}/Recordings/${referenceSid}/AddOnResults.json`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new AddOnResultPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new AddOnResultPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new AddOnResultPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new AddOnResultPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class AddOnResultPage extends Page_1.default {
    /**
     * Initialize the AddOnResultPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of AddOnResultInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new AddOnResultInstance(this._version, payload, this._solution.accountSid, this._solution.referenceSid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.AddOnResultPage = AddOnResultPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/recording/transcription.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TranscriptionPage = exports.TranscriptionInstance = exports.TranscriptionContextImpl = void 0;
exports.TranscriptionListInstance = TranscriptionListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
class TranscriptionContextImpl {
    constructor(_version, accountSid, recordingSid, sid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(accountSid)) {
            throw new Error("Parameter 'accountSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(recordingSid)) {
            throw new Error("Parameter 'recordingSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(sid)) {
            throw new Error("Parameter 'sid' is not valid.");
        }
        this._solution = {
            accountSid,
            recordingSid,
            sid
        };
        this._uri = `/Accounts/${accountSid}/Recordings/${recordingSid}/Transcriptions/${sid}.json`;
    }
    remove(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.remove({
            uri: instance._uri,
            method: "delete",
            headers
        });
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    removeWithHttpInfo(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version;
        // DELETE operation - returns boolean based on status code
        let operationPromise = operationVersion.removeWithResponseInfo({
            uri: instance._uri,
            method: "delete",
            headers
        }).then((response)=>({
                ...response,
                body: response.statusCode === 204
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new TranscriptionInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.recordingSid, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new TranscriptionInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.recordingSid, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.TranscriptionContextImpl = TranscriptionContextImpl;
class TranscriptionInstance {
    constructor(_version, payload, accountSid, recordingSid, sid){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.apiVersion = payload.api_version;
        this.dateCreated = deserialize.rfc2822DateTime(payload.date_created);
        this.dateUpdated = deserialize.rfc2822DateTime(payload.date_updated);
        this.duration = payload.duration;
        this.price = payload.price;
        this.priceUnit = payload.price_unit;
        this.recordingSid = payload.recording_sid;
        this.sid = payload.sid;
        this.status = payload.status;
        this.transcriptionText = payload.transcription_text;
        this.type = payload.type;
        this.uri = payload.uri;
        this._solution = {
            accountSid,
            recordingSid,
            sid: sid || this.sid
        };
    }
    get _proxy() {
        this._context = this._context || new TranscriptionContextImpl(this._version, this._solution.accountSid, this._solution.recordingSid, this._solution.sid);
        return this._context;
    }
    /**
     * Remove a TranscriptionInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean
     */ remove(callback) {
        return this._proxy.remove(callback);
    }
    /**
     * Remove a TranscriptionInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean with HTTP metadata
     */ removeWithHttpInfo(callback) {
        return this._proxy.removeWithHttpInfo(callback);
    }
    /**
     * Fetch a TranscriptionInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed TranscriptionInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a TranscriptionInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed TranscriptionInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            apiVersion: this.apiVersion,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated,
            duration: this.duration,
            price: this.price,
            priceUnit: this.priceUnit,
            recordingSid: this.recordingSid,
            sid: this.sid,
            status: this.status,
            transcriptionText: this.transcriptionText,
            type: this.type,
            uri: this.uri
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.TranscriptionInstance = TranscriptionInstance;
function TranscriptionListInstance(version, accountSid, recordingSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    if (!(0, utility_1.isValidPathParam)(recordingSid)) {
        throw new Error("Parameter 'recordingSid' is not valid.");
    }
    const instance = (sid)=>instance.get(sid);
    instance.get = function get(sid) {
        return new TranscriptionContextImpl(version, accountSid, recordingSid, sid);
    };
    instance._version = version;
    instance._solution = {
        accountSid,
        recordingSid
    };
    instance._uri = `/Accounts/${accountSid}/Recordings/${recordingSid}/Transcriptions.json`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new TranscriptionPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new TranscriptionPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new TranscriptionPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new TranscriptionPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class TranscriptionPage extends Page_1.default {
    /**
     * Initialize the TranscriptionPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of TranscriptionInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new TranscriptionInstance(this._version, payload, this._solution.accountSid, this._solution.recordingSid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.TranscriptionPage = TranscriptionPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/recording.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RecordingPage = exports.RecordingInstance = exports.RecordingContextImpl = void 0;
exports.RecordingListInstance = RecordingListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
const addOnResult_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/recording/addOnResult.js [app-route] (ecmascript)");
const transcription_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/recording/transcription.js [app-route] (ecmascript)");
class RecordingContextImpl {
    constructor(_version, accountSid, sid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(accountSid)) {
            throw new Error("Parameter 'accountSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(sid)) {
            throw new Error("Parameter 'sid' is not valid.");
        }
        this._solution = {
            accountSid,
            sid
        };
        this._uri = `/Accounts/${accountSid}/Recordings/${sid}.json`;
    }
    get addOnResults() {
        this._addOnResults = this._addOnResults || (0, addOnResult_1.AddOnResultListInstance)(this._version, this._solution.accountSid, this._solution.sid);
        return this._addOnResults;
    }
    get transcriptions() {
        this._transcriptions = this._transcriptions || (0, transcription_1.TranscriptionListInstance)(this._version, this._solution.accountSid, this._solution.sid);
        return this._transcriptions;
    }
    remove(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.remove({
            uri: instance._uri,
            method: "delete",
            headers
        });
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    removeWithHttpInfo(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version;
        // DELETE operation - returns boolean based on status code
        let operationPromise = operationVersion.removeWithResponseInfo({
            uri: instance._uri,
            method: "delete",
            headers
        }).then((response)=>({
                ...response,
                body: response.statusCode === 204
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetch(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["includeSoftDeleted"] !== undefined) data["IncludeSoftDeleted"] = serialize.bool(params["includeSoftDeleted"]);
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new RecordingInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["includeSoftDeleted"] !== undefined) data["IncludeSoftDeleted"] = serialize.bool(params["includeSoftDeleted"]);
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                ...response,
                body: new RecordingInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.RecordingContextImpl = RecordingContextImpl;
class RecordingInstance {
    constructor(_version, payload, accountSid, sid){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.apiVersion = payload.api_version;
        this.callSid = payload.call_sid;
        this.conferenceSid = payload.conference_sid;
        this.dateCreated = deserialize.rfc2822DateTime(payload.date_created);
        this.dateUpdated = deserialize.rfc2822DateTime(payload.date_updated);
        this.startTime = deserialize.rfc2822DateTime(payload.start_time);
        this.duration = payload.duration;
        this.sid = payload.sid;
        this.price = payload.price;
        this.priceUnit = payload.price_unit;
        this.status = payload.status;
        this.channels = deserialize.integer(payload.channels);
        this.source = payload.source;
        this.errorCode = deserialize.integer(payload.error_code);
        this.uri = payload.uri;
        this.encryptionDetails = payload.encryption_details;
        this.subresourceUris = payload.subresource_uris;
        this.mediaUrl = payload.media_url;
        this._solution = {
            accountSid,
            sid: sid || this.sid
        };
    }
    get _proxy() {
        this._context = this._context || new RecordingContextImpl(this._version, this._solution.accountSid, this._solution.sid);
        return this._context;
    }
    /**
     * Remove a RecordingInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean
     */ remove(callback) {
        return this._proxy.remove(callback);
    }
    /**
     * Remove a RecordingInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean with HTTP metadata
     */ removeWithHttpInfo(callback) {
        return this._proxy.removeWithHttpInfo(callback);
    }
    fetch(params, callback) {
        return this._proxy.fetch(params, callback);
    }
    fetchWithHttpInfo(params, callback) {
        return this._proxy.fetchWithHttpInfo(params, callback);
    }
    /**
     * Access the addOnResults.
     */ addOnResults() {
        return this._proxy.addOnResults;
    }
    /**
     * Access the transcriptions.
     */ transcriptions() {
        return this._proxy.transcriptions;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            apiVersion: this.apiVersion,
            callSid: this.callSid,
            conferenceSid: this.conferenceSid,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated,
            startTime: this.startTime,
            duration: this.duration,
            sid: this.sid,
            price: this.price,
            priceUnit: this.priceUnit,
            status: this.status,
            channels: this.channels,
            source: this.source,
            errorCode: this.errorCode,
            uri: this.uri,
            encryptionDetails: this.encryptionDetails,
            subresourceUris: this.subresourceUris,
            mediaUrl: this.mediaUrl
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.RecordingInstance = RecordingInstance;
function RecordingListInstance(version, accountSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    const instance = (sid)=>instance.get(sid);
    instance.get = function get(sid) {
        return new RecordingContextImpl(version, accountSid, sid);
    };
    instance._version = version;
    instance._solution = {
        accountSid
    };
    instance._uri = `/Accounts/${accountSid}/Recordings.json`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["dateCreated"] !== undefined) data["DateCreated"] = serialize.iso8601DateTime(params["dateCreated"]);
        if (params["dateCreatedBefore"] !== undefined) data["DateCreated<"] = serialize.iso8601DateTime(params["dateCreatedBefore"]);
        if (params["dateCreatedAfter"] !== undefined) data["DateCreated>"] = serialize.iso8601DateTime(params["dateCreatedAfter"]);
        if (params["callSid"] !== undefined) data["CallSid"] = params["callSid"];
        if (params["conferenceSid"] !== undefined) data["ConferenceSid"] = params["conferenceSid"];
        if (params["includeSoftDeleted"] !== undefined) data["IncludeSoftDeleted"] = serialize.bool(params["includeSoftDeleted"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new RecordingPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new RecordingPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["dateCreated"] !== undefined) data["DateCreated"] = serialize.iso8601DateTime(params["dateCreated"]);
        if (params["dateCreatedBefore"] !== undefined) data["DateCreated<"] = serialize.iso8601DateTime(params["dateCreatedBefore"]);
        if (params["dateCreatedAfter"] !== undefined) data["DateCreated>"] = serialize.iso8601DateTime(params["dateCreatedAfter"]);
        if (params["callSid"] !== undefined) data["CallSid"] = params["callSid"];
        if (params["conferenceSid"] !== undefined) data["ConferenceSid"] = params["conferenceSid"];
        if (params["includeSoftDeleted"] !== undefined) data["IncludeSoftDeleted"] = serialize.bool(params["includeSoftDeleted"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new RecordingPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new RecordingPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class RecordingPage extends Page_1.default {
    /**
     * Initialize the RecordingPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of RecordingInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new RecordingInstance(this._version, payload, this._solution.accountSid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.RecordingPage = RecordingPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/shortCode.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ShortCodePage = exports.ShortCodeInstance = exports.ShortCodeContextImpl = void 0;
exports.ShortCodeListInstance = ShortCodeListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
class ShortCodeContextImpl {
    constructor(_version, accountSid, sid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(accountSid)) {
            throw new Error("Parameter 'accountSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(sid)) {
            throw new Error("Parameter 'sid' is not valid.");
        }
        this._solution = {
            accountSid,
            sid
        };
        this._uri = `/Accounts/${accountSid}/SMS/ShortCodes/${sid}.json`;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new ShortCodeInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new ShortCodeInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    update(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["apiVersion"] !== undefined) data["ApiVersion"] = params["apiVersion"];
        if (params["smsUrl"] !== undefined) data["SmsUrl"] = params["smsUrl"];
        if (params["smsMethod"] !== undefined) data["SmsMethod"] = params["smsMethod"];
        if (params["smsFallbackUrl"] !== undefined) data["SmsFallbackUrl"] = params["smsFallbackUrl"];
        if (params["smsFallbackMethod"] !== undefined) data["SmsFallbackMethod"] = params["smsFallbackMethod"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.update({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new ShortCodeInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    updateWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["apiVersion"] !== undefined) data["ApiVersion"] = params["apiVersion"];
        if (params["smsUrl"] !== undefined) data["SmsUrl"] = params["smsUrl"];
        if (params["smsMethod"] !== undefined) data["SmsMethod"] = params["smsMethod"];
        if (params["smsFallbackUrl"] !== undefined) data["SmsFallbackUrl"] = params["smsFallbackUrl"];
        if (params["smsFallbackMethod"] !== undefined) data["SmsFallbackMethod"] = params["smsFallbackMethod"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.updateWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new ShortCodeInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.ShortCodeContextImpl = ShortCodeContextImpl;
class ShortCodeInstance {
    constructor(_version, payload, accountSid, sid){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.apiVersion = payload.api_version;
        this.dateCreated = deserialize.rfc2822DateTime(payload.date_created);
        this.dateUpdated = deserialize.rfc2822DateTime(payload.date_updated);
        this.friendlyName = payload.friendly_name;
        this.shortCode = payload.short_code;
        this.sid = payload.sid;
        this.smsFallbackMethod = payload.sms_fallback_method;
        this.smsFallbackUrl = payload.sms_fallback_url;
        this.smsMethod = payload.sms_method;
        this.smsUrl = payload.sms_url;
        this.uri = payload.uri;
        this._solution = {
            accountSid,
            sid: sid || this.sid
        };
    }
    get _proxy() {
        this._context = this._context || new ShortCodeContextImpl(this._version, this._solution.accountSid, this._solution.sid);
        return this._context;
    }
    /**
     * Fetch a ShortCodeInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed ShortCodeInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a ShortCodeInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed ShortCodeInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    update(params, callback) {
        return this._proxy.update(params, callback);
    }
    updateWithHttpInfo(params, callback) {
        return this._proxy.updateWithHttpInfo(params, callback);
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            apiVersion: this.apiVersion,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated,
            friendlyName: this.friendlyName,
            shortCode: this.shortCode,
            sid: this.sid,
            smsFallbackMethod: this.smsFallbackMethod,
            smsFallbackUrl: this.smsFallbackUrl,
            smsMethod: this.smsMethod,
            smsUrl: this.smsUrl,
            uri: this.uri
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.ShortCodeInstance = ShortCodeInstance;
function ShortCodeListInstance(version, accountSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    const instance = (sid)=>instance.get(sid);
    instance.get = function get(sid) {
        return new ShortCodeContextImpl(version, accountSid, sid);
    };
    instance._version = version;
    instance._solution = {
        accountSid
    };
    instance._uri = `/Accounts/${accountSid}/SMS/ShortCodes.json`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["shortCode"] !== undefined) data["ShortCode"] = params["shortCode"];
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new ShortCodePage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new ShortCodePage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["shortCode"] !== undefined) data["ShortCode"] = params["shortCode"];
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new ShortCodePage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new ShortCodePage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class ShortCodePage extends Page_1.default {
    /**
     * Initialize the ShortCodePage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of ShortCodeInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new ShortCodeInstance(this._version, payload, this._solution.accountSid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.ShortCodePage = ShortCodePage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/signingKey.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SigningKeyPage = exports.SigningKeyInstance = exports.SigningKeyContextImpl = void 0;
exports.SigningKeyListInstance = SigningKeyListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
class SigningKeyContextImpl {
    constructor(_version, accountSid, sid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(accountSid)) {
            throw new Error("Parameter 'accountSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(sid)) {
            throw new Error("Parameter 'sid' is not valid.");
        }
        this._solution = {
            accountSid,
            sid
        };
        this._uri = `/Accounts/${accountSid}/SigningKeys/${sid}.json`;
    }
    remove(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.remove({
            uri: instance._uri,
            method: "delete",
            headers
        });
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    removeWithHttpInfo(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version;
        // DELETE operation - returns boolean based on status code
        let operationPromise = operationVersion.removeWithResponseInfo({
            uri: instance._uri,
            method: "delete",
            headers
        }).then((response)=>({
                ...response,
                body: response.statusCode === 204
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new SigningKeyInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new SigningKeyInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    update(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.update({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new SigningKeyInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    updateWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.updateWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new SigningKeyInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.SigningKeyContextImpl = SigningKeyContextImpl;
class SigningKeyInstance {
    constructor(_version, payload, accountSid, sid){
        this._version = _version;
        this.sid = payload.sid;
        this.friendlyName = payload.friendly_name;
        this.dateCreated = deserialize.rfc2822DateTime(payload.date_created);
        this.dateUpdated = deserialize.rfc2822DateTime(payload.date_updated);
        this._solution = {
            accountSid,
            sid: sid || this.sid
        };
    }
    get _proxy() {
        this._context = this._context || new SigningKeyContextImpl(this._version, this._solution.accountSid, this._solution.sid);
        return this._context;
    }
    /**
     * Remove a SigningKeyInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean
     */ remove(callback) {
        return this._proxy.remove(callback);
    }
    /**
     * Remove a SigningKeyInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean with HTTP metadata
     */ removeWithHttpInfo(callback) {
        return this._proxy.removeWithHttpInfo(callback);
    }
    /**
     * Fetch a SigningKeyInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed SigningKeyInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a SigningKeyInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed SigningKeyInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    update(params, callback) {
        return this._proxy.update(params, callback);
    }
    updateWithHttpInfo(params, callback) {
        return this._proxy.updateWithHttpInfo(params, callback);
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            sid: this.sid,
            friendlyName: this.friendlyName,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.SigningKeyInstance = SigningKeyInstance;
function SigningKeyListInstance(version, accountSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    const instance = (sid)=>instance.get(sid);
    instance.get = function get(sid) {
        return new SigningKeyContextImpl(version, accountSid, sid);
    };
    instance._version = version;
    instance._solution = {
        accountSid
    };
    instance._uri = `/Accounts/${accountSid}/SigningKeys.json`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new SigningKeyPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new SigningKeyPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new SigningKeyPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new SigningKeyPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class SigningKeyPage extends Page_1.default {
    /**
     * Initialize the SigningKeyPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of SigningKeyInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new SigningKeyInstance(this._version, payload, this._solution.accountSid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.SigningKeyPage = SigningKeyPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/sip.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SipListInstance = SipListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
const credentialList_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/sip/credentialList.js [app-route] (ecmascript)");
const domain_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/sip/domain.js [app-route] (ecmascript)");
const ipAccessControlList_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/sip/ipAccessControlList.js [app-route] (ecmascript)");
function SipListInstance(version, accountSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    const instance = {};
    instance._version = version;
    instance._solution = {
        accountSid
    };
    instance._uri = `/Accounts/${accountSid}/SIP.json`;
    Object.defineProperty(instance, "credentialLists", {
        get: function credentialLists() {
            if (!instance._credentialLists) {
                instance._credentialLists = (0, credentialList_1.CredentialListListInstance)(instance._version, instance._solution.accountSid);
            }
            return instance._credentialLists;
        }
    });
    Object.defineProperty(instance, "domains", {
        get: function domains() {
            if (!instance._domains) {
                instance._domains = (0, domain_1.DomainListInstance)(instance._version, instance._solution.accountSid);
            }
            return instance._domains;
        }
    });
    Object.defineProperty(instance, "ipAccessControlLists", {
        get: function ipAccessControlLists() {
            if (!instance._ipAccessControlLists) {
                instance._ipAccessControlLists = (0, ipAccessControlList_1.IpAccessControlListListInstance)(instance._version, instance._solution.accountSid);
            }
            return instance._ipAccessControlLists;
        }
    });
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/token.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TokenInstance = exports.ApiV2010AccountTokenIceServers = void 0;
exports.TokenListInstance = TokenListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
class ApiV2010AccountTokenIceServers {
}
exports.ApiV2010AccountTokenIceServers = ApiV2010AccountTokenIceServers;
function TokenListInstance(version, accountSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    const instance = {};
    instance._version = version;
    instance._solution = {
        accountSid
    };
    instance._uri = `/Accounts/${accountSid}/Tokens.json`;
    instance.create = function create(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["ttl"] !== undefined) data["Ttl"] = params["ttl"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.create({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new TokenInstance(operationVersion, payload, instance._solution.accountSid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.createWithHttpInfo = function createWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["ttl"] !== undefined) data["Ttl"] = params["ttl"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.createWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new TokenInstance(operationVersion, response.body, instance._solution.accountSid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class TokenInstance {
    constructor(_version, payload, accountSid){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.dateCreated = deserialize.rfc2822DateTime(payload.date_created);
        this.dateUpdated = deserialize.rfc2822DateTime(payload.date_updated);
        this.iceServers = payload.ice_servers;
        this.password = payload.password;
        this.ttl = payload.ttl;
        this.username = payload.username;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated,
            iceServers: this.iceServers,
            password: this.password,
            ttl: this.ttl,
            username: this.username
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.TokenInstance = TokenInstance;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/transcription.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TranscriptionPage = exports.TranscriptionInstance = exports.TranscriptionContextImpl = void 0;
exports.TranscriptionListInstance = TranscriptionListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
class TranscriptionContextImpl {
    constructor(_version, accountSid, sid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(accountSid)) {
            throw new Error("Parameter 'accountSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(sid)) {
            throw new Error("Parameter 'sid' is not valid.");
        }
        this._solution = {
            accountSid,
            sid
        };
        this._uri = `/Accounts/${accountSid}/Transcriptions/${sid}.json`;
    }
    remove(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.remove({
            uri: instance._uri,
            method: "delete",
            headers
        });
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    removeWithHttpInfo(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version;
        // DELETE operation - returns boolean based on status code
        let operationPromise = operationVersion.removeWithResponseInfo({
            uri: instance._uri,
            method: "delete",
            headers
        }).then((response)=>({
                ...response,
                body: response.statusCode === 204
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new TranscriptionInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new TranscriptionInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.TranscriptionContextImpl = TranscriptionContextImpl;
class TranscriptionInstance {
    constructor(_version, payload, accountSid, sid){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.apiVersion = payload.api_version;
        this.dateCreated = deserialize.rfc2822DateTime(payload.date_created);
        this.dateUpdated = deserialize.rfc2822DateTime(payload.date_updated);
        this.duration = payload.duration;
        this.price = payload.price;
        this.priceUnit = payload.price_unit;
        this.recordingSid = payload.recording_sid;
        this.sid = payload.sid;
        this.status = payload.status;
        this.transcriptionText = payload.transcription_text;
        this.type = payload.type;
        this.uri = payload.uri;
        this._solution = {
            accountSid,
            sid: sid || this.sid
        };
    }
    get _proxy() {
        this._context = this._context || new TranscriptionContextImpl(this._version, this._solution.accountSid, this._solution.sid);
        return this._context;
    }
    /**
     * Remove a TranscriptionInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean
     */ remove(callback) {
        return this._proxy.remove(callback);
    }
    /**
     * Remove a TranscriptionInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean with HTTP metadata
     */ removeWithHttpInfo(callback) {
        return this._proxy.removeWithHttpInfo(callback);
    }
    /**
     * Fetch a TranscriptionInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed TranscriptionInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a TranscriptionInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed TranscriptionInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            apiVersion: this.apiVersion,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated,
            duration: this.duration,
            price: this.price,
            priceUnit: this.priceUnit,
            recordingSid: this.recordingSid,
            sid: this.sid,
            status: this.status,
            transcriptionText: this.transcriptionText,
            type: this.type,
            uri: this.uri
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.TranscriptionInstance = TranscriptionInstance;
function TranscriptionListInstance(version, accountSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    const instance = (sid)=>instance.get(sid);
    instance.get = function get(sid) {
        return new TranscriptionContextImpl(version, accountSid, sid);
    };
    instance._version = version;
    instance._solution = {
        accountSid
    };
    instance._uri = `/Accounts/${accountSid}/Transcriptions.json`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new TranscriptionPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new TranscriptionPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new TranscriptionPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new TranscriptionPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class TranscriptionPage extends Page_1.default {
    /**
     * Initialize the TranscriptionPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of TranscriptionInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new TranscriptionInstance(this._version, payload, this._solution.accountSid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.TranscriptionPage = TranscriptionPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/usage/record/allTime.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AllTimePage = exports.AllTimeInstance = void 0;
exports.AllTimeListInstance = AllTimeListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
function AllTimeListInstance(version, accountSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    const instance = {};
    instance._version = version;
    instance._solution = {
        accountSid
    };
    instance._uri = `/Accounts/${accountSid}/Usage/Records/AllTime.json`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["category"] !== undefined) data["Category"] = params["category"];
        if (params["startDate"] !== undefined) data["StartDate"] = serialize.iso8601Date(params["startDate"]);
        if (params["endDate"] !== undefined) data["EndDate"] = serialize.iso8601Date(params["endDate"]);
        if (params["includeSubaccounts"] !== undefined) data["IncludeSubaccounts"] = serialize.bool(params["includeSubaccounts"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new AllTimePage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new AllTimePage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["category"] !== undefined) data["Category"] = params["category"];
        if (params["startDate"] !== undefined) data["StartDate"] = serialize.iso8601Date(params["startDate"]);
        if (params["endDate"] !== undefined) data["EndDate"] = serialize.iso8601Date(params["endDate"]);
        if (params["includeSubaccounts"] !== undefined) data["IncludeSubaccounts"] = serialize.bool(params["includeSubaccounts"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new AllTimePage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new AllTimePage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class AllTimeInstance {
    constructor(_version, payload, accountSid){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.apiVersion = payload.api_version;
        this.asOf = payload.as_of;
        this.category = payload.category;
        this.count = payload.count;
        this.countUnit = payload.count_unit;
        this.description = payload.description;
        this.endDate = deserialize.iso8601Date(payload.end_date);
        this.price = payload.price;
        this.priceUnit = payload.price_unit;
        this.startDate = deserialize.iso8601Date(payload.start_date);
        this.subresourceUris = payload.subresource_uris;
        this.uri = payload.uri;
        this.usage = payload.usage;
        this.usageUnit = payload.usage_unit;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            apiVersion: this.apiVersion,
            asOf: this.asOf,
            category: this.category,
            count: this.count,
            countUnit: this.countUnit,
            description: this.description,
            endDate: this.endDate,
            price: this.price,
            priceUnit: this.priceUnit,
            startDate: this.startDate,
            subresourceUris: this.subresourceUris,
            uri: this.uri,
            usage: this.usage,
            usageUnit: this.usageUnit
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.AllTimeInstance = AllTimeInstance;
class AllTimePage extends Page_1.default {
    /**
     * Initialize the AllTimePage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of AllTimeInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new AllTimeInstance(this._version, payload, this._solution.accountSid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.AllTimePage = AllTimePage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/usage/record/daily.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DailyPage = exports.DailyInstance = void 0;
exports.DailyListInstance = DailyListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
function DailyListInstance(version, accountSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    const instance = {};
    instance._version = version;
    instance._solution = {
        accountSid
    };
    instance._uri = `/Accounts/${accountSid}/Usage/Records/Daily.json`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["category"] !== undefined) data["Category"] = params["category"];
        if (params["startDate"] !== undefined) data["StartDate"] = serialize.iso8601Date(params["startDate"]);
        if (params["endDate"] !== undefined) data["EndDate"] = serialize.iso8601Date(params["endDate"]);
        if (params["includeSubaccounts"] !== undefined) data["IncludeSubaccounts"] = serialize.bool(params["includeSubaccounts"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new DailyPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new DailyPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["category"] !== undefined) data["Category"] = params["category"];
        if (params["startDate"] !== undefined) data["StartDate"] = serialize.iso8601Date(params["startDate"]);
        if (params["endDate"] !== undefined) data["EndDate"] = serialize.iso8601Date(params["endDate"]);
        if (params["includeSubaccounts"] !== undefined) data["IncludeSubaccounts"] = serialize.bool(params["includeSubaccounts"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new DailyPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new DailyPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class DailyInstance {
    constructor(_version, payload, accountSid){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.apiVersion = payload.api_version;
        this.asOf = payload.as_of;
        this.category = payload.category;
        this.count = payload.count;
        this.countUnit = payload.count_unit;
        this.description = payload.description;
        this.endDate = deserialize.iso8601Date(payload.end_date);
        this.price = payload.price;
        this.priceUnit = payload.price_unit;
        this.startDate = deserialize.iso8601Date(payload.start_date);
        this.subresourceUris = payload.subresource_uris;
        this.uri = payload.uri;
        this.usage = payload.usage;
        this.usageUnit = payload.usage_unit;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            apiVersion: this.apiVersion,
            asOf: this.asOf,
            category: this.category,
            count: this.count,
            countUnit: this.countUnit,
            description: this.description,
            endDate: this.endDate,
            price: this.price,
            priceUnit: this.priceUnit,
            startDate: this.startDate,
            subresourceUris: this.subresourceUris,
            uri: this.uri,
            usage: this.usage,
            usageUnit: this.usageUnit
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.DailyInstance = DailyInstance;
class DailyPage extends Page_1.default {
    /**
     * Initialize the DailyPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of DailyInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new DailyInstance(this._version, payload, this._solution.accountSid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.DailyPage = DailyPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/usage/record/lastMonth.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LastMonthPage = exports.LastMonthInstance = void 0;
exports.LastMonthListInstance = LastMonthListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
function LastMonthListInstance(version, accountSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    const instance = {};
    instance._version = version;
    instance._solution = {
        accountSid
    };
    instance._uri = `/Accounts/${accountSid}/Usage/Records/LastMonth.json`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["category"] !== undefined) data["Category"] = params["category"];
        if (params["startDate"] !== undefined) data["StartDate"] = serialize.iso8601Date(params["startDate"]);
        if (params["endDate"] !== undefined) data["EndDate"] = serialize.iso8601Date(params["endDate"]);
        if (params["includeSubaccounts"] !== undefined) data["IncludeSubaccounts"] = serialize.bool(params["includeSubaccounts"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new LastMonthPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new LastMonthPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["category"] !== undefined) data["Category"] = params["category"];
        if (params["startDate"] !== undefined) data["StartDate"] = serialize.iso8601Date(params["startDate"]);
        if (params["endDate"] !== undefined) data["EndDate"] = serialize.iso8601Date(params["endDate"]);
        if (params["includeSubaccounts"] !== undefined) data["IncludeSubaccounts"] = serialize.bool(params["includeSubaccounts"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new LastMonthPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new LastMonthPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class LastMonthInstance {
    constructor(_version, payload, accountSid){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.apiVersion = payload.api_version;
        this.asOf = payload.as_of;
        this.category = payload.category;
        this.count = payload.count;
        this.countUnit = payload.count_unit;
        this.description = payload.description;
        this.endDate = deserialize.iso8601Date(payload.end_date);
        this.price = payload.price;
        this.priceUnit = payload.price_unit;
        this.startDate = deserialize.iso8601Date(payload.start_date);
        this.subresourceUris = payload.subresource_uris;
        this.uri = payload.uri;
        this.usage = payload.usage;
        this.usageUnit = payload.usage_unit;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            apiVersion: this.apiVersion,
            asOf: this.asOf,
            category: this.category,
            count: this.count,
            countUnit: this.countUnit,
            description: this.description,
            endDate: this.endDate,
            price: this.price,
            priceUnit: this.priceUnit,
            startDate: this.startDate,
            subresourceUris: this.subresourceUris,
            uri: this.uri,
            usage: this.usage,
            usageUnit: this.usageUnit
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.LastMonthInstance = LastMonthInstance;
class LastMonthPage extends Page_1.default {
    /**
     * Initialize the LastMonthPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of LastMonthInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new LastMonthInstance(this._version, payload, this._solution.accountSid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.LastMonthPage = LastMonthPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/usage/record/monthly.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MonthlyPage = exports.MonthlyInstance = void 0;
exports.MonthlyListInstance = MonthlyListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
function MonthlyListInstance(version, accountSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    const instance = {};
    instance._version = version;
    instance._solution = {
        accountSid
    };
    instance._uri = `/Accounts/${accountSid}/Usage/Records/Monthly.json`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["category"] !== undefined) data["Category"] = params["category"];
        if (params["startDate"] !== undefined) data["StartDate"] = serialize.iso8601Date(params["startDate"]);
        if (params["endDate"] !== undefined) data["EndDate"] = serialize.iso8601Date(params["endDate"]);
        if (params["includeSubaccounts"] !== undefined) data["IncludeSubaccounts"] = serialize.bool(params["includeSubaccounts"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new MonthlyPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new MonthlyPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["category"] !== undefined) data["Category"] = params["category"];
        if (params["startDate"] !== undefined) data["StartDate"] = serialize.iso8601Date(params["startDate"]);
        if (params["endDate"] !== undefined) data["EndDate"] = serialize.iso8601Date(params["endDate"]);
        if (params["includeSubaccounts"] !== undefined) data["IncludeSubaccounts"] = serialize.bool(params["includeSubaccounts"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new MonthlyPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new MonthlyPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class MonthlyInstance {
    constructor(_version, payload, accountSid){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.apiVersion = payload.api_version;
        this.asOf = payload.as_of;
        this.category = payload.category;
        this.count = payload.count;
        this.countUnit = payload.count_unit;
        this.description = payload.description;
        this.endDate = deserialize.iso8601Date(payload.end_date);
        this.price = payload.price;
        this.priceUnit = payload.price_unit;
        this.startDate = deserialize.iso8601Date(payload.start_date);
        this.subresourceUris = payload.subresource_uris;
        this.uri = payload.uri;
        this.usage = payload.usage;
        this.usageUnit = payload.usage_unit;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            apiVersion: this.apiVersion,
            asOf: this.asOf,
            category: this.category,
            count: this.count,
            countUnit: this.countUnit,
            description: this.description,
            endDate: this.endDate,
            price: this.price,
            priceUnit: this.priceUnit,
            startDate: this.startDate,
            subresourceUris: this.subresourceUris,
            uri: this.uri,
            usage: this.usage,
            usageUnit: this.usageUnit
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.MonthlyInstance = MonthlyInstance;
class MonthlyPage extends Page_1.default {
    /**
     * Initialize the MonthlyPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of MonthlyInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new MonthlyInstance(this._version, payload, this._solution.accountSid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.MonthlyPage = MonthlyPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/usage/record/thisMonth.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ThisMonthPage = exports.ThisMonthInstance = void 0;
exports.ThisMonthListInstance = ThisMonthListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
function ThisMonthListInstance(version, accountSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    const instance = {};
    instance._version = version;
    instance._solution = {
        accountSid
    };
    instance._uri = `/Accounts/${accountSid}/Usage/Records/ThisMonth.json`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["category"] !== undefined) data["Category"] = params["category"];
        if (params["startDate"] !== undefined) data["StartDate"] = serialize.iso8601Date(params["startDate"]);
        if (params["endDate"] !== undefined) data["EndDate"] = serialize.iso8601Date(params["endDate"]);
        if (params["includeSubaccounts"] !== undefined) data["IncludeSubaccounts"] = serialize.bool(params["includeSubaccounts"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new ThisMonthPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new ThisMonthPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["category"] !== undefined) data["Category"] = params["category"];
        if (params["startDate"] !== undefined) data["StartDate"] = serialize.iso8601Date(params["startDate"]);
        if (params["endDate"] !== undefined) data["EndDate"] = serialize.iso8601Date(params["endDate"]);
        if (params["includeSubaccounts"] !== undefined) data["IncludeSubaccounts"] = serialize.bool(params["includeSubaccounts"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new ThisMonthPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new ThisMonthPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class ThisMonthInstance {
    constructor(_version, payload, accountSid){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.apiVersion = payload.api_version;
        this.asOf = payload.as_of;
        this.category = payload.category;
        this.count = payload.count;
        this.countUnit = payload.count_unit;
        this.description = payload.description;
        this.endDate = deserialize.iso8601Date(payload.end_date);
        this.price = payload.price;
        this.priceUnit = payload.price_unit;
        this.startDate = deserialize.iso8601Date(payload.start_date);
        this.subresourceUris = payload.subresource_uris;
        this.uri = payload.uri;
        this.usage = payload.usage;
        this.usageUnit = payload.usage_unit;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            apiVersion: this.apiVersion,
            asOf: this.asOf,
            category: this.category,
            count: this.count,
            countUnit: this.countUnit,
            description: this.description,
            endDate: this.endDate,
            price: this.price,
            priceUnit: this.priceUnit,
            startDate: this.startDate,
            subresourceUris: this.subresourceUris,
            uri: this.uri,
            usage: this.usage,
            usageUnit: this.usageUnit
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.ThisMonthInstance = ThisMonthInstance;
class ThisMonthPage extends Page_1.default {
    /**
     * Initialize the ThisMonthPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of ThisMonthInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new ThisMonthInstance(this._version, payload, this._solution.accountSid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.ThisMonthPage = ThisMonthPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/usage/record/today.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TodayPage = exports.TodayInstance = void 0;
exports.TodayListInstance = TodayListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
function TodayListInstance(version, accountSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    const instance = {};
    instance._version = version;
    instance._solution = {
        accountSid
    };
    instance._uri = `/Accounts/${accountSid}/Usage/Records/Today.json`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["category"] !== undefined) data["Category"] = params["category"];
        if (params["startDate"] !== undefined) data["StartDate"] = serialize.iso8601Date(params["startDate"]);
        if (params["endDate"] !== undefined) data["EndDate"] = serialize.iso8601Date(params["endDate"]);
        if (params["includeSubaccounts"] !== undefined) data["IncludeSubaccounts"] = serialize.bool(params["includeSubaccounts"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new TodayPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new TodayPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["category"] !== undefined) data["Category"] = params["category"];
        if (params["startDate"] !== undefined) data["StartDate"] = serialize.iso8601Date(params["startDate"]);
        if (params["endDate"] !== undefined) data["EndDate"] = serialize.iso8601Date(params["endDate"]);
        if (params["includeSubaccounts"] !== undefined) data["IncludeSubaccounts"] = serialize.bool(params["includeSubaccounts"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new TodayPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new TodayPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class TodayInstance {
    constructor(_version, payload, accountSid){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.apiVersion = payload.api_version;
        this.asOf = payload.as_of;
        this.category = payload.category;
        this.count = payload.count;
        this.countUnit = payload.count_unit;
        this.description = payload.description;
        this.endDate = deserialize.iso8601Date(payload.end_date);
        this.price = payload.price;
        this.priceUnit = payload.price_unit;
        this.startDate = deserialize.iso8601Date(payload.start_date);
        this.subresourceUris = payload.subresource_uris;
        this.uri = payload.uri;
        this.usage = payload.usage;
        this.usageUnit = payload.usage_unit;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            apiVersion: this.apiVersion,
            asOf: this.asOf,
            category: this.category,
            count: this.count,
            countUnit: this.countUnit,
            description: this.description,
            endDate: this.endDate,
            price: this.price,
            priceUnit: this.priceUnit,
            startDate: this.startDate,
            subresourceUris: this.subresourceUris,
            uri: this.uri,
            usage: this.usage,
            usageUnit: this.usageUnit
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.TodayInstance = TodayInstance;
class TodayPage extends Page_1.default {
    /**
     * Initialize the TodayPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of TodayInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new TodayInstance(this._version, payload, this._solution.accountSid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.TodayPage = TodayPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/usage/record/yearly.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YearlyPage = exports.YearlyInstance = void 0;
exports.YearlyListInstance = YearlyListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
function YearlyListInstance(version, accountSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    const instance = {};
    instance._version = version;
    instance._solution = {
        accountSid
    };
    instance._uri = `/Accounts/${accountSid}/Usage/Records/Yearly.json`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["category"] !== undefined) data["Category"] = params["category"];
        if (params["startDate"] !== undefined) data["StartDate"] = serialize.iso8601Date(params["startDate"]);
        if (params["endDate"] !== undefined) data["EndDate"] = serialize.iso8601Date(params["endDate"]);
        if (params["includeSubaccounts"] !== undefined) data["IncludeSubaccounts"] = serialize.bool(params["includeSubaccounts"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new YearlyPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new YearlyPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["category"] !== undefined) data["Category"] = params["category"];
        if (params["startDate"] !== undefined) data["StartDate"] = serialize.iso8601Date(params["startDate"]);
        if (params["endDate"] !== undefined) data["EndDate"] = serialize.iso8601Date(params["endDate"]);
        if (params["includeSubaccounts"] !== undefined) data["IncludeSubaccounts"] = serialize.bool(params["includeSubaccounts"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new YearlyPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new YearlyPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class YearlyInstance {
    constructor(_version, payload, accountSid){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.apiVersion = payload.api_version;
        this.asOf = payload.as_of;
        this.category = payload.category;
        this.count = payload.count;
        this.countUnit = payload.count_unit;
        this.description = payload.description;
        this.endDate = deserialize.iso8601Date(payload.end_date);
        this.price = payload.price;
        this.priceUnit = payload.price_unit;
        this.startDate = deserialize.iso8601Date(payload.start_date);
        this.subresourceUris = payload.subresource_uris;
        this.uri = payload.uri;
        this.usage = payload.usage;
        this.usageUnit = payload.usage_unit;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            apiVersion: this.apiVersion,
            asOf: this.asOf,
            category: this.category,
            count: this.count,
            countUnit: this.countUnit,
            description: this.description,
            endDate: this.endDate,
            price: this.price,
            priceUnit: this.priceUnit,
            startDate: this.startDate,
            subresourceUris: this.subresourceUris,
            uri: this.uri,
            usage: this.usage,
            usageUnit: this.usageUnit
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.YearlyInstance = YearlyInstance;
class YearlyPage extends Page_1.default {
    /**
     * Initialize the YearlyPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of YearlyInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new YearlyInstance(this._version, payload, this._solution.accountSid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.YearlyPage = YearlyPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/usage/record/yesterday.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.YesterdayPage = exports.YesterdayInstance = void 0;
exports.YesterdayListInstance = YesterdayListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
function YesterdayListInstance(version, accountSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    const instance = {};
    instance._version = version;
    instance._solution = {
        accountSid
    };
    instance._uri = `/Accounts/${accountSid}/Usage/Records/Yesterday.json`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["category"] !== undefined) data["Category"] = params["category"];
        if (params["startDate"] !== undefined) data["StartDate"] = serialize.iso8601Date(params["startDate"]);
        if (params["endDate"] !== undefined) data["EndDate"] = serialize.iso8601Date(params["endDate"]);
        if (params["includeSubaccounts"] !== undefined) data["IncludeSubaccounts"] = serialize.bool(params["includeSubaccounts"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new YesterdayPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new YesterdayPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["category"] !== undefined) data["Category"] = params["category"];
        if (params["startDate"] !== undefined) data["StartDate"] = serialize.iso8601Date(params["startDate"]);
        if (params["endDate"] !== undefined) data["EndDate"] = serialize.iso8601Date(params["endDate"]);
        if (params["includeSubaccounts"] !== undefined) data["IncludeSubaccounts"] = serialize.bool(params["includeSubaccounts"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new YesterdayPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new YesterdayPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class YesterdayInstance {
    constructor(_version, payload, accountSid){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.apiVersion = payload.api_version;
        this.asOf = payload.as_of;
        this.category = payload.category;
        this.count = payload.count;
        this.countUnit = payload.count_unit;
        this.description = payload.description;
        this.endDate = deserialize.iso8601Date(payload.end_date);
        this.price = payload.price;
        this.priceUnit = payload.price_unit;
        this.startDate = deserialize.iso8601Date(payload.start_date);
        this.subresourceUris = payload.subresource_uris;
        this.uri = payload.uri;
        this.usage = payload.usage;
        this.usageUnit = payload.usage_unit;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            apiVersion: this.apiVersion,
            asOf: this.asOf,
            category: this.category,
            count: this.count,
            countUnit: this.countUnit,
            description: this.description,
            endDate: this.endDate,
            price: this.price,
            priceUnit: this.priceUnit,
            startDate: this.startDate,
            subresourceUris: this.subresourceUris,
            uri: this.uri,
            usage: this.usage,
            usageUnit: this.usageUnit
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.YesterdayInstance = YesterdayInstance;
class YesterdayPage extends Page_1.default {
    /**
     * Initialize the YesterdayPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of YesterdayInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new YesterdayInstance(this._version, payload, this._solution.accountSid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.YesterdayPage = YesterdayPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/usage/record.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RecordPage = exports.RecordInstance = void 0;
exports.RecordListInstance = RecordListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
const allTime_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/usage/record/allTime.js [app-route] (ecmascript)");
const daily_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/usage/record/daily.js [app-route] (ecmascript)");
const lastMonth_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/usage/record/lastMonth.js [app-route] (ecmascript)");
const monthly_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/usage/record/monthly.js [app-route] (ecmascript)");
const thisMonth_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/usage/record/thisMonth.js [app-route] (ecmascript)");
const today_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/usage/record/today.js [app-route] (ecmascript)");
const yearly_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/usage/record/yearly.js [app-route] (ecmascript)");
const yesterday_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/usage/record/yesterday.js [app-route] (ecmascript)");
function RecordListInstance(version, accountSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    const instance = {};
    instance._version = version;
    instance._solution = {
        accountSid
    };
    instance._uri = `/Accounts/${accountSid}/Usage/Records.json`;
    Object.defineProperty(instance, "allTime", {
        get: function allTime() {
            if (!instance._allTime) {
                instance._allTime = (0, allTime_1.AllTimeListInstance)(instance._version, instance._solution.accountSid);
            }
            return instance._allTime;
        }
    });
    Object.defineProperty(instance, "daily", {
        get: function daily() {
            if (!instance._daily) {
                instance._daily = (0, daily_1.DailyListInstance)(instance._version, instance._solution.accountSid);
            }
            return instance._daily;
        }
    });
    Object.defineProperty(instance, "lastMonth", {
        get: function lastMonth() {
            if (!instance._lastMonth) {
                instance._lastMonth = (0, lastMonth_1.LastMonthListInstance)(instance._version, instance._solution.accountSid);
            }
            return instance._lastMonth;
        }
    });
    Object.defineProperty(instance, "monthly", {
        get: function monthly() {
            if (!instance._monthly) {
                instance._monthly = (0, monthly_1.MonthlyListInstance)(instance._version, instance._solution.accountSid);
            }
            return instance._monthly;
        }
    });
    Object.defineProperty(instance, "thisMonth", {
        get: function thisMonth() {
            if (!instance._thisMonth) {
                instance._thisMonth = (0, thisMonth_1.ThisMonthListInstance)(instance._version, instance._solution.accountSid);
            }
            return instance._thisMonth;
        }
    });
    Object.defineProperty(instance, "today", {
        get: function today() {
            if (!instance._today) {
                instance._today = (0, today_1.TodayListInstance)(instance._version, instance._solution.accountSid);
            }
            return instance._today;
        }
    });
    Object.defineProperty(instance, "yearly", {
        get: function yearly() {
            if (!instance._yearly) {
                instance._yearly = (0, yearly_1.YearlyListInstance)(instance._version, instance._solution.accountSid);
            }
            return instance._yearly;
        }
    });
    Object.defineProperty(instance, "yesterday", {
        get: function yesterday() {
            if (!instance._yesterday) {
                instance._yesterday = (0, yesterday_1.YesterdayListInstance)(instance._version, instance._solution.accountSid);
            }
            return instance._yesterday;
        }
    });
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["category"] !== undefined) data["Category"] = params["category"];
        if (params["startDate"] !== undefined) data["StartDate"] = serialize.iso8601Date(params["startDate"]);
        if (params["endDate"] !== undefined) data["EndDate"] = serialize.iso8601Date(params["endDate"]);
        if (params["includeSubaccounts"] !== undefined) data["IncludeSubaccounts"] = serialize.bool(params["includeSubaccounts"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new RecordPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new RecordPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["category"] !== undefined) data["Category"] = params["category"];
        if (params["startDate"] !== undefined) data["StartDate"] = serialize.iso8601Date(params["startDate"]);
        if (params["endDate"] !== undefined) data["EndDate"] = serialize.iso8601Date(params["endDate"]);
        if (params["includeSubaccounts"] !== undefined) data["IncludeSubaccounts"] = serialize.bool(params["includeSubaccounts"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new RecordPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new RecordPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class RecordInstance {
    constructor(_version, payload, accountSid){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.apiVersion = payload.api_version;
        this.asOf = payload.as_of;
        this.category = payload.category;
        this.count = payload.count;
        this.countUnit = payload.count_unit;
        this.description = payload.description;
        this.endDate = deserialize.iso8601Date(payload.end_date);
        this.price = payload.price;
        this.priceUnit = payload.price_unit;
        this.startDate = deserialize.iso8601Date(payload.start_date);
        this.subresourceUris = payload.subresource_uris;
        this.uri = payload.uri;
        this.usage = payload.usage;
        this.usageUnit = payload.usage_unit;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            apiVersion: this.apiVersion,
            asOf: this.asOf,
            category: this.category,
            count: this.count,
            countUnit: this.countUnit,
            description: this.description,
            endDate: this.endDate,
            price: this.price,
            priceUnit: this.priceUnit,
            startDate: this.startDate,
            subresourceUris: this.subresourceUris,
            uri: this.uri,
            usage: this.usage,
            usageUnit: this.usageUnit
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.RecordInstance = RecordInstance;
class RecordPage extends Page_1.default {
    /**
     * Initialize the RecordPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of RecordInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new RecordInstance(this._version, payload, this._solution.accountSid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.RecordPage = RecordPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/usage/trigger.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TriggerPage = exports.TriggerInstance = exports.TriggerContextImpl = void 0;
exports.TriggerListInstance = TriggerListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
class TriggerContextImpl {
    constructor(_version, accountSid, sid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(accountSid)) {
            throw new Error("Parameter 'accountSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(sid)) {
            throw new Error("Parameter 'sid' is not valid.");
        }
        this._solution = {
            accountSid,
            sid
        };
        this._uri = `/Accounts/${accountSid}/Usage/Triggers/${sid}.json`;
    }
    remove(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.remove({
            uri: instance._uri,
            method: "delete",
            headers
        });
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    removeWithHttpInfo(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version;
        // DELETE operation - returns boolean based on status code
        let operationPromise = operationVersion.removeWithResponseInfo({
            uri: instance._uri,
            method: "delete",
            headers
        }).then((response)=>({
                ...response,
                body: response.statusCode === 204
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new TriggerInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new TriggerInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    update(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["callbackMethod"] !== undefined) data["CallbackMethod"] = params["callbackMethod"];
        if (params["callbackUrl"] !== undefined) data["CallbackUrl"] = params["callbackUrl"];
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.update({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new TriggerInstance(operationVersion, payload, instance._solution.accountSid, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    updateWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["callbackMethod"] !== undefined) data["CallbackMethod"] = params["callbackMethod"];
        if (params["callbackUrl"] !== undefined) data["CallbackUrl"] = params["callbackUrl"];
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.updateWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new TriggerInstance(operationVersion, response.body, instance._solution.accountSid, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.TriggerContextImpl = TriggerContextImpl;
class TriggerInstance {
    constructor(_version, payload, accountSid, sid){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.apiVersion = payload.api_version;
        this.callbackMethod = payload.callback_method;
        this.callbackUrl = payload.callback_url;
        this.currentValue = payload.current_value;
        this.dateCreated = deserialize.rfc2822DateTime(payload.date_created);
        this.dateFired = deserialize.rfc2822DateTime(payload.date_fired);
        this.dateUpdated = deserialize.rfc2822DateTime(payload.date_updated);
        this.friendlyName = payload.friendly_name;
        this.recurring = payload.recurring;
        this.sid = payload.sid;
        this.triggerBy = payload.trigger_by;
        this.triggerValue = payload.trigger_value;
        this.uri = payload.uri;
        this.usageCategory = payload.usage_category;
        this.usageRecordUri = payload.usage_record_uri;
        this._solution = {
            accountSid,
            sid: sid || this.sid
        };
    }
    get _proxy() {
        this._context = this._context || new TriggerContextImpl(this._version, this._solution.accountSid, this._solution.sid);
        return this._context;
    }
    /**
     * Remove a TriggerInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean
     */ remove(callback) {
        return this._proxy.remove(callback);
    }
    /**
     * Remove a TriggerInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean with HTTP metadata
     */ removeWithHttpInfo(callback) {
        return this._proxy.removeWithHttpInfo(callback);
    }
    /**
     * Fetch a TriggerInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed TriggerInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a TriggerInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed TriggerInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    update(params, callback) {
        return this._proxy.update(params, callback);
    }
    updateWithHttpInfo(params, callback) {
        return this._proxy.updateWithHttpInfo(params, callback);
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            apiVersion: this.apiVersion,
            callbackMethod: this.callbackMethod,
            callbackUrl: this.callbackUrl,
            currentValue: this.currentValue,
            dateCreated: this.dateCreated,
            dateFired: this.dateFired,
            dateUpdated: this.dateUpdated,
            friendlyName: this.friendlyName,
            recurring: this.recurring,
            sid: this.sid,
            triggerBy: this.triggerBy,
            triggerValue: this.triggerValue,
            uri: this.uri,
            usageCategory: this.usageCategory,
            usageRecordUri: this.usageRecordUri
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.TriggerInstance = TriggerInstance;
function TriggerListInstance(version, accountSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    const instance = (sid)=>instance.get(sid);
    instance.get = function get(sid) {
        return new TriggerContextImpl(version, accountSid, sid);
    };
    instance._version = version;
    instance._solution = {
        accountSid
    };
    instance._uri = `/Accounts/${accountSid}/Usage/Triggers.json`;
    instance.create = function create(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["callbackUrl"] === null || params["callbackUrl"] === undefined) {
            throw new Error("Required parameter \"params['callbackUrl']\" missing.");
        }
        if (params["triggerValue"] === null || params["triggerValue"] === undefined) {
            throw new Error("Required parameter \"params['triggerValue']\" missing.");
        }
        if (params["usageCategory"] === null || params["usageCategory"] === undefined) {
            throw new Error("Required parameter \"params['usageCategory']\" missing.");
        }
        let data = {};
        data["CallbackUrl"] = params["callbackUrl"];
        data["TriggerValue"] = params["triggerValue"];
        data["UsageCategory"] = params["usageCategory"];
        if (params["callbackMethod"] !== undefined) data["CallbackMethod"] = params["callbackMethod"];
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["recurring"] !== undefined) data["Recurring"] = params["recurring"];
        if (params["triggerBy"] !== undefined) data["TriggerBy"] = params["triggerBy"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.create({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new TriggerInstance(operationVersion, payload, instance._solution.accountSid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.createWithHttpInfo = function createWithHttpInfo(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["callbackUrl"] === null || params["callbackUrl"] === undefined) {
            throw new Error("Required parameter \"params['callbackUrl']\" missing.");
        }
        if (params["triggerValue"] === null || params["triggerValue"] === undefined) {
            throw new Error("Required parameter \"params['triggerValue']\" missing.");
        }
        if (params["usageCategory"] === null || params["usageCategory"] === undefined) {
            throw new Error("Required parameter \"params['usageCategory']\" missing.");
        }
        let data = {};
        data["CallbackUrl"] = params["callbackUrl"];
        data["TriggerValue"] = params["triggerValue"];
        data["UsageCategory"] = params["usageCategory"];
        if (params["callbackMethod"] !== undefined) data["CallbackMethod"] = params["callbackMethod"];
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["recurring"] !== undefined) data["Recurring"] = params["recurring"];
        if (params["triggerBy"] !== undefined) data["TriggerBy"] = params["triggerBy"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.createWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new TriggerInstance(operationVersion, response.body, instance._solution.accountSid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["recurring"] !== undefined) data["Recurring"] = params["recurring"];
        if (params["triggerBy"] !== undefined) data["TriggerBy"] = params["triggerBy"];
        if (params["usageCategory"] !== undefined) data["UsageCategory"] = params["usageCategory"];
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new TriggerPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new TriggerPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["recurring"] !== undefined) data["Recurring"] = params["recurring"];
        if (params["triggerBy"] !== undefined) data["TriggerBy"] = params["triggerBy"];
        if (params["usageCategory"] !== undefined) data["UsageCategory"] = params["usageCategory"];
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new TriggerPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new TriggerPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class TriggerPage extends Page_1.default {
    /**
     * Initialize the TriggerPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of TriggerInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new TriggerInstance(this._version, payload, this._solution.accountSid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.TriggerPage = TriggerPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/usage.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.UsageListInstance = UsageListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
const record_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/usage/record.js [app-route] (ecmascript)");
const trigger_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/usage/trigger.js [app-route] (ecmascript)");
function UsageListInstance(version, accountSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    const instance = {};
    instance._version = version;
    instance._solution = {
        accountSid
    };
    instance._uri = `/Accounts/${accountSid}/Usage.json`;
    Object.defineProperty(instance, "records", {
        get: function records() {
            if (!instance._records) {
                instance._records = (0, record_1.RecordListInstance)(instance._version, instance._solution.accountSid);
            }
            return instance._records;
        }
    });
    Object.defineProperty(instance, "triggers", {
        get: function triggers() {
            if (!instance._triggers) {
                instance._triggers = (0, trigger_1.TriggerListInstance)(instance._version, instance._solution.accountSid);
            }
            return instance._triggers;
        }
    });
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/api/v2010/account/validationRequest.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Api
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ValidationRequestInstance = void 0;
exports.ValidationRequestListInstance = ValidationRequestListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
function ValidationRequestListInstance(version, accountSid) {
    if (!(0, utility_1.isValidPathParam)(accountSid)) {
        throw new Error("Parameter 'accountSid' is not valid.");
    }
    const instance = {};
    instance._version = version;
    instance._solution = {
        accountSid
    };
    instance._uri = `/Accounts/${accountSid}/OutgoingCallerIds.json`;
    instance.create = function create(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["phoneNumber"] === null || params["phoneNumber"] === undefined) {
            throw new Error("Required parameter \"params['phoneNumber']\" missing.");
        }
        let data = {};
        data["PhoneNumber"] = params["phoneNumber"];
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["callDelay"] !== undefined) data["CallDelay"] = params["callDelay"];
        if (params["extension"] !== undefined) data["Extension"] = params["extension"];
        if (params["statusCallback"] !== undefined) data["StatusCallback"] = params["statusCallback"];
        if (params["statusCallbackMethod"] !== undefined) data["StatusCallbackMethod"] = params["statusCallbackMethod"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.create({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new ValidationRequestInstance(operationVersion, payload, instance._solution.accountSid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.createWithHttpInfo = function createWithHttpInfo(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["phoneNumber"] === null || params["phoneNumber"] === undefined) {
            throw new Error("Required parameter \"params['phoneNumber']\" missing.");
        }
        let data = {};
        data["PhoneNumber"] = params["phoneNumber"];
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["callDelay"] !== undefined) data["CallDelay"] = params["callDelay"];
        if (params["extension"] !== undefined) data["Extension"] = params["extension"];
        if (params["statusCallback"] !== undefined) data["StatusCallback"] = params["statusCallback"];
        if (params["statusCallbackMethod"] !== undefined) data["StatusCallbackMethod"] = params["statusCallbackMethod"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.createWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new ValidationRequestInstance(operationVersion, response.body, instance._solution.accountSid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class ValidationRequestInstance {
    constructor(_version, payload, accountSid){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.callSid = payload.call_sid;
        this.friendlyName = payload.friendly_name;
        this.phoneNumber = payload.phone_number;
        this.validationCode = payload.validation_code;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            callSid: this.callSid,
            friendlyName: this.friendlyName,
            phoneNumber: this.phoneNumber,
            validationCode: this.validationCode
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.ValidationRequestInstance = ValidationRequestInstance;
}),
];

//# sourceMappingURL=96e98_twilio_lib_rest_api_v2010_account_6a3dc29d._.js.map