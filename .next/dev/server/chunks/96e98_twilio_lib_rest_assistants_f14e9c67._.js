module.exports = [
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/assistants/v1/assistant/assistantsKnowledge.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Assistants
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AssistantsKnowledgePage = exports.AssistantsKnowledgeInstance = exports.AssistantsKnowledgeContextImpl = void 0;
exports.AssistantsKnowledgeListInstance = AssistantsKnowledgeListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
class AssistantsKnowledgeContextImpl {
    constructor(_version, assistantId, id){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(assistantId)) {
            throw new Error("Parameter 'assistantId' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(id)) {
            throw new Error("Parameter 'id' is not valid.");
        }
        this._solution = {
            assistantId,
            id
        };
        this._uri = `/Assistants/${assistantId}/Knowledge/${id}`;
    }
    create(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.create({
            uri: instance._uri,
            method: "post",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new AssistantsKnowledgeInstance(operationVersion, payload, instance._solution.assistantId, instance._solution.id));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    createWithHttpInfo(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.createWithResponseInfo({
            uri: instance._uri,
            method: "post",
            headers
        }).then((response)=>({
                ...response,
                body: new AssistantsKnowledgeInstance(operationVersion, response.body, instance._solution.assistantId, instance._solution.id)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    remove(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.remove({
            uri: instance._uri,
            method: "delete",
            headers
        });
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    removeWithHttpInfo(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version;
        // DELETE operation - returns boolean based on status code
        let operationPromise = operationVersion.removeWithResponseInfo({
            uri: instance._uri,
            method: "delete",
            headers
        }).then((response)=>({
                ...response,
                body: response.statusCode === 204
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.AssistantsKnowledgeContextImpl = AssistantsKnowledgeContextImpl;
class AssistantsKnowledgeInstance {
    constructor(_version, payload, assistantId, id){
        this._version = _version;
        this.description = payload.description;
        this.id = payload.id;
        this.accountSid = payload.account_sid;
        this.knowledgeSourceDetails = payload.knowledge_source_details;
        this.name = payload.name;
        this.status = payload.status;
        this.type = payload.type;
        this.url = payload.url;
        this.embeddingModel = payload.embedding_model;
        this.dateCreated = deserialize.iso8601DateTime(payload.date_created);
        this.dateUpdated = deserialize.iso8601DateTime(payload.date_updated);
        this._solution = {
            assistantId,
            id: id || this.id
        };
    }
    get _proxy() {
        this._context = this._context || new AssistantsKnowledgeContextImpl(this._version, this._solution.assistantId, this._solution.id);
        return this._context;
    }
    /**
     * Create a AssistantsKnowledgeInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed AssistantsKnowledgeInstance
     */ create(callback) {
        return this._proxy.create(callback);
    }
    /**
     * Create a AssistantsKnowledgeInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed AssistantsKnowledgeInstance with HTTP metadata
     */ createWithHttpInfo(callback) {
        return this._proxy.createWithHttpInfo(callback);
    }
    /**
     * Remove a AssistantsKnowledgeInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean
     */ remove(callback) {
        return this._proxy.remove(callback);
    }
    /**
     * Remove a AssistantsKnowledgeInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean with HTTP metadata
     */ removeWithHttpInfo(callback) {
        return this._proxy.removeWithHttpInfo(callback);
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            description: this.description,
            id: this.id,
            accountSid: this.accountSid,
            knowledgeSourceDetails: this.knowledgeSourceDetails,
            name: this.name,
            status: this.status,
            type: this.type,
            url: this.url,
            embeddingModel: this.embeddingModel,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.AssistantsKnowledgeInstance = AssistantsKnowledgeInstance;
function AssistantsKnowledgeListInstance(version, assistantId) {
    if (!(0, utility_1.isValidPathParam)(assistantId)) {
        throw new Error("Parameter 'assistantId' is not valid.");
    }
    const instance = (id)=>instance.get(id);
    instance.get = function get(id) {
        return new AssistantsKnowledgeContextImpl(version, assistantId, id);
    };
    instance._version = version;
    instance._solution = {
        assistantId
    };
    instance._uri = `/Assistants/${assistantId}/Knowledge`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new AssistantsKnowledgePage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new AssistantsKnowledgePage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new AssistantsKnowledgePage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new AssistantsKnowledgePage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class AssistantsKnowledgePage extends Page_1.default {
    /**
     * Initialize the AssistantsKnowledgePage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of AssistantsKnowledgeInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new AssistantsKnowledgeInstance(this._version, payload, this._solution.assistantId);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.AssistantsKnowledgePage = AssistantsKnowledgePage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/assistants/v1/assistant/assistantsTool.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Assistants
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AssistantsToolPage = exports.AssistantsToolInstance = exports.AssistantsToolContextImpl = void 0;
exports.AssistantsToolListInstance = AssistantsToolListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
class AssistantsToolContextImpl {
    constructor(_version, assistantId, id){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(assistantId)) {
            throw new Error("Parameter 'assistantId' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(id)) {
            throw new Error("Parameter 'id' is not valid.");
        }
        this._solution = {
            assistantId,
            id
        };
        this._uri = `/Assistants/${assistantId}/Tools/${id}`;
    }
    create(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.create({
            uri: instance._uri,
            method: "post",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new AssistantsToolInstance(operationVersion, payload, instance._solution.assistantId, instance._solution.id));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    createWithHttpInfo(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.createWithResponseInfo({
            uri: instance._uri,
            method: "post",
            headers
        }).then((response)=>({
                ...response,
                body: new AssistantsToolInstance(operationVersion, response.body, instance._solution.assistantId, instance._solution.id)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    remove(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.remove({
            uri: instance._uri,
            method: "delete",
            headers
        });
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    removeWithHttpInfo(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version;
        // DELETE operation - returns boolean based on status code
        let operationPromise = operationVersion.removeWithResponseInfo({
            uri: instance._uri,
            method: "delete",
            headers
        }).then((response)=>({
                ...response,
                body: response.statusCode === 204
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.AssistantsToolContextImpl = AssistantsToolContextImpl;
class AssistantsToolInstance {
    constructor(_version, payload, assistantId, id){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.description = payload.description;
        this.enabled = payload.enabled;
        this.id = payload.id;
        this.meta = payload.meta;
        this.name = payload.name;
        this.requiresAuth = payload.requires_auth;
        this.type = payload.type;
        this.url = payload.url;
        this.dateCreated = deserialize.iso8601DateTime(payload.date_created);
        this.dateUpdated = deserialize.iso8601DateTime(payload.date_updated);
        this._solution = {
            assistantId,
            id: id || this.id
        };
    }
    get _proxy() {
        this._context = this._context || new AssistantsToolContextImpl(this._version, this._solution.assistantId, this._solution.id);
        return this._context;
    }
    /**
     * Create a AssistantsToolInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed AssistantsToolInstance
     */ create(callback) {
        return this._proxy.create(callback);
    }
    /**
     * Create a AssistantsToolInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed AssistantsToolInstance with HTTP metadata
     */ createWithHttpInfo(callback) {
        return this._proxy.createWithHttpInfo(callback);
    }
    /**
     * Remove a AssistantsToolInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean
     */ remove(callback) {
        return this._proxy.remove(callback);
    }
    /**
     * Remove a AssistantsToolInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean with HTTP metadata
     */ removeWithHttpInfo(callback) {
        return this._proxy.removeWithHttpInfo(callback);
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            description: this.description,
            enabled: this.enabled,
            id: this.id,
            meta: this.meta,
            name: this.name,
            requiresAuth: this.requiresAuth,
            type: this.type,
            url: this.url,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.AssistantsToolInstance = AssistantsToolInstance;
function AssistantsToolListInstance(version, assistantId) {
    if (!(0, utility_1.isValidPathParam)(assistantId)) {
        throw new Error("Parameter 'assistantId' is not valid.");
    }
    const instance = (id)=>instance.get(id);
    instance.get = function get(id) {
        return new AssistantsToolContextImpl(version, assistantId, id);
    };
    instance._version = version;
    instance._solution = {
        assistantId
    };
    instance._uri = `/Assistants/${assistantId}/Tools`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new AssistantsToolPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new AssistantsToolPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new AssistantsToolPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new AssistantsToolPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class AssistantsToolPage extends Page_1.default {
    /**
     * Initialize the AssistantsToolPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of AssistantsToolInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new AssistantsToolInstance(this._version, payload, this._solution.assistantId);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.AssistantsToolPage = AssistantsToolPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/assistants/v1/assistant/feedback.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Assistants
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FeedbackPage = exports.FeedbackInstance = exports.AssistantsV1ServiceCreateFeedbackRequest = void 0;
exports.FeedbackListInstance = FeedbackListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
class AssistantsV1ServiceCreateFeedbackRequest {
}
exports.AssistantsV1ServiceCreateFeedbackRequest = AssistantsV1ServiceCreateFeedbackRequest;
function FeedbackListInstance(version, id) {
    if (!(0, utility_1.isValidPathParam)(id)) {
        throw new Error("Parameter 'id' is not valid.");
    }
    const instance = {};
    instance._version = version;
    instance._solution = {
        id
    };
    instance._uri = `/Assistants/${id}/Feedbacks`;
    instance.create = function create(params, headers, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        let data = {};
        data = params;
        if (headers === null || headers === undefined) {
            headers = {};
        }
        headers["Content-Type"] = "application/json";
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.create({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new FeedbackInstance(operationVersion, payload, instance._solution.id));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.createWithHttpInfo = function createWithHttpInfo(params, headers, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        let data = {};
        data = params;
        if (headers === null || headers === undefined) {
            headers = {};
        }
        headers["Content-Type"] = "application/json";
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.createWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new FeedbackInstance(operationVersion, response.body, instance._solution.id)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new FeedbackPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new FeedbackPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new FeedbackPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new FeedbackPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class FeedbackInstance {
    constructor(_version, payload, id){
        this._version = _version;
        this.assistantId = payload.assistant_id;
        this.id = payload.id;
        this.accountSid = payload.account_sid;
        this.userSid = payload.user_sid;
        this.messageId = payload.message_id;
        this.score = payload.score;
        this.sessionId = payload.session_id;
        this.text = payload.text;
        this.dateCreated = deserialize.iso8601DateTime(payload.date_created);
        this.dateUpdated = deserialize.iso8601DateTime(payload.date_updated);
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            assistantId: this.assistantId,
            id: this.id,
            accountSid: this.accountSid,
            userSid: this.userSid,
            messageId: this.messageId,
            score: this.score,
            sessionId: this.sessionId,
            text: this.text,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.FeedbackInstance = FeedbackInstance;
class FeedbackPage extends Page_1.default {
    /**
     * Initialize the FeedbackPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of FeedbackInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new FeedbackInstance(this._version, payload, this._solution.id);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.FeedbackPage = FeedbackPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/assistants/v1/assistant/message.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Assistants
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MessageInstance = exports.AssistantsV1ServiceAssistantSendMessageRequest = void 0;
exports.MessageListInstance = MessageListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
class AssistantsV1ServiceAssistantSendMessageRequest {
}
exports.AssistantsV1ServiceAssistantSendMessageRequest = AssistantsV1ServiceAssistantSendMessageRequest;
function MessageListInstance(version, id) {
    if (!(0, utility_1.isValidPathParam)(id)) {
        throw new Error("Parameter 'id' is not valid.");
    }
    const instance = {};
    instance._version = version;
    instance._solution = {
        id
    };
    instance._uri = `/Assistants/${id}/Messages`;
    instance.create = function create(params, headers, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        let data = {};
        data = params;
        if (headers === null || headers === undefined) {
            headers = {};
        }
        headers["Content-Type"] = "application/json";
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.create({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new MessageInstance(operationVersion, payload, instance._solution.id));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.createWithHttpInfo = function createWithHttpInfo(params, headers, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        let data = {};
        data = params;
        if (headers === null || headers === undefined) {
            headers = {};
        }
        headers["Content-Type"] = "application/json";
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.createWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new MessageInstance(operationVersion, response.body, instance._solution.id)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class MessageInstance {
    constructor(_version, payload, id){
        this._version = _version;
        this.status = payload.status;
        this.flagged = payload.flagged;
        this.aborted = payload.aborted;
        this.sessionId = payload.session_id;
        this.accountSid = payload.account_sid;
        this.body = payload.body;
        this.error = payload.error;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            status: this.status,
            flagged: this.flagged,
            aborted: this.aborted,
            sessionId: this.sessionId,
            accountSid: this.accountSid,
            body: this.body,
            error: this.error
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.MessageInstance = MessageInstance;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/assistants/v1/assistant.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Assistants
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AssistantPage = exports.AssistantInstance = exports.AssistantContextImpl = exports.AssistantsV1ServiceUpdateAssistantRequest = exports.AssistantsV1ServiceTool = exports.AssistantsV1ServiceSegmentCredential = exports.AssistantsV1ServiceKnowledge = exports.AssistantsV1ServiceCustomerAi = exports.AssistantsV1ServiceCreateAssistantRequest = void 0;
exports.AssistantListInstance = AssistantListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
const assistantsKnowledge_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/assistants/v1/assistant/assistantsKnowledge.js [app-route] (ecmascript)");
const assistantsTool_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/assistants/v1/assistant/assistantsTool.js [app-route] (ecmascript)");
const feedback_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/assistants/v1/assistant/feedback.js [app-route] (ecmascript)");
const message_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/assistants/v1/assistant/message.js [app-route] (ecmascript)");
class AssistantsV1ServiceCreateAssistantRequest {
}
exports.AssistantsV1ServiceCreateAssistantRequest = AssistantsV1ServiceCreateAssistantRequest;
class AssistantsV1ServiceCustomerAi {
}
exports.AssistantsV1ServiceCustomerAi = AssistantsV1ServiceCustomerAi;
class AssistantsV1ServiceKnowledge {
}
exports.AssistantsV1ServiceKnowledge = AssistantsV1ServiceKnowledge;
class AssistantsV1ServiceSegmentCredential {
}
exports.AssistantsV1ServiceSegmentCredential = AssistantsV1ServiceSegmentCredential;
class AssistantsV1ServiceTool {
}
exports.AssistantsV1ServiceTool = AssistantsV1ServiceTool;
class AssistantsV1ServiceUpdateAssistantRequest {
}
exports.AssistantsV1ServiceUpdateAssistantRequest = AssistantsV1ServiceUpdateAssistantRequest;
class AssistantContextImpl {
    constructor(_version, id){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(id)) {
            throw new Error("Parameter 'id' is not valid.");
        }
        this._solution = {
            id
        };
        this._uri = `/Assistants/${id}`;
    }
    get assistantsKnowledge() {
        this._assistantsKnowledge = this._assistantsKnowledge || (0, assistantsKnowledge_1.AssistantsKnowledgeListInstance)(this._version, this._solution.id);
        return this._assistantsKnowledge;
    }
    get assistantsTools() {
        this._assistantsTools = this._assistantsTools || (0, assistantsTool_1.AssistantsToolListInstance)(this._version, this._solution.id);
        return this._assistantsTools;
    }
    get feedbacks() {
        this._feedbacks = this._feedbacks || (0, feedback_1.FeedbackListInstance)(this._version, this._solution.id);
        return this._feedbacks;
    }
    get messages() {
        this._messages = this._messages || (0, message_1.MessageListInstance)(this._version, this._solution.id);
        return this._messages;
    }
    remove(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.remove({
            uri: instance._uri,
            method: "delete",
            headers
        });
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    removeWithHttpInfo(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version;
        // DELETE operation - returns boolean based on status code
        let operationPromise = operationVersion.removeWithResponseInfo({
            uri: instance._uri,
            method: "delete",
            headers
        }).then((response)=>({
                ...response,
                body: response.statusCode === 204
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new AssistantInstance(operationVersion, payload, instance._solution.id));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new AssistantInstance(operationVersion, response.body, instance._solution.id)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    update(params, headers, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        data = params;
        if (headers === null || headers === undefined) {
            headers = {};
        }
        headers["Content-Type"] = "application/json";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.update({
            uri: instance._uri,
            method: "put",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new AssistantInstance(operationVersion, payload, instance._solution.id));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    updateWithHttpInfo(params, headers, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        data = params;
        if (headers === null || headers === undefined) {
            headers = {};
        }
        headers["Content-Type"] = "application/json";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.updateWithResponseInfo({
            uri: instance._uri,
            method: "put",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new AssistantInstance(operationVersion, response.body, instance._solution.id)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.AssistantContextImpl = AssistantContextImpl;
class AssistantInstance {
    constructor(_version, payload, id){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.customerAi = payload.customer_ai;
        this.id = payload.id;
        this.model = payload.model;
        this.name = payload.name;
        this.owner = payload.owner;
        this.url = payload.url;
        this.personalityPrompt = payload.personality_prompt;
        this.dateCreated = deserialize.iso8601DateTime(payload.date_created);
        this.dateUpdated = deserialize.iso8601DateTime(payload.date_updated);
        this.knowledge = payload.knowledge;
        this.tools = payload.tools;
        this._solution = {
            id: id || this.id
        };
    }
    get _proxy() {
        this._context = this._context || new AssistantContextImpl(this._version, this._solution.id);
        return this._context;
    }
    /**
     * Remove a AssistantInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean
     */ remove(callback) {
        return this._proxy.remove(callback);
    }
    /**
     * Remove a AssistantInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean with HTTP metadata
     */ removeWithHttpInfo(callback) {
        return this._proxy.removeWithHttpInfo(callback);
    }
    /**
     * Fetch a AssistantInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed AssistantInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a AssistantInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed AssistantInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    update(params, callback) {
        return this._proxy.update(params, callback);
    }
    updateWithHttpInfo(params, callback) {
        return this._proxy.updateWithHttpInfo(params, callback);
    }
    /**
     * Access the assistantsKnowledge.
     */ assistantsKnowledge() {
        return this._proxy.assistantsKnowledge;
    }
    /**
     * Access the assistantsTools.
     */ assistantsTools() {
        return this._proxy.assistantsTools;
    }
    /**
     * Access the feedbacks.
     */ feedbacks() {
        return this._proxy.feedbacks;
    }
    /**
     * Access the messages.
     */ messages() {
        return this._proxy.messages;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            customerAi: this.customerAi,
            id: this.id,
            model: this.model,
            name: this.name,
            owner: this.owner,
            url: this.url,
            personalityPrompt: this.personalityPrompt,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated,
            knowledge: this.knowledge,
            tools: this.tools
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.AssistantInstance = AssistantInstance;
function AssistantListInstance(version) {
    const instance = (id)=>instance.get(id);
    instance.get = function get(id) {
        return new AssistantContextImpl(version, id);
    };
    instance._version = version;
    instance._solution = {};
    instance._uri = `/Assistants`;
    instance.create = function create(params, headers, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        let data = {};
        data = params;
        if (headers === null || headers === undefined) {
            headers = {};
        }
        headers["Content-Type"] = "application/json";
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.create({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new AssistantInstance(operationVersion, payload));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.createWithHttpInfo = function createWithHttpInfo(params, headers, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        let data = {};
        data = params;
        if (headers === null || headers === undefined) {
            headers = {};
        }
        headers["Content-Type"] = "application/json";
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.createWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new AssistantInstance(operationVersion, response.body)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new AssistantPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new AssistantPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new AssistantPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new AssistantPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class AssistantPage extends Page_1.default {
    /**
     * Initialize the AssistantPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of AssistantInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new AssistantInstance(this._version, payload);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.AssistantPage = AssistantPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/assistants/v1/knowledge/chunk.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Assistants
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ChunkPage = exports.ChunkInstance = void 0;
exports.ChunkListInstance = ChunkListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
function ChunkListInstance(version, id) {
    if (!(0, utility_1.isValidPathParam)(id)) {
        throw new Error("Parameter 'id' is not valid.");
    }
    const instance = {};
    instance._version = version;
    instance._solution = {
        id
    };
    instance._uri = `/Knowledge/${id}/Chunks`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new ChunkPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new ChunkPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new ChunkPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new ChunkPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class ChunkInstance {
    constructor(_version, payload, id){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.content = payload.content;
        this.metadata = payload.metadata;
        this.dateCreated = deserialize.iso8601DateTime(payload.date_created);
        this.dateUpdated = deserialize.iso8601DateTime(payload.date_updated);
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            content: this.content,
            metadata: this.metadata,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.ChunkInstance = ChunkInstance;
class ChunkPage extends Page_1.default {
    /**
     * Initialize the ChunkPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of ChunkInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new ChunkInstance(this._version, payload, this._solution.id);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.ChunkPage = ChunkPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/assistants/v1/knowledge/knowledgeStatus.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Assistants
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.KnowledgeStatusInstance = exports.KnowledgeStatusContextImpl = void 0;
exports.KnowledgeStatusListInstance = KnowledgeStatusListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
class KnowledgeStatusContextImpl {
    constructor(_version, id){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(id)) {
            throw new Error("Parameter 'id' is not valid.");
        }
        this._solution = {
            id
        };
        this._uri = `/Knowledge/${id}/Status`;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new KnowledgeStatusInstance(operationVersion, payload, instance._solution.id));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new KnowledgeStatusInstance(operationVersion, response.body, instance._solution.id)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.KnowledgeStatusContextImpl = KnowledgeStatusContextImpl;
class KnowledgeStatusInstance {
    constructor(_version, payload, id){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.status = payload.status;
        this.lastStatus = payload.last_status;
        this.dateUpdated = deserialize.iso8601DateTime(payload.date_updated);
        this._solution = {
            id
        };
    }
    get _proxy() {
        this._context = this._context || new KnowledgeStatusContextImpl(this._version, this._solution.id);
        return this._context;
    }
    /**
     * Fetch a KnowledgeStatusInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed KnowledgeStatusInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a KnowledgeStatusInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed KnowledgeStatusInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            status: this.status,
            lastStatus: this.lastStatus,
            dateUpdated: this.dateUpdated
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.KnowledgeStatusInstance = KnowledgeStatusInstance;
function KnowledgeStatusListInstance(version, id) {
    if (!(0, utility_1.isValidPathParam)(id)) {
        throw new Error("Parameter 'id' is not valid.");
    }
    const instance = ()=>instance.get();
    instance.get = function get() {
        return new KnowledgeStatusContextImpl(version, id);
    };
    instance._version = version;
    instance._solution = {
        id
    };
    instance._uri = ``;
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/assistants/v1/knowledge.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Assistants
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.KnowledgePage = exports.KnowledgeInstance = exports.KnowledgeContextImpl = exports.AssistantsV1ServiceUpdateKnowledgeRequest = exports.AssistantsV1ServiceCreatePolicyRequest = exports.AssistantsV1ServiceCreateKnowledgeRequest = void 0;
exports.KnowledgeListInstance = KnowledgeListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
const chunk_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/assistants/v1/knowledge/chunk.js [app-route] (ecmascript)");
const knowledgeStatus_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/assistants/v1/knowledge/knowledgeStatus.js [app-route] (ecmascript)");
class AssistantsV1ServiceCreateKnowledgeRequest {
}
exports.AssistantsV1ServiceCreateKnowledgeRequest = AssistantsV1ServiceCreateKnowledgeRequest;
class AssistantsV1ServiceCreatePolicyRequest {
}
exports.AssistantsV1ServiceCreatePolicyRequest = AssistantsV1ServiceCreatePolicyRequest;
class AssistantsV1ServiceUpdateKnowledgeRequest {
}
exports.AssistantsV1ServiceUpdateKnowledgeRequest = AssistantsV1ServiceUpdateKnowledgeRequest;
class KnowledgeContextImpl {
    constructor(_version, id){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(id)) {
            throw new Error("Parameter 'id' is not valid.");
        }
        this._solution = {
            id
        };
        this._uri = `/Knowledge/${id}`;
    }
    get chunks() {
        this._chunks = this._chunks || (0, chunk_1.ChunkListInstance)(this._version, this._solution.id);
        return this._chunks;
    }
    get knowledgeStatus() {
        this._knowledgeStatus = this._knowledgeStatus || (0, knowledgeStatus_1.KnowledgeStatusListInstance)(this._version, this._solution.id);
        return this._knowledgeStatus;
    }
    remove(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.remove({
            uri: instance._uri,
            method: "delete",
            headers
        });
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    removeWithHttpInfo(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version;
        // DELETE operation - returns boolean based on status code
        let operationPromise = operationVersion.removeWithResponseInfo({
            uri: instance._uri,
            method: "delete",
            headers
        }).then((response)=>({
                ...response,
                body: response.statusCode === 204
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new KnowledgeInstance(operationVersion, payload, instance._solution.id));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new KnowledgeInstance(operationVersion, response.body, instance._solution.id)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    update(params, headers, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        data = params;
        if (headers === null || headers === undefined) {
            headers = {};
        }
        headers["Content-Type"] = "application/json";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.update({
            uri: instance._uri,
            method: "put",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new KnowledgeInstance(operationVersion, payload, instance._solution.id));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    updateWithHttpInfo(params, headers, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        data = params;
        if (headers === null || headers === undefined) {
            headers = {};
        }
        headers["Content-Type"] = "application/json";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.updateWithResponseInfo({
            uri: instance._uri,
            method: "put",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new KnowledgeInstance(operationVersion, response.body, instance._solution.id)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.KnowledgeContextImpl = KnowledgeContextImpl;
class KnowledgeInstance {
    constructor(_version, payload, id){
        this._version = _version;
        this.description = payload.description;
        this.id = payload.id;
        this.accountSid = payload.account_sid;
        this.knowledgeSourceDetails = payload.knowledge_source_details;
        this.name = payload.name;
        this.status = payload.status;
        this.type = payload.type;
        this.url = payload.url;
        this.embeddingModel = payload.embedding_model;
        this.dateCreated = deserialize.iso8601DateTime(payload.date_created);
        this.dateUpdated = deserialize.iso8601DateTime(payload.date_updated);
        this._solution = {
            id: id || this.id
        };
    }
    get _proxy() {
        this._context = this._context || new KnowledgeContextImpl(this._version, this._solution.id);
        return this._context;
    }
    /**
     * Remove a KnowledgeInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean
     */ remove(callback) {
        return this._proxy.remove(callback);
    }
    /**
     * Remove a KnowledgeInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean with HTTP metadata
     */ removeWithHttpInfo(callback) {
        return this._proxy.removeWithHttpInfo(callback);
    }
    /**
     * Fetch a KnowledgeInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed KnowledgeInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a KnowledgeInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed KnowledgeInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    update(params, callback) {
        return this._proxy.update(params, callback);
    }
    updateWithHttpInfo(params, callback) {
        return this._proxy.updateWithHttpInfo(params, callback);
    }
    /**
     * Access the chunks.
     */ chunks() {
        return this._proxy.chunks;
    }
    /**
     * Access the knowledgeStatus.
     */ knowledgeStatus() {
        return this._proxy.knowledgeStatus;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            description: this.description,
            id: this.id,
            accountSid: this.accountSid,
            knowledgeSourceDetails: this.knowledgeSourceDetails,
            name: this.name,
            status: this.status,
            type: this.type,
            url: this.url,
            embeddingModel: this.embeddingModel,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.KnowledgeInstance = KnowledgeInstance;
function KnowledgeListInstance(version) {
    const instance = (id)=>instance.get(id);
    instance.get = function get(id) {
        return new KnowledgeContextImpl(version, id);
    };
    instance._version = version;
    instance._solution = {};
    instance._uri = `/Knowledge`;
    instance.create = function create(params, headers, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        let data = {};
        data = params;
        if (headers === null || headers === undefined) {
            headers = {};
        }
        headers["Content-Type"] = "application/json";
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.create({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new KnowledgeInstance(operationVersion, payload));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.createWithHttpInfo = function createWithHttpInfo(params, headers, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        let data = {};
        data = params;
        if (headers === null || headers === undefined) {
            headers = {};
        }
        headers["Content-Type"] = "application/json";
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.createWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new KnowledgeInstance(operationVersion, response.body)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["assistantId"] !== undefined) data["AssistantId"] = params["assistantId"];
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new KnowledgePage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new KnowledgePage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["assistantId"] !== undefined) data["AssistantId"] = params["assistantId"];
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new KnowledgePage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new KnowledgePage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class KnowledgePage extends Page_1.default {
    /**
     * Initialize the KnowledgePage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of KnowledgeInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new KnowledgeInstance(this._version, payload);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.KnowledgePage = KnowledgePage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/assistants/v1/policy.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Assistants
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PolicyPage = exports.PolicyInstance = void 0;
exports.PolicyListInstance = PolicyListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
function PolicyListInstance(version) {
    const instance = {};
    instance._version = version;
    instance._solution = {};
    instance._uri = `/Policies`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["toolId"] !== undefined) data["ToolId"] = params["toolId"];
        if (params["knowledgeId"] !== undefined) data["KnowledgeId"] = params["knowledgeId"];
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new PolicyPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new PolicyPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["toolId"] !== undefined) data["ToolId"] = params["toolId"];
        if (params["knowledgeId"] !== undefined) data["KnowledgeId"] = params["knowledgeId"];
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new PolicyPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new PolicyPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class PolicyInstance {
    constructor(_version, payload){
        this._version = _version;
        this.id = payload.id;
        this.name = payload.name;
        this.description = payload.description;
        this.accountSid = payload.account_sid;
        this.userSid = payload.user_sid;
        this.type = payload.type;
        this.policyDetails = payload.policy_details;
        this.dateCreated = deserialize.iso8601DateTime(payload.date_created);
        this.dateUpdated = deserialize.iso8601DateTime(payload.date_updated);
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            id: this.id,
            name: this.name,
            description: this.description,
            accountSid: this.accountSid,
            userSid: this.userSid,
            type: this.type,
            policyDetails: this.policyDetails,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.PolicyInstance = PolicyInstance;
class PolicyPage extends Page_1.default {
    /**
     * Initialize the PolicyPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of PolicyInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new PolicyInstance(this._version, payload);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.PolicyPage = PolicyPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/assistants/v1/session/message.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Assistants
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MessagePage = exports.MessageInstance = void 0;
exports.MessageListInstance = MessageListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
function MessageListInstance(version, sessionId) {
    if (!(0, utility_1.isValidPathParam)(sessionId)) {
        throw new Error("Parameter 'sessionId' is not valid.");
    }
    const instance = {};
    instance._version = version;
    instance._solution = {
        sessionId
    };
    instance._uri = `/Sessions/${sessionId}/Messages`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new MessagePage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new MessagePage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new MessagePage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new MessagePage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class MessageInstance {
    constructor(_version, payload, sessionId){
        this._version = _version;
        this.id = payload.id;
        this.accountSid = payload.account_sid;
        this.assistantId = payload.assistant_id;
        this.sessionId = payload.session_id;
        this.identity = payload.identity;
        this.role = payload.role;
        this.content = payload.content;
        this.meta = payload.meta;
        this.dateCreated = deserialize.iso8601DateTime(payload.date_created);
        this.dateUpdated = deserialize.iso8601DateTime(payload.date_updated);
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            id: this.id,
            accountSid: this.accountSid,
            assistantId: this.assistantId,
            sessionId: this.sessionId,
            identity: this.identity,
            role: this.role,
            content: this.content,
            meta: this.meta,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.MessageInstance = MessageInstance;
class MessagePage extends Page_1.default {
    /**
     * Initialize the MessagePage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of MessageInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new MessageInstance(this._version, payload, this._solution.sessionId);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.MessagePage = MessagePage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/assistants/v1/session.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Assistants
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SessionPage = exports.SessionInstance = exports.SessionContextImpl = void 0;
exports.SessionListInstance = SessionListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
const message_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/assistants/v1/session/message.js [app-route] (ecmascript)");
class SessionContextImpl {
    constructor(_version, id){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(id)) {
            throw new Error("Parameter 'id' is not valid.");
        }
        this._solution = {
            id
        };
        this._uri = `/Sessions/${id}`;
    }
    get messages() {
        this._messages = this._messages || (0, message_1.MessageListInstance)(this._version, this._solution.id);
        return this._messages;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new SessionInstance(operationVersion, payload, instance._solution.id));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new SessionInstance(operationVersion, response.body, instance._solution.id)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.SessionContextImpl = SessionContextImpl;
class SessionInstance {
    constructor(_version, payload, id){
        this._version = _version;
        this.id = payload.id;
        this.accountSid = payload.account_sid;
        this.assistantId = payload.assistant_id;
        this.verified = payload.verified;
        this.identity = payload.identity;
        this.dateCreated = deserialize.iso8601DateTime(payload.date_created);
        this.dateUpdated = deserialize.iso8601DateTime(payload.date_updated);
        this._solution = {
            id: id || this.id
        };
    }
    get _proxy() {
        this._context = this._context || new SessionContextImpl(this._version, this._solution.id);
        return this._context;
    }
    /**
     * Fetch a SessionInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed SessionInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a SessionInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed SessionInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    /**
     * Access the messages.
     */ messages() {
        return this._proxy.messages;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            id: this.id,
            accountSid: this.accountSid,
            assistantId: this.assistantId,
            verified: this.verified,
            identity: this.identity,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.SessionInstance = SessionInstance;
function SessionListInstance(version) {
    const instance = (id)=>instance.get(id);
    instance.get = function get(id) {
        return new SessionContextImpl(version, id);
    };
    instance._version = version;
    instance._solution = {};
    instance._uri = `/Sessions`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new SessionPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new SessionPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new SessionPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new SessionPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class SessionPage extends Page_1.default {
    /**
     * Initialize the SessionPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of SessionInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new SessionInstance(this._version, payload);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.SessionPage = SessionPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/assistants/v1/tool.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Assistants
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ToolPage = exports.ToolInstance = exports.ToolContextImpl = exports.AssistantsV1ServiceUpdateToolRequest = exports.AssistantsV1ServicePolicy = exports.AssistantsV1ServiceCreateToolRequest = exports.AssistantsV1ServiceCreatePolicyRequest = void 0;
exports.ToolListInstance = ToolListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
class AssistantsV1ServiceCreatePolicyRequest {
}
exports.AssistantsV1ServiceCreatePolicyRequest = AssistantsV1ServiceCreatePolicyRequest;
class AssistantsV1ServiceCreateToolRequest {
}
exports.AssistantsV1ServiceCreateToolRequest = AssistantsV1ServiceCreateToolRequest;
class AssistantsV1ServicePolicy {
}
exports.AssistantsV1ServicePolicy = AssistantsV1ServicePolicy;
class AssistantsV1ServiceUpdateToolRequest {
}
exports.AssistantsV1ServiceUpdateToolRequest = AssistantsV1ServiceUpdateToolRequest;
class ToolContextImpl {
    constructor(_version, id){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(id)) {
            throw new Error("Parameter 'id' is not valid.");
        }
        this._solution = {
            id
        };
        this._uri = `/Tools/${id}`;
    }
    remove(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.remove({
            uri: instance._uri,
            method: "delete",
            headers
        });
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    removeWithHttpInfo(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version;
        // DELETE operation - returns boolean based on status code
        let operationPromise = operationVersion.removeWithResponseInfo({
            uri: instance._uri,
            method: "delete",
            headers
        }).then((response)=>({
                ...response,
                body: response.statusCode === 204
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new ToolInstance(operationVersion, payload, instance._solution.id));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new ToolInstance(operationVersion, response.body, instance._solution.id)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    update(params, headers, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        data = params;
        if (headers === null || headers === undefined) {
            headers = {};
        }
        headers["Content-Type"] = "application/json";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.update({
            uri: instance._uri,
            method: "put",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new ToolInstance(operationVersion, payload, instance._solution.id));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    updateWithHttpInfo(params, headers, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        data = params;
        if (headers === null || headers === undefined) {
            headers = {};
        }
        headers["Content-Type"] = "application/json";
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.updateWithResponseInfo({
            uri: instance._uri,
            method: "put",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new ToolInstance(operationVersion, response.body, instance._solution.id)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.ToolContextImpl = ToolContextImpl;
class ToolInstance {
    constructor(_version, payload, id){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.description = payload.description;
        this.enabled = payload.enabled;
        this.id = payload.id;
        this.meta = payload.meta;
        this.name = payload.name;
        this.requiresAuth = payload.requires_auth;
        this.type = payload.type;
        this.url = payload.url;
        this.dateCreated = deserialize.iso8601DateTime(payload.date_created);
        this.dateUpdated = deserialize.iso8601DateTime(payload.date_updated);
        this.policies = payload.policies;
        this._solution = {
            id: id || this.id
        };
    }
    get _proxy() {
        this._context = this._context || new ToolContextImpl(this._version, this._solution.id);
        return this._context;
    }
    /**
     * Remove a ToolInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean
     */ remove(callback) {
        return this._proxy.remove(callback);
    }
    /**
     * Remove a ToolInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean with HTTP metadata
     */ removeWithHttpInfo(callback) {
        return this._proxy.removeWithHttpInfo(callback);
    }
    /**
     * Fetch a ToolInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed ToolInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a ToolInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed ToolInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    update(params, callback) {
        return this._proxy.update(params, callback);
    }
    updateWithHttpInfo(params, callback) {
        return this._proxy.updateWithHttpInfo(params, callback);
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            description: this.description,
            enabled: this.enabled,
            id: this.id,
            meta: this.meta,
            name: this.name,
            requiresAuth: this.requiresAuth,
            type: this.type,
            url: this.url,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated,
            policies: this.policies
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.ToolInstance = ToolInstance;
function ToolListInstance(version) {
    const instance = (id)=>instance.get(id);
    instance.get = function get(id) {
        return new ToolContextImpl(version, id);
    };
    instance._version = version;
    instance._solution = {};
    instance._uri = `/Tools`;
    instance.create = function create(params, headers, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        let data = {};
        data = params;
        if (headers === null || headers === undefined) {
            headers = {};
        }
        headers["Content-Type"] = "application/json";
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.create({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new ToolInstance(operationVersion, payload));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.createWithHttpInfo = function createWithHttpInfo(params, headers, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        let data = {};
        data = params;
        if (headers === null || headers === undefined) {
            headers = {};
        }
        headers["Content-Type"] = "application/json";
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.createWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new ToolInstance(operationVersion, response.body)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["assistantId"] !== undefined) data["AssistantId"] = params["assistantId"];
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new ToolPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new ToolPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["assistantId"] !== undefined) data["AssistantId"] = params["assistantId"];
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new ToolPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new ToolPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class ToolPage extends Page_1.default {
    /**
     * Initialize the ToolPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of ToolInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new ToolInstance(this._version, payload);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.ToolPage = ToolPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/assistants/V1.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Assistants
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
const Version_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Version.js [app-route] (ecmascript)"));
const assistant_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/assistants/v1/assistant.js [app-route] (ecmascript)");
const knowledge_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/assistants/v1/knowledge.js [app-route] (ecmascript)");
const policy_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/assistants/v1/policy.js [app-route] (ecmascript)");
const session_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/assistants/v1/session.js [app-route] (ecmascript)");
const tool_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/assistants/v1/tool.js [app-route] (ecmascript)");
class V1 extends Version_1.default {
    /**
     * Initialize the V1 version of Assistants
     *
     * @param domain - The Twilio (Twilio.Assistants) domain
     */ constructor(domain){
        super(domain, "v1");
    }
    /** Getter for assistants resource */ get assistants() {
        this._assistants = this._assistants || (0, assistant_1.AssistantListInstance)(this);
        return this._assistants;
    }
    /** Getter for knowledge resource */ get knowledge() {
        this._knowledge = this._knowledge || (0, knowledge_1.KnowledgeListInstance)(this);
        return this._knowledge;
    }
    /** Getter for policies resource */ get policies() {
        this._policies = this._policies || (0, policy_1.PolicyListInstance)(this);
        return this._policies;
    }
    /** Getter for sessions resource */ get sessions() {
        this._sessions = this._sessions || (0, session_1.SessionListInstance)(this);
        return this._sessions;
    }
    /** Getter for tools resource */ get tools() {
        this._tools = this._tools || (0, tool_1.ToolListInstance)(this);
        return this._tools;
    }
}
exports.default = V1;
}),
];

//# sourceMappingURL=96e98_twilio_lib_rest_assistants_f14e9c67._.js.map