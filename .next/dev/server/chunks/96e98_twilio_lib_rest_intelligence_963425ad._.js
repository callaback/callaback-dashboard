module.exports = [
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/intelligence/v2/customOperator.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Intelligence
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CustomOperatorPage = exports.CustomOperatorInstance = exports.CustomOperatorContextImpl = void 0;
exports.CustomOperatorListInstance = CustomOperatorListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
class CustomOperatorContextImpl {
    constructor(_version, sid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(sid)) {
            throw new Error("Parameter 'sid' is not valid.");
        }
        this._solution = {
            sid
        };
        this._uri = `/Operators/Custom/${sid}`;
    }
    remove(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.remove({
            uri: instance._uri,
            method: "delete",
            headers
        });
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    removeWithHttpInfo(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version;
        // DELETE operation - returns boolean based on status code
        let operationPromise = operationVersion.removeWithResponseInfo({
            uri: instance._uri,
            method: "delete",
            headers
        }).then((response)=>({
                ...response,
                body: response.statusCode === 204
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new CustomOperatorInstance(operationVersion, payload, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new CustomOperatorInstance(operationVersion, response.body, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    update(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["friendlyName"] === null || params["friendlyName"] === undefined) {
            throw new Error("Required parameter \"params['friendlyName']\" missing.");
        }
        if (params["config"] === null || params["config"] === undefined) {
            throw new Error("Required parameter \"params['config']\" missing.");
        }
        let data = {};
        data["FriendlyName"] = params["friendlyName"];
        data["Config"] = serialize.object(params["config"]);
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        if (params["ifMatch"] !== undefined) headers["If-Match"] = params["ifMatch"];
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.update({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new CustomOperatorInstance(operationVersion, payload, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    updateWithHttpInfo(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["friendlyName"] === null || params["friendlyName"] === undefined) {
            throw new Error("Required parameter \"params['friendlyName']\" missing.");
        }
        if (params["config"] === null || params["config"] === undefined) {
            throw new Error("Required parameter \"params['config']\" missing.");
        }
        let data = {};
        data["FriendlyName"] = params["friendlyName"];
        data["Config"] = serialize.object(params["config"]);
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        if (params["ifMatch"] !== undefined) headers["If-Match"] = params["ifMatch"];
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.updateWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new CustomOperatorInstance(operationVersion, response.body, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.CustomOperatorContextImpl = CustomOperatorContextImpl;
class CustomOperatorInstance {
    constructor(_version, payload, sid){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.sid = payload.sid;
        this.friendlyName = payload.friendly_name;
        this.description = payload.description;
        this.author = payload.author;
        this.operatorType = payload.operator_type;
        this.version = deserialize.integer(payload.version);
        this.availability = payload.availability;
        this.config = payload.config;
        this.dateCreated = deserialize.iso8601DateTime(payload.date_created);
        this.dateUpdated = deserialize.iso8601DateTime(payload.date_updated);
        this.url = payload.url;
        this._solution = {
            sid: sid || this.sid
        };
    }
    get _proxy() {
        this._context = this._context || new CustomOperatorContextImpl(this._version, this._solution.sid);
        return this._context;
    }
    /**
     * Remove a CustomOperatorInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean
     */ remove(callback) {
        return this._proxy.remove(callback);
    }
    /**
     * Remove a CustomOperatorInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean with HTTP metadata
     */ removeWithHttpInfo(callback) {
        return this._proxy.removeWithHttpInfo(callback);
    }
    /**
     * Fetch a CustomOperatorInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed CustomOperatorInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a CustomOperatorInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed CustomOperatorInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    update(params, callback) {
        return this._proxy.update(params, callback);
    }
    updateWithHttpInfo(params, callback) {
        return this._proxy.updateWithHttpInfo(params, callback);
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            sid: this.sid,
            friendlyName: this.friendlyName,
            description: this.description,
            author: this.author,
            operatorType: this.operatorType,
            version: this.version,
            availability: this.availability,
            config: this.config,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated,
            url: this.url
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.CustomOperatorInstance = CustomOperatorInstance;
function CustomOperatorListInstance(version) {
    const instance = (sid)=>instance.get(sid);
    instance.get = function get(sid) {
        return new CustomOperatorContextImpl(version, sid);
    };
    instance._version = version;
    instance._solution = {};
    instance._uri = `/Operators/Custom`;
    instance.create = function create(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["friendlyName"] === null || params["friendlyName"] === undefined) {
            throw new Error("Required parameter \"params['friendlyName']\" missing.");
        }
        if (params["operatorType"] === null || params["operatorType"] === undefined) {
            throw new Error("Required parameter \"params['operatorType']\" missing.");
        }
        if (params["config"] === null || params["config"] === undefined) {
            throw new Error("Required parameter \"params['config']\" missing.");
        }
        let data = {};
        data["FriendlyName"] = params["friendlyName"];
        data["OperatorType"] = params["operatorType"];
        data["Config"] = serialize.object(params["config"]);
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.create({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new CustomOperatorInstance(operationVersion, payload));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.createWithHttpInfo = function createWithHttpInfo(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["friendlyName"] === null || params["friendlyName"] === undefined) {
            throw new Error("Required parameter \"params['friendlyName']\" missing.");
        }
        if (params["operatorType"] === null || params["operatorType"] === undefined) {
            throw new Error("Required parameter \"params['operatorType']\" missing.");
        }
        if (params["config"] === null || params["config"] === undefined) {
            throw new Error("Required parameter \"params['config']\" missing.");
        }
        let data = {};
        data["FriendlyName"] = params["friendlyName"];
        data["OperatorType"] = params["operatorType"];
        data["Config"] = serialize.object(params["config"]);
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.createWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new CustomOperatorInstance(operationVersion, response.body)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["availability"] !== undefined) data["Availability"] = params["availability"];
        if (params["languageCode"] !== undefined) data["LanguageCode"] = params["languageCode"];
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new CustomOperatorPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new CustomOperatorPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["availability"] !== undefined) data["Availability"] = params["availability"];
        if (params["languageCode"] !== undefined) data["LanguageCode"] = params["languageCode"];
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new CustomOperatorPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new CustomOperatorPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class CustomOperatorPage extends Page_1.default {
    /**
     * Initialize the CustomOperatorPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of CustomOperatorInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new CustomOperatorInstance(this._version, payload);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.CustomOperatorPage = CustomOperatorPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/intelligence/v2/operator.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Intelligence
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OperatorPage = exports.OperatorInstance = exports.OperatorContextImpl = void 0;
exports.OperatorListInstance = OperatorListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
class OperatorContextImpl {
    constructor(_version, sid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(sid)) {
            throw new Error("Parameter 'sid' is not valid.");
        }
        this._solution = {
            sid
        };
        this._uri = `/Operators/${sid}`;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new OperatorInstance(operationVersion, payload, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new OperatorInstance(operationVersion, response.body, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.OperatorContextImpl = OperatorContextImpl;
class OperatorInstance {
    constructor(_version, payload, sid){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.sid = payload.sid;
        this.friendlyName = payload.friendly_name;
        this.description = payload.description;
        this.author = payload.author;
        this.operatorType = payload.operator_type;
        this.version = deserialize.integer(payload.version);
        this.availability = payload.availability;
        this.config = payload.config;
        this.dateCreated = deserialize.iso8601DateTime(payload.date_created);
        this.dateUpdated = deserialize.iso8601DateTime(payload.date_updated);
        this.url = payload.url;
        this._solution = {
            sid: sid || this.sid
        };
    }
    get _proxy() {
        this._context = this._context || new OperatorContextImpl(this._version, this._solution.sid);
        return this._context;
    }
    /**
     * Fetch a OperatorInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed OperatorInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a OperatorInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed OperatorInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            sid: this.sid,
            friendlyName: this.friendlyName,
            description: this.description,
            author: this.author,
            operatorType: this.operatorType,
            version: this.version,
            availability: this.availability,
            config: this.config,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated,
            url: this.url
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.OperatorInstance = OperatorInstance;
function OperatorListInstance(version) {
    const instance = (sid)=>instance.get(sid);
    instance.get = function get(sid) {
        return new OperatorContextImpl(version, sid);
    };
    instance._version = version;
    instance._solution = {};
    instance._uri = `/Operators`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["availability"] !== undefined) data["Availability"] = params["availability"];
        if (params["languageCode"] !== undefined) data["LanguageCode"] = params["languageCode"];
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new OperatorPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new OperatorPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["availability"] !== undefined) data["Availability"] = params["availability"];
        if (params["languageCode"] !== undefined) data["LanguageCode"] = params["languageCode"];
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new OperatorPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new OperatorPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class OperatorPage extends Page_1.default {
    /**
     * Initialize the OperatorPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of OperatorInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new OperatorInstance(this._version, payload);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.OperatorPage = OperatorPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/intelligence/v2/operatorAttachment.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Intelligence
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OperatorAttachmentInstance = exports.OperatorAttachmentContextImpl = void 0;
exports.OperatorAttachmentListInstance = OperatorAttachmentListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
class OperatorAttachmentContextImpl {
    constructor(_version, serviceSid, operatorSid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(serviceSid)) {
            throw new Error("Parameter 'serviceSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(operatorSid)) {
            throw new Error("Parameter 'operatorSid' is not valid.");
        }
        this._solution = {
            serviceSid,
            operatorSid
        };
        this._uri = `/Services/${serviceSid}/Operators/${operatorSid}`;
    }
    create(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.create({
            uri: instance._uri,
            method: "post",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new OperatorAttachmentInstance(operationVersion, payload, instance._solution.serviceSid, instance._solution.operatorSid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    createWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.createWithResponseInfo({
            uri: instance._uri,
            method: "post",
            headers
        }).then((response)=>({
                ...response,
                body: new OperatorAttachmentInstance(operationVersion, response.body, instance._solution.serviceSid, instance._solution.operatorSid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    remove(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.remove({
            uri: instance._uri,
            method: "delete",
            headers
        });
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    removeWithHttpInfo(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version;
        // DELETE operation - returns boolean based on status code
        let operationPromise = operationVersion.removeWithResponseInfo({
            uri: instance._uri,
            method: "delete",
            headers
        }).then((response)=>({
                ...response,
                body: response.statusCode === 204
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.OperatorAttachmentContextImpl = OperatorAttachmentContextImpl;
class OperatorAttachmentInstance {
    constructor(_version, payload, serviceSid, operatorSid){
        this._version = _version;
        this.serviceSid = payload.service_sid;
        this.operatorSid = payload.operator_sid;
        this.url = payload.url;
        this._solution = {
            serviceSid: serviceSid || this.serviceSid,
            operatorSid: operatorSid || this.operatorSid
        };
    }
    get _proxy() {
        this._context = this._context || new OperatorAttachmentContextImpl(this._version, this._solution.serviceSid, this._solution.operatorSid);
        return this._context;
    }
    /**
     * Create a OperatorAttachmentInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed OperatorAttachmentInstance
     */ create(callback) {
        return this._proxy.create(callback);
    }
    /**
     * Create a OperatorAttachmentInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed OperatorAttachmentInstance with HTTP metadata
     */ createWithHttpInfo(callback) {
        return this._proxy.createWithHttpInfo(callback);
    }
    /**
     * Remove a OperatorAttachmentInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean
     */ remove(callback) {
        return this._proxy.remove(callback);
    }
    /**
     * Remove a OperatorAttachmentInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean with HTTP metadata
     */ removeWithHttpInfo(callback) {
        return this._proxy.removeWithHttpInfo(callback);
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            serviceSid: this.serviceSid,
            operatorSid: this.operatorSid,
            url: this.url
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.OperatorAttachmentInstance = OperatorAttachmentInstance;
function OperatorAttachmentListInstance(version) {
    const instance = (serviceSid, operatorSid)=>instance.get(serviceSid, operatorSid);
    instance.get = function get(serviceSid, operatorSid) {
        return new OperatorAttachmentContextImpl(version, serviceSid, operatorSid);
    };
    instance._version = version;
    instance._solution = {};
    instance._uri = ``;
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/intelligence/v2/operatorAttachments.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Intelligence
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OperatorAttachmentsInstance = exports.OperatorAttachmentsContextImpl = void 0;
exports.OperatorAttachmentsListInstance = OperatorAttachmentsListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
class OperatorAttachmentsContextImpl {
    constructor(_version, serviceSid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(serviceSid)) {
            throw new Error("Parameter 'serviceSid' is not valid.");
        }
        this._solution = {
            serviceSid
        };
        this._uri = `/Services/${serviceSid}/Operators`;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new OperatorAttachmentsInstance(operationVersion, payload, instance._solution.serviceSid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new OperatorAttachmentsInstance(operationVersion, response.body, instance._solution.serviceSid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.OperatorAttachmentsContextImpl = OperatorAttachmentsContextImpl;
class OperatorAttachmentsInstance {
    constructor(_version, payload, serviceSid){
        this._version = _version;
        this.serviceSid = payload.service_sid;
        this.operatorSids = payload.operator_sids;
        this.url = payload.url;
        this._solution = {
            serviceSid: serviceSid || this.serviceSid
        };
    }
    get _proxy() {
        this._context = this._context || new OperatorAttachmentsContextImpl(this._version, this._solution.serviceSid);
        return this._context;
    }
    /**
     * Fetch a OperatorAttachmentsInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed OperatorAttachmentsInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a OperatorAttachmentsInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed OperatorAttachmentsInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            serviceSid: this.serviceSid,
            operatorSids: this.operatorSids,
            url: this.url
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.OperatorAttachmentsInstance = OperatorAttachmentsInstance;
function OperatorAttachmentsListInstance(version) {
    const instance = (serviceSid)=>instance.get(serviceSid);
    instance.get = function get(serviceSid) {
        return new OperatorAttachmentsContextImpl(version, serviceSid);
    };
    instance._version = version;
    instance._solution = {};
    instance._uri = ``;
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/intelligence/v2/operatorType.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Intelligence
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OperatorTypePage = exports.OperatorTypeInstance = exports.OperatorTypeContextImpl = void 0;
exports.OperatorTypeListInstance = OperatorTypeListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
class OperatorTypeContextImpl {
    constructor(_version, sid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(sid)) {
            throw new Error("Parameter 'sid' is not valid.");
        }
        this._solution = {
            sid
        };
        this._uri = `/OperatorTypes/${sid}`;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new OperatorTypeInstance(operationVersion, payload, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new OperatorTypeInstance(operationVersion, response.body, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.OperatorTypeContextImpl = OperatorTypeContextImpl;
class OperatorTypeInstance {
    constructor(_version, payload, sid){
        this._version = _version;
        this.name = payload.name;
        this.sid = payload.sid;
        this.friendlyName = payload.friendly_name;
        this.description = payload.description;
        this.docsLink = payload.docs_link;
        this.outputType = payload.output_type;
        this.supportedLanguages = payload.supported_languages;
        this.provider = payload.provider;
        this.availability = payload.availability;
        this.configurable = payload.configurable;
        this.configSchema = payload.config_schema;
        this.dateCreated = deserialize.iso8601DateTime(payload.date_created);
        this.dateUpdated = deserialize.iso8601DateTime(payload.date_updated);
        this.url = payload.url;
        this._solution = {
            sid: sid || this.sid
        };
    }
    get _proxy() {
        this._context = this._context || new OperatorTypeContextImpl(this._version, this._solution.sid);
        return this._context;
    }
    /**
     * Fetch a OperatorTypeInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed OperatorTypeInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a OperatorTypeInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed OperatorTypeInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            name: this.name,
            sid: this.sid,
            friendlyName: this.friendlyName,
            description: this.description,
            docsLink: this.docsLink,
            outputType: this.outputType,
            supportedLanguages: this.supportedLanguages,
            provider: this.provider,
            availability: this.availability,
            configurable: this.configurable,
            configSchema: this.configSchema,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated,
            url: this.url
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.OperatorTypeInstance = OperatorTypeInstance;
function OperatorTypeListInstance(version) {
    const instance = (sid)=>instance.get(sid);
    instance.get = function get(sid) {
        return new OperatorTypeContextImpl(version, sid);
    };
    instance._version = version;
    instance._solution = {};
    instance._uri = `/OperatorTypes`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new OperatorTypePage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new OperatorTypePage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new OperatorTypePage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new OperatorTypePage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class OperatorTypePage extends Page_1.default {
    /**
     * Initialize the OperatorTypePage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of OperatorTypeInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new OperatorTypeInstance(this._version, payload);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.OperatorTypePage = OperatorTypePage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/intelligence/v2/prebuiltOperator.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Intelligence
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PrebuiltOperatorPage = exports.PrebuiltOperatorInstance = exports.PrebuiltOperatorContextImpl = void 0;
exports.PrebuiltOperatorListInstance = PrebuiltOperatorListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
class PrebuiltOperatorContextImpl {
    constructor(_version, sid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(sid)) {
            throw new Error("Parameter 'sid' is not valid.");
        }
        this._solution = {
            sid
        };
        this._uri = `/Operators/PreBuilt/${sid}`;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new PrebuiltOperatorInstance(operationVersion, payload, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new PrebuiltOperatorInstance(operationVersion, response.body, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.PrebuiltOperatorContextImpl = PrebuiltOperatorContextImpl;
class PrebuiltOperatorInstance {
    constructor(_version, payload, sid){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.sid = payload.sid;
        this.friendlyName = payload.friendly_name;
        this.description = payload.description;
        this.author = payload.author;
        this.operatorType = payload.operator_type;
        this.version = deserialize.integer(payload.version);
        this.availability = payload.availability;
        this.config = payload.config;
        this.dateCreated = deserialize.iso8601DateTime(payload.date_created);
        this.dateUpdated = deserialize.iso8601DateTime(payload.date_updated);
        this.url = payload.url;
        this._solution = {
            sid: sid || this.sid
        };
    }
    get _proxy() {
        this._context = this._context || new PrebuiltOperatorContextImpl(this._version, this._solution.sid);
        return this._context;
    }
    /**
     * Fetch a PrebuiltOperatorInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed PrebuiltOperatorInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a PrebuiltOperatorInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed PrebuiltOperatorInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            sid: this.sid,
            friendlyName: this.friendlyName,
            description: this.description,
            author: this.author,
            operatorType: this.operatorType,
            version: this.version,
            availability: this.availability,
            config: this.config,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated,
            url: this.url
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.PrebuiltOperatorInstance = PrebuiltOperatorInstance;
function PrebuiltOperatorListInstance(version) {
    const instance = (sid)=>instance.get(sid);
    instance.get = function get(sid) {
        return new PrebuiltOperatorContextImpl(version, sid);
    };
    instance._version = version;
    instance._solution = {};
    instance._uri = `/Operators/PreBuilt`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["availability"] !== undefined) data["Availability"] = params["availability"];
        if (params["languageCode"] !== undefined) data["LanguageCode"] = params["languageCode"];
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new PrebuiltOperatorPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new PrebuiltOperatorPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["availability"] !== undefined) data["Availability"] = params["availability"];
        if (params["languageCode"] !== undefined) data["LanguageCode"] = params["languageCode"];
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new PrebuiltOperatorPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new PrebuiltOperatorPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class PrebuiltOperatorPage extends Page_1.default {
    /**
     * Initialize the PrebuiltOperatorPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of PrebuiltOperatorInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new PrebuiltOperatorInstance(this._version, payload);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.PrebuiltOperatorPage = PrebuiltOperatorPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/intelligence/v2/service.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Intelligence
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ServicePage = exports.ServiceInstance = exports.ServiceContextImpl = void 0;
exports.ServiceListInstance = ServiceListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
class ServiceContextImpl {
    constructor(_version, sid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(sid)) {
            throw new Error("Parameter 'sid' is not valid.");
        }
        this._solution = {
            sid
        };
        this._uri = `/Services/${sid}`;
    }
    remove(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.remove({
            uri: instance._uri,
            method: "delete",
            headers
        });
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    removeWithHttpInfo(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version;
        // DELETE operation - returns boolean based on status code
        let operationPromise = operationVersion.removeWithResponseInfo({
            uri: instance._uri,
            method: "delete",
            headers
        }).then((response)=>({
                ...response,
                body: response.statusCode === 204
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new ServiceInstance(operationVersion, payload, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new ServiceInstance(operationVersion, response.body, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    update(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["autoTranscribe"] !== undefined) data["AutoTranscribe"] = serialize.bool(params["autoTranscribe"]);
        if (params["dataLogging"] !== undefined) data["DataLogging"] = serialize.bool(params["dataLogging"]);
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["uniqueName"] !== undefined) data["UniqueName"] = params["uniqueName"];
        if (params["autoRedaction"] !== undefined) data["AutoRedaction"] = serialize.bool(params["autoRedaction"]);
        if (params["mediaRedaction"] !== undefined) data["MediaRedaction"] = serialize.bool(params["mediaRedaction"]);
        if (params["webhookUrl"] !== undefined) data["WebhookUrl"] = params["webhookUrl"];
        if (params["webhookHttpMethod"] !== undefined) data["WebhookHttpMethod"] = params["webhookHttpMethod"];
        if (params["encryptionCredentialSid"] !== undefined) data["EncryptionCredentialSid"] = params["encryptionCredentialSid"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        if (params["ifMatch"] !== undefined) headers["If-Match"] = params["ifMatch"];
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.update({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new ServiceInstance(operationVersion, payload, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    updateWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["autoTranscribe"] !== undefined) data["AutoTranscribe"] = serialize.bool(params["autoTranscribe"]);
        if (params["dataLogging"] !== undefined) data["DataLogging"] = serialize.bool(params["dataLogging"]);
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["uniqueName"] !== undefined) data["UniqueName"] = params["uniqueName"];
        if (params["autoRedaction"] !== undefined) data["AutoRedaction"] = serialize.bool(params["autoRedaction"]);
        if (params["mediaRedaction"] !== undefined) data["MediaRedaction"] = serialize.bool(params["mediaRedaction"]);
        if (params["webhookUrl"] !== undefined) data["WebhookUrl"] = params["webhookUrl"];
        if (params["webhookHttpMethod"] !== undefined) data["WebhookHttpMethod"] = params["webhookHttpMethod"];
        if (params["encryptionCredentialSid"] !== undefined) data["EncryptionCredentialSid"] = params["encryptionCredentialSid"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        if (params["ifMatch"] !== undefined) headers["If-Match"] = params["ifMatch"];
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.updateWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new ServiceInstance(operationVersion, response.body, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.ServiceContextImpl = ServiceContextImpl;
class ServiceInstance {
    constructor(_version, payload, sid){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.autoRedaction = payload.auto_redaction;
        this.mediaRedaction = payload.media_redaction;
        this.autoTranscribe = payload.auto_transcribe;
        this.dataLogging = payload.data_logging;
        this.dateCreated = deserialize.iso8601DateTime(payload.date_created);
        this.dateUpdated = deserialize.iso8601DateTime(payload.date_updated);
        this.friendlyName = payload.friendly_name;
        this.languageCode = payload.language_code;
        this.sid = payload.sid;
        this.uniqueName = payload.unique_name;
        this.url = payload.url;
        this.webhookUrl = payload.webhook_url;
        this.webhookHttpMethod = payload.webhook_http_method;
        this.readOnlyAttachedOperatorSids = payload.read_only_attached_operator_sids;
        this.version = deserialize.integer(payload.version);
        this.encryptionCredentialSid = payload.encryption_credential_sid;
        this._solution = {
            sid: sid || this.sid
        };
    }
    get _proxy() {
        this._context = this._context || new ServiceContextImpl(this._version, this._solution.sid);
        return this._context;
    }
    /**
     * Remove a ServiceInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean
     */ remove(callback) {
        return this._proxy.remove(callback);
    }
    /**
     * Remove a ServiceInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean with HTTP metadata
     */ removeWithHttpInfo(callback) {
        return this._proxy.removeWithHttpInfo(callback);
    }
    /**
     * Fetch a ServiceInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed ServiceInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a ServiceInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed ServiceInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    update(params, callback) {
        return this._proxy.update(params, callback);
    }
    updateWithHttpInfo(params, callback) {
        return this._proxy.updateWithHttpInfo(params, callback);
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            autoRedaction: this.autoRedaction,
            mediaRedaction: this.mediaRedaction,
            autoTranscribe: this.autoTranscribe,
            dataLogging: this.dataLogging,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated,
            friendlyName: this.friendlyName,
            languageCode: this.languageCode,
            sid: this.sid,
            uniqueName: this.uniqueName,
            url: this.url,
            webhookUrl: this.webhookUrl,
            webhookHttpMethod: this.webhookHttpMethod,
            readOnlyAttachedOperatorSids: this.readOnlyAttachedOperatorSids,
            version: this.version,
            encryptionCredentialSid: this.encryptionCredentialSid
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.ServiceInstance = ServiceInstance;
function ServiceListInstance(version) {
    const instance = (sid)=>instance.get(sid);
    instance.get = function get(sid) {
        return new ServiceContextImpl(version, sid);
    };
    instance._version = version;
    instance._solution = {};
    instance._uri = `/Services`;
    instance.create = function create(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["uniqueName"] === null || params["uniqueName"] === undefined) {
            throw new Error("Required parameter \"params['uniqueName']\" missing.");
        }
        let data = {};
        data["UniqueName"] = params["uniqueName"];
        if (params["autoTranscribe"] !== undefined) data["AutoTranscribe"] = serialize.bool(params["autoTranscribe"]);
        if (params["dataLogging"] !== undefined) data["DataLogging"] = serialize.bool(params["dataLogging"]);
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["languageCode"] !== undefined) data["LanguageCode"] = params["languageCode"];
        if (params["autoRedaction"] !== undefined) data["AutoRedaction"] = serialize.bool(params["autoRedaction"]);
        if (params["mediaRedaction"] !== undefined) data["MediaRedaction"] = serialize.bool(params["mediaRedaction"]);
        if (params["webhookUrl"] !== undefined) data["WebhookUrl"] = params["webhookUrl"];
        if (params["webhookHttpMethod"] !== undefined) data["WebhookHttpMethod"] = params["webhookHttpMethod"];
        if (params["encryptionCredentialSid"] !== undefined) data["EncryptionCredentialSid"] = params["encryptionCredentialSid"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.create({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new ServiceInstance(operationVersion, payload));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.createWithHttpInfo = function createWithHttpInfo(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["uniqueName"] === null || params["uniqueName"] === undefined) {
            throw new Error("Required parameter \"params['uniqueName']\" missing.");
        }
        let data = {};
        data["UniqueName"] = params["uniqueName"];
        if (params["autoTranscribe"] !== undefined) data["AutoTranscribe"] = serialize.bool(params["autoTranscribe"]);
        if (params["dataLogging"] !== undefined) data["DataLogging"] = serialize.bool(params["dataLogging"]);
        if (params["friendlyName"] !== undefined) data["FriendlyName"] = params["friendlyName"];
        if (params["languageCode"] !== undefined) data["LanguageCode"] = params["languageCode"];
        if (params["autoRedaction"] !== undefined) data["AutoRedaction"] = serialize.bool(params["autoRedaction"]);
        if (params["mediaRedaction"] !== undefined) data["MediaRedaction"] = serialize.bool(params["mediaRedaction"]);
        if (params["webhookUrl"] !== undefined) data["WebhookUrl"] = params["webhookUrl"];
        if (params["webhookHttpMethod"] !== undefined) data["WebhookHttpMethod"] = params["webhookHttpMethod"];
        if (params["encryptionCredentialSid"] !== undefined) data["EncryptionCredentialSid"] = params["encryptionCredentialSid"];
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.createWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new ServiceInstance(operationVersion, response.body)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new ServicePage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new ServicePage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new ServicePage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new ServicePage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class ServicePage extends Page_1.default {
    /**
     * Initialize the ServicePage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of ServiceInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new ServiceInstance(this._version, payload);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.ServicePage = ServicePage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/intelligence/v2/transcript/encryptedOperatorResults.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Intelligence
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EncryptedOperatorResultsInstance = exports.EncryptedOperatorResultsContextImpl = void 0;
exports.EncryptedOperatorResultsListInstance = EncryptedOperatorResultsListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
class EncryptedOperatorResultsContextImpl {
    constructor(_version, transcriptSid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(transcriptSid)) {
            throw new Error("Parameter 'transcriptSid' is not valid.");
        }
        this._solution = {
            transcriptSid
        };
        this._uri = `/Transcripts/${transcriptSid}/OperatorResults/Encrypted`;
    }
    fetch(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["redacted"] !== undefined) data["Redacted"] = serialize.bool(params["redacted"]);
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new EncryptedOperatorResultsInstance(operationVersion, payload, instance._solution.transcriptSid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["redacted"] !== undefined) data["Redacted"] = serialize.bool(params["redacted"]);
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                ...response,
                body: new EncryptedOperatorResultsInstance(operationVersion, response.body, instance._solution.transcriptSid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.EncryptedOperatorResultsContextImpl = EncryptedOperatorResultsContextImpl;
class EncryptedOperatorResultsInstance {
    constructor(_version, payload, transcriptSid){
        this._version = _version;
        this.locations = payload.locations;
        this.transcriptSid = payload.transcript_sid;
        this.url = payload.url;
        this._solution = {
            transcriptSid
        };
    }
    get _proxy() {
        this._context = this._context || new EncryptedOperatorResultsContextImpl(this._version, this._solution.transcriptSid);
        return this._context;
    }
    fetch(params, callback) {
        return this._proxy.fetch(params, callback);
    }
    fetchWithHttpInfo(params, callback) {
        return this._proxy.fetchWithHttpInfo(params, callback);
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            locations: this.locations,
            transcriptSid: this.transcriptSid,
            url: this.url
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.EncryptedOperatorResultsInstance = EncryptedOperatorResultsInstance;
function EncryptedOperatorResultsListInstance(version, transcriptSid) {
    if (!(0, utility_1.isValidPathParam)(transcriptSid)) {
        throw new Error("Parameter 'transcriptSid' is not valid.");
    }
    const instance = ()=>instance.get();
    instance.get = function get() {
        return new EncryptedOperatorResultsContextImpl(version, transcriptSid);
    };
    instance._version = version;
    instance._solution = {
        transcriptSid
    };
    instance._uri = ``;
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/intelligence/v2/transcript/encryptedSentences.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Intelligence
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.EncryptedSentencesInstance = exports.EncryptedSentencesContextImpl = void 0;
exports.EncryptedSentencesListInstance = EncryptedSentencesListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
class EncryptedSentencesContextImpl {
    constructor(_version, transcriptSid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(transcriptSid)) {
            throw new Error("Parameter 'transcriptSid' is not valid.");
        }
        this._solution = {
            transcriptSid
        };
        this._uri = `/Transcripts/${transcriptSid}/Sentences/Encrypted`;
    }
    fetch(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["redacted"] !== undefined) data["Redacted"] = serialize.bool(params["redacted"]);
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new EncryptedSentencesInstance(operationVersion, payload, instance._solution.transcriptSid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["redacted"] !== undefined) data["Redacted"] = serialize.bool(params["redacted"]);
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                ...response,
                body: new EncryptedSentencesInstance(operationVersion, response.body, instance._solution.transcriptSid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.EncryptedSentencesContextImpl = EncryptedSentencesContextImpl;
class EncryptedSentencesInstance {
    constructor(_version, payload, transcriptSid){
        this._version = _version;
        this.location = payload.location;
        this.transcriptSid = payload.transcript_sid;
        this.url = payload.url;
        this._solution = {
            transcriptSid
        };
    }
    get _proxy() {
        this._context = this._context || new EncryptedSentencesContextImpl(this._version, this._solution.transcriptSid);
        return this._context;
    }
    fetch(params, callback) {
        return this._proxy.fetch(params, callback);
    }
    fetchWithHttpInfo(params, callback) {
        return this._proxy.fetchWithHttpInfo(params, callback);
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            location: this.location,
            transcriptSid: this.transcriptSid,
            url: this.url
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.EncryptedSentencesInstance = EncryptedSentencesInstance;
function EncryptedSentencesListInstance(version, transcriptSid) {
    if (!(0, utility_1.isValidPathParam)(transcriptSid)) {
        throw new Error("Parameter 'transcriptSid' is not valid.");
    }
    const instance = ()=>instance.get();
    instance.get = function get() {
        return new EncryptedSentencesContextImpl(version, transcriptSid);
    };
    instance._version = version;
    instance._solution = {
        transcriptSid
    };
    instance._uri = ``;
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/intelligence/v2/transcript/media.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Intelligence
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MediaInstance = exports.MediaContextImpl = void 0;
exports.MediaListInstance = MediaListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
class MediaContextImpl {
    constructor(_version, sid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(sid)) {
            throw new Error("Parameter 'sid' is not valid.");
        }
        this._solution = {
            sid
        };
        this._uri = `/Transcripts/${sid}/Media`;
    }
    fetch(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["redacted"] !== undefined) data["Redacted"] = serialize.bool(params["redacted"]);
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new MediaInstance(operationVersion, payload, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["redacted"] !== undefined) data["Redacted"] = serialize.bool(params["redacted"]);
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                ...response,
                body: new MediaInstance(operationVersion, response.body, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.MediaContextImpl = MediaContextImpl;
class MediaInstance {
    constructor(_version, payload, sid){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.mediaUrl = payload.media_url;
        this.serviceSid = payload.service_sid;
        this.sid = payload.sid;
        this.url = payload.url;
        this._solution = {
            sid
        };
    }
    get _proxy() {
        this._context = this._context || new MediaContextImpl(this._version, this._solution.sid);
        return this._context;
    }
    fetch(params, callback) {
        return this._proxy.fetch(params, callback);
    }
    fetchWithHttpInfo(params, callback) {
        return this._proxy.fetchWithHttpInfo(params, callback);
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            mediaUrl: this.mediaUrl,
            serviceSid: this.serviceSid,
            sid: this.sid,
            url: this.url
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.MediaInstance = MediaInstance;
function MediaListInstance(version, sid) {
    if (!(0, utility_1.isValidPathParam)(sid)) {
        throw new Error("Parameter 'sid' is not valid.");
    }
    const instance = ()=>instance.get();
    instance.get = function get() {
        return new MediaContextImpl(version, sid);
    };
    instance._version = version;
    instance._solution = {
        sid
    };
    instance._uri = ``;
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/intelligence/v2/transcript/operatorResult.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Intelligence
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.OperatorResultPage = exports.OperatorResultInstance = exports.OperatorResultContextImpl = void 0;
exports.OperatorResultListInstance = OperatorResultListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
class OperatorResultContextImpl {
    constructor(_version, transcriptSid, operatorSid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(transcriptSid)) {
            throw new Error("Parameter 'transcriptSid' is not valid.");
        }
        if (!(0, utility_1.isValidPathParam)(operatorSid)) {
            throw new Error("Parameter 'operatorSid' is not valid.");
        }
        this._solution = {
            transcriptSid,
            operatorSid
        };
        this._uri = `/Transcripts/${transcriptSid}/OperatorResults/${operatorSid}`;
    }
    fetch(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["redacted"] !== undefined) data["Redacted"] = serialize.bool(params["redacted"]);
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new OperatorResultInstance(operationVersion, payload, instance._solution.transcriptSid, instance._solution.operatorSid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["redacted"] !== undefined) data["Redacted"] = serialize.bool(params["redacted"]);
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                ...response,
                body: new OperatorResultInstance(operationVersion, response.body, instance._solution.transcriptSid, instance._solution.operatorSid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.OperatorResultContextImpl = OperatorResultContextImpl;
class OperatorResultInstance {
    constructor(_version, payload, transcriptSid, operatorSid){
        this._version = _version;
        this.operatorType = payload.operator_type;
        this.name = payload.name;
        this.operatorSid = payload.operator_sid;
        this.extractMatch = payload.extract_match;
        this.matchProbability = payload.match_probability;
        this.normalizedResult = payload.normalized_result;
        this.utteranceResults = payload.utterance_results;
        this.utteranceMatch = payload.utterance_match;
        this.predictedLabel = payload.predicted_label;
        this.predictedProbability = payload.predicted_probability;
        this.labelProbabilities = payload.label_probabilities;
        this.extractResults = payload.extract_results;
        this.textGenerationResults = payload.text_generation_results;
        this.jsonResults = payload.json_results;
        this.transcriptSid = payload.transcript_sid;
        this.url = payload.url;
        this._solution = {
            transcriptSid,
            operatorSid: operatorSid || this.operatorSid
        };
    }
    get _proxy() {
        this._context = this._context || new OperatorResultContextImpl(this._version, this._solution.transcriptSid, this._solution.operatorSid);
        return this._context;
    }
    fetch(params, callback) {
        return this._proxy.fetch(params, callback);
    }
    fetchWithHttpInfo(params, callback) {
        return this._proxy.fetchWithHttpInfo(params, callback);
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            operatorType: this.operatorType,
            name: this.name,
            operatorSid: this.operatorSid,
            extractMatch: this.extractMatch,
            matchProbability: this.matchProbability,
            normalizedResult: this.normalizedResult,
            utteranceResults: this.utteranceResults,
            utteranceMatch: this.utteranceMatch,
            predictedLabel: this.predictedLabel,
            predictedProbability: this.predictedProbability,
            labelProbabilities: this.labelProbabilities,
            extractResults: this.extractResults,
            textGenerationResults: this.textGenerationResults,
            jsonResults: this.jsonResults,
            transcriptSid: this.transcriptSid,
            url: this.url
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.OperatorResultInstance = OperatorResultInstance;
function OperatorResultListInstance(version, transcriptSid) {
    if (!(0, utility_1.isValidPathParam)(transcriptSid)) {
        throw new Error("Parameter 'transcriptSid' is not valid.");
    }
    const instance = (operatorSid)=>instance.get(operatorSid);
    instance.get = function get(operatorSid) {
        return new OperatorResultContextImpl(version, transcriptSid, operatorSid);
    };
    instance._version = version;
    instance._solution = {
        transcriptSid
    };
    instance._uri = `/Transcripts/${transcriptSid}/OperatorResults`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["redacted"] !== undefined) data["Redacted"] = serialize.bool(params["redacted"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new OperatorResultPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new OperatorResultPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["redacted"] !== undefined) data["Redacted"] = serialize.bool(params["redacted"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new OperatorResultPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new OperatorResultPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class OperatorResultPage extends Page_1.default {
    /**
     * Initialize the OperatorResultPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of OperatorResultInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new OperatorResultInstance(this._version, payload, this._solution.transcriptSid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.OperatorResultPage = OperatorResultPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/intelligence/v2/transcript/sentence.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Intelligence
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SentencePage = exports.SentenceInstance = void 0;
exports.SentenceListInstance = SentenceListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
function SentenceListInstance(version, transcriptSid) {
    if (!(0, utility_1.isValidPathParam)(transcriptSid)) {
        throw new Error("Parameter 'transcriptSid' is not valid.");
    }
    const instance = {};
    instance._version = version;
    instance._solution = {
        transcriptSid
    };
    instance._uri = `/Transcripts/${transcriptSid}/Sentences`;
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["redacted"] !== undefined) data["Redacted"] = serialize.bool(params["redacted"]);
        if (params["wordTimestamps"] !== undefined) data["WordTimestamps"] = serialize.bool(params["wordTimestamps"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new SentencePage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new SentencePage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["redacted"] !== undefined) data["Redacted"] = serialize.bool(params["redacted"]);
        if (params["wordTimestamps"] !== undefined) data["WordTimestamps"] = serialize.bool(params["wordTimestamps"]);
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new SentencePage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new SentencePage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class SentenceInstance {
    constructor(_version, payload, transcriptSid){
        this._version = _version;
        this.mediaChannel = deserialize.integer(payload.media_channel);
        this.sentenceIndex = deserialize.integer(payload.sentence_index);
        this.startTime = payload.start_time;
        this.endTime = payload.end_time;
        this.transcript = payload.transcript;
        this.sid = payload.sid;
        this.confidence = payload.confidence;
        this.words = payload.words;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            mediaChannel: this.mediaChannel,
            sentenceIndex: this.sentenceIndex,
            startTime: this.startTime,
            endTime: this.endTime,
            transcript: this.transcript,
            sid: this.sid,
            confidence: this.confidence,
            words: this.words
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.SentenceInstance = SentenceInstance;
class SentencePage extends Page_1.default {
    /**
     * Initialize the SentencePage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of SentenceInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new SentenceInstance(this._version, payload, this._solution.transcriptSid);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.SentencePage = SentencePage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/intelligence/v2/transcript.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Intelligence
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TranscriptPage = exports.TranscriptInstance = exports.TranscriptContextImpl = void 0;
exports.TranscriptListInstance = TranscriptListInstance;
const util_1 = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
const Page_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Page.js [app-route] (ecmascript)"));
const deserialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/deserialize.js [app-route] (ecmascript)");
const serialize = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/serialize.js [app-route] (ecmascript)");
const utility_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/utility.js [app-route] (ecmascript)");
const encryptedOperatorResults_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/intelligence/v2/transcript/encryptedOperatorResults.js [app-route] (ecmascript)");
const encryptedSentences_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/intelligence/v2/transcript/encryptedSentences.js [app-route] (ecmascript)");
const media_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/intelligence/v2/transcript/media.js [app-route] (ecmascript)");
const operatorResult_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/intelligence/v2/transcript/operatorResult.js [app-route] (ecmascript)");
const sentence_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/intelligence/v2/transcript/sentence.js [app-route] (ecmascript)");
class TranscriptContextImpl {
    constructor(_version, sid){
        this._version = _version;
        if (!(0, utility_1.isValidPathParam)(sid)) {
            throw new Error("Parameter 'sid' is not valid.");
        }
        this._solution = {
            sid
        };
        this._uri = `/Transcripts/${sid}`;
    }
    get encryptedOperatorResults() {
        this._encryptedOperatorResults = this._encryptedOperatorResults || (0, encryptedOperatorResults_1.EncryptedOperatorResultsListInstance)(this._version, this._solution.sid);
        return this._encryptedOperatorResults;
    }
    get encryptedSentences() {
        this._encryptedSentences = this._encryptedSentences || (0, encryptedSentences_1.EncryptedSentencesListInstance)(this._version, this._solution.sid);
        return this._encryptedSentences;
    }
    get media() {
        this._media = this._media || (0, media_1.MediaListInstance)(this._version, this._solution.sid);
        return this._media;
    }
    get operatorResults() {
        this._operatorResults = this._operatorResults || (0, operatorResult_1.OperatorResultListInstance)(this._version, this._solution.sid);
        return this._operatorResults;
    }
    get sentences() {
        this._sentences = this._sentences || (0, sentence_1.SentenceListInstance)(this._version, this._solution.sid);
        return this._sentences;
    }
    remove(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.remove({
            uri: instance._uri,
            method: "delete",
            headers
        });
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    removeWithHttpInfo(callback) {
        const headers = {};
        const instance = this;
        let operationVersion = instance._version;
        // DELETE operation - returns boolean based on status code
        let operationPromise = operationVersion.removeWithResponseInfo({
            uri: instance._uri,
            method: "delete",
            headers
        }).then((response)=>({
                ...response,
                body: response.statusCode === 204
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetch(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version, operationPromise = operationVersion.fetch({
            uri: instance._uri,
            method: "get",
            headers
        });
        operationPromise = operationPromise.then((payload)=>new TranscriptInstance(operationVersion, payload, instance._solution.sid));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    fetchWithHttpInfo(callback) {
        const headers = {};
        headers["Accept"] = "application/json";
        const instance = this;
        let operationVersion = instance._version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.fetchWithResponseInfo({
            uri: instance._uri,
            method: "get",
            headers
        }).then((response)=>({
                ...response,
                body: new TranscriptInstance(operationVersion, response.body, instance._solution.sid)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return this._solution;
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.TranscriptContextImpl = TranscriptContextImpl;
class TranscriptInstance {
    constructor(_version, payload, sid){
        this._version = _version;
        this.accountSid = payload.account_sid;
        this.serviceSid = payload.service_sid;
        this.sid = payload.sid;
        this.dateCreated = deserialize.iso8601DateTime(payload.date_created);
        this.dateUpdated = deserialize.iso8601DateTime(payload.date_updated);
        this.status = payload.status;
        this.channel = payload.channel;
        this.dataLogging = payload.data_logging;
        this.languageCode = payload.language_code;
        this.customerKey = payload.customer_key;
        this.mediaStartTime = deserialize.iso8601DateTime(payload.media_start_time);
        this.duration = deserialize.integer(payload.duration);
        this.url = payload.url;
        this.redaction = payload.redaction;
        this.encryptionCredentialSid = payload.encryption_credential_sid;
        this.links = payload.links;
        this._solution = {
            sid: sid || this.sid
        };
    }
    get _proxy() {
        this._context = this._context || new TranscriptContextImpl(this._version, this._solution.sid);
        return this._context;
    }
    /**
     * Remove a TranscriptInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean
     */ remove(callback) {
        return this._proxy.remove(callback);
    }
    /**
     * Remove a TranscriptInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed boolean with HTTP metadata
     */ removeWithHttpInfo(callback) {
        return this._proxy.removeWithHttpInfo(callback);
    }
    /**
     * Fetch a TranscriptInstance
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed TranscriptInstance
     */ fetch(callback) {
        return this._proxy.fetch(callback);
    }
    /**
     * Fetch a TranscriptInstance and return HTTP info
     *
     * @param callback - Callback to handle processed record
     *
     * @returns Resolves to processed TranscriptInstance with HTTP metadata
     */ fetchWithHttpInfo(callback) {
        return this._proxy.fetchWithHttpInfo(callback);
    }
    /**
     * Access the encryptedOperatorResults.
     */ encryptedOperatorResults() {
        return this._proxy.encryptedOperatorResults;
    }
    /**
     * Access the encryptedSentences.
     */ encryptedSentences() {
        return this._proxy.encryptedSentences;
    }
    /**
     * Access the media.
     */ media() {
        return this._proxy.media;
    }
    /**
     * Access the operatorResults.
     */ operatorResults() {
        return this._proxy.operatorResults;
    }
    /**
     * Access the sentences.
     */ sentences() {
        return this._proxy.sentences;
    }
    /**
     * Provide a user-friendly representation
     *
     * @returns Object
     */ toJSON() {
        return {
            accountSid: this.accountSid,
            serviceSid: this.serviceSid,
            sid: this.sid,
            dateCreated: this.dateCreated,
            dateUpdated: this.dateUpdated,
            status: this.status,
            channel: this.channel,
            dataLogging: this.dataLogging,
            languageCode: this.languageCode,
            customerKey: this.customerKey,
            mediaStartTime: this.mediaStartTime,
            duration: this.duration,
            url: this.url,
            redaction: this.redaction,
            encryptionCredentialSid: this.encryptionCredentialSid,
            links: this.links
        };
    }
    [util_1.inspect.custom](_depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.TranscriptInstance = TranscriptInstance;
function TranscriptListInstance(version) {
    const instance = (sid)=>instance.get(sid);
    instance.get = function get(sid) {
        return new TranscriptContextImpl(version, sid);
    };
    instance._version = version;
    instance._solution = {};
    instance._uri = `/Transcripts`;
    instance.create = function create(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["serviceSid"] === null || params["serviceSid"] === undefined) {
            throw new Error("Required parameter \"params['serviceSid']\" missing.");
        }
        if (params["channel"] === null || params["channel"] === undefined) {
            throw new Error("Required parameter \"params['channel']\" missing.");
        }
        let data = {};
        data["ServiceSid"] = params["serviceSid"];
        data["Channel"] = serialize.object(params["channel"]);
        if (params["customerKey"] !== undefined) data["CustomerKey"] = params["customerKey"];
        if (params["mediaStartTime"] !== undefined) data["MediaStartTime"] = serialize.iso8601DateTime(params["mediaStartTime"]);
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.create({
            uri: instance._uri,
            method: "post",
            data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new TranscriptInstance(operationVersion, payload));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.createWithHttpInfo = function createWithHttpInfo(params, callback) {
        if (params === null || params === undefined) {
            throw new Error('Required parameter "params" missing.');
        }
        if (params["serviceSid"] === null || params["serviceSid"] === undefined) {
            throw new Error("Required parameter \"params['serviceSid']\" missing.");
        }
        if (params["channel"] === null || params["channel"] === undefined) {
            throw new Error("Required parameter \"params['channel']\" missing.");
        }
        let data = {};
        data["ServiceSid"] = params["serviceSid"];
        data["Channel"] = serialize.object(params["channel"]);
        if (params["customerKey"] !== undefined) data["CustomerKey"] = params["customerKey"];
        if (params["mediaStartTime"] !== undefined) data["MediaStartTime"] = serialize.iso8601DateTime(params["mediaStartTime"]);
        const headers = {};
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // CREATE, FETCH, UPDATE operations
        let operationPromise = operationVersion.createWithResponseInfo({
            uri: instance._uri,
            method: "post",
            data,
            headers
        }).then((response)=>({
                ...response,
                body: new TranscriptInstance(operationVersion, response.body)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.page = function page(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["serviceSid"] !== undefined) data["ServiceSid"] = params["serviceSid"];
        if (params["beforeStartTime"] !== undefined) data["BeforeStartTime"] = params["beforeStartTime"];
        if (params["afterStartTime"] !== undefined) data["AfterStartTime"] = params["afterStartTime"];
        if (params["beforeDateCreated"] !== undefined) data["BeforeDateCreated"] = params["beforeDateCreated"];
        if (params["afterDateCreated"] !== undefined) data["AfterDateCreated"] = params["afterDateCreated"];
        if (params["status"] !== undefined) data["Status"] = params["status"];
        if (params["languageCode"] !== undefined) data["LanguageCode"] = params["languageCode"];
        if (params["sourceSid"] !== undefined) data["SourceSid"] = params["sourceSid"];
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version, operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        });
        operationPromise = operationPromise.then((payload)=>new TranscriptPage(operationVersion, payload, instance._solution));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.list = instance._version.list;
    instance.getPage = function getPage(targetUrl, callback) {
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((payload)=>new TranscriptPage(instance._version, payload, instance._solution));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.pageWithHttpInfo = function pageWithHttpInfo(params, callback) {
        if (params instanceof Function) {
            callback = params;
            params = {};
        } else {
            params = params || {};
        }
        let data = {};
        if (params["serviceSid"] !== undefined) data["ServiceSid"] = params["serviceSid"];
        if (params["beforeStartTime"] !== undefined) data["BeforeStartTime"] = params["beforeStartTime"];
        if (params["afterStartTime"] !== undefined) data["AfterStartTime"] = params["afterStartTime"];
        if (params["beforeDateCreated"] !== undefined) data["BeforeDateCreated"] = params["beforeDateCreated"];
        if (params["afterDateCreated"] !== undefined) data["AfterDateCreated"] = params["afterDateCreated"];
        if (params["status"] !== undefined) data["Status"] = params["status"];
        if (params["languageCode"] !== undefined) data["LanguageCode"] = params["languageCode"];
        if (params["sourceSid"] !== undefined) data["SourceSid"] = params["sourceSid"];
        if (params["pageSize"] !== undefined) data["PageSize"] = params["pageSize"];
        if (params.pageNumber !== undefined) data["Page"] = params.pageNumber;
        if (params.pageToken !== undefined) data["PageToken"] = params.pageToken;
        const headers = {};
        headers["Accept"] = "application/json";
        let operationVersion = version;
        // For page operations, use page() directly as it already returns { statusCode, body, headers }
        // IMPORTANT: Pass full response to Page constructor, not response.body
        let operationPromise = operationVersion.page({
            uri: instance._uri,
            method: "get",
            params: data,
            headers
        }).then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new TranscriptPage(operationVersion, response, instance._solution)
            }));
        operationPromise = instance._version.setPromiseCallback(operationPromise, callback);
        return operationPromise;
    };
    instance.each = instance._version.each;
    instance.eachWithHttpInfo = instance._version.eachWithHttpInfo;
    instance.list = instance._version.list;
    instance.listWithHttpInfo = instance._version.listWithHttpInfo;
    instance.getPageWithHttpInfo = function getPageWithHttpInfo(targetUrl, callback) {
        // Use request() directly as it already returns { statusCode, body, headers }
        const operationPromise = instance._version._domain.twilio.request({
            method: "get",
            uri: targetUrl
        });
        let pagePromise = operationPromise.then((response)=>({
                statusCode: response.statusCode,
                headers: response.headers,
                body: new TranscriptPage(instance._version, response, instance._solution)
            }));
        pagePromise = instance._version.setPromiseCallback(pagePromise, callback);
        return pagePromise;
    };
    instance.toJSON = function toJSON() {
        return instance._solution;
    };
    instance[util_1.inspect.custom] = function inspectImpl(_depth, options) {
        return (0, util_1.inspect)(instance.toJSON(), options);
    };
    return instance;
}
class TranscriptPage extends Page_1.default {
    /**
     * Initialize the TranscriptPage
     *
     * @param version - Version of the resource
     * @param response - Response from the API
     * @param solution - Path solution
     */ constructor(version, response, solution){
        super(version, response, solution);
    }
    /**
     * Build an instance of TranscriptInstance
     *
     * @param payload - Payload response from the API
     */ getInstance(payload) {
        return new TranscriptInstance(this._version, payload);
    }
    [util_1.inspect.custom](depth, options) {
        return (0, util_1.inspect)(this.toJSON(), options);
    }
}
exports.TranscriptPage = TranscriptPage;
}),
"[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/intelligence/V2.js [app-route] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*
 * This code was generated by
 * ___ _ _ _ _ _    _ ____    ____ ____ _    ____ ____ _  _ ____ ____ ____ ___ __   __
 *  |  | | | | |    | |  | __ |  | |__| | __ | __ |___ |\ | |___ |__/ |__|  | |  | |__/
 *  |  |_|_| | |___ | |__|    |__| |  | |    |__] |___ | \| |___ |  \ |  |  | |__| |  \
 *
 * Twilio - Intelligence
 * This is the public Twilio REST API.
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
const Version_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/base/Version.js [app-route] (ecmascript)"));
const customOperator_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/intelligence/v2/customOperator.js [app-route] (ecmascript)");
const operator_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/intelligence/v2/operator.js [app-route] (ecmascript)");
const operatorAttachment_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/intelligence/v2/operatorAttachment.js [app-route] (ecmascript)");
const operatorAttachments_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/intelligence/v2/operatorAttachments.js [app-route] (ecmascript)");
const operatorType_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/intelligence/v2/operatorType.js [app-route] (ecmascript)");
const prebuiltOperator_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/intelligence/v2/prebuiltOperator.js [app-route] (ecmascript)");
const service_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/intelligence/v2/service.js [app-route] (ecmascript)");
const transcript_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/twilio@5.12.0/node_modules/twilio/lib/rest/intelligence/v2/transcript.js [app-route] (ecmascript)");
class V2 extends Version_1.default {
    /**
     * Initialize the V2 version of Intelligence
     *
     * @param domain - The Twilio (Twilio.Intelligence) domain
     */ constructor(domain){
        super(domain, "v2");
    }
    /** Getter for customOperators resource */ get customOperators() {
        this._customOperators = this._customOperators || (0, customOperator_1.CustomOperatorListInstance)(this);
        return this._customOperators;
    }
    /** Getter for operators resource */ get operators() {
        this._operators = this._operators || (0, operator_1.OperatorListInstance)(this);
        return this._operators;
    }
    /** Getter for operatorAttachment resource */ get operatorAttachment() {
        this._operatorAttachment = this._operatorAttachment || (0, operatorAttachment_1.OperatorAttachmentListInstance)(this);
        return this._operatorAttachment;
    }
    /** Getter for operatorAttachments resource */ get operatorAttachments() {
        this._operatorAttachments = this._operatorAttachments || (0, operatorAttachments_1.OperatorAttachmentsListInstance)(this);
        return this._operatorAttachments;
    }
    /** Getter for operatorType resource */ get operatorType() {
        this._operatorType = this._operatorType || (0, operatorType_1.OperatorTypeListInstance)(this);
        return this._operatorType;
    }
    /** Getter for prebuiltOperators resource */ get prebuiltOperators() {
        this._prebuiltOperators = this._prebuiltOperators || (0, prebuiltOperator_1.PrebuiltOperatorListInstance)(this);
        return this._prebuiltOperators;
    }
    /** Getter for services resource */ get services() {
        this._services = this._services || (0, service_1.ServiceListInstance)(this);
        return this._services;
    }
    /** Getter for transcripts resource */ get transcripts() {
        this._transcripts = this._transcripts || (0, transcript_1.TranscriptListInstance)(this);
        return this._transcripts;
    }
}
exports.default = V2;
}),
];

//# sourceMappingURL=96e98_twilio_lib_rest_intelligence_963425ad._.js.map